<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Analysis.Normed.Algebra.GelfandMazur</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Mathlib.Analysis.Normed.Algebra.GelfandMazur";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Analysis</span>.<span class="name">Normed</span>.<span class="name">Algebra</span>.<span class="name">GelfandMazur</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Analysis/Normed/Algebra/GelfandMazur.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init.html">Init</a></li><li><a href="../../../.././Mathlib/Analysis/Polynomial/Factorization.html">Mathlib.Analysis.Polynomial.Factorization</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Analysis.Normed.Algebra.GelfandMazur" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#NormedAlgebra.exists_isMinOn_norm_sub_smul"><span class="name">NormedAlgebra</span>.<span class="name">exists_isMinOn_norm_sub_smul</span></a></div><div class="nav_link"><a class="break_within" href="#NormedAlgebra.Complex.exists_norm_sub_smul_one_eq_zero"><span class="name">NormedAlgebra</span>.<span class="name">Complex</span>.<span class="name">exists_norm_sub_smul_one_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#NormedAlgebra.Complex.algEquivOfNormMul"><span class="name">NormedAlgebra</span>.<span class="name">Complex</span>.<span class="name">algEquivOfNormMul</span></a></div><div class="nav_link"><a class="break_within" href="#NormedAlgebra.Complex.nonempty_algEquiv"><span class="name">NormedAlgebra</span>.<span class="name">Complex</span>.<span class="name">nonempty_algEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#NormedAlgebra.Real.exists_isMonicOfDegree_two_and_aeval_eq_zero"><span class="name">NormedAlgebra</span>.<span class="name">Real</span>.<span class="name">exists_isMonicOfDegree_two_and_aeval_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#NormedAlgebra.Real.nonempty_algEquiv_or"><span class="name">NormedAlgebra</span>.<span class="name">Real</span>.<span class="name">nonempty_algEquiv_or</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="A-new-proof-of-the-Gelfand-Mazur-Theorem">A (new?) proof of the Gelfand-Mazur Theorem <a class="hover-link" href="#A-new-proof-of-the-Gelfand-Mazur-Theorem">#</a></h1><p>We provide a formalization of proofs of the following versions of the <em>Gelfand-Mazur Theorem</em>.</p><ul>
<li><p><code><a href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.Complex.algEquivOfNormMul">NormedAlgebra.Complex.algEquivOfNormMul</a></code>: if <code>F</code> is a nontrivial normed <code>‚ÑÇ</code>-algebra
with multiplicative norm, then we obtain a <code>‚ÑÇ</code>-algebra equivalence with <code>‚ÑÇ</code>.</p>
<p>This differs from <code>NormedRing.algEquivComplexOfComplete</code> in the assumptions: there,</p>
<ul>
<li><code>F</code> is assumed to be complete,</li>
<li><code>F</code> is assumed to be a (nontrivial) division ring,</li>
<li>but the norm is only required to be submultiplicative.</li>
</ul>
</li>
<li><p><code><a href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.Complex.nonempty_algEquiv">NormedAlgebra.Complex.nonempty_algEquiv</a></code>: A nontrivial normed <code>‚ÑÇ</code>-algebra
with multiplicative norm is isomorphic to <code>‚ÑÇ</code> as a <code>‚ÑÇ</code>-algebra.</p>
</li>
<li><p><code><a href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.Real.nonempty_algEquiv_or">NormedAlgebra.Real.nonempty_algEquiv_or</a></code>: if a field <code>F</code> is a normed <code>‚Ñù</code>-algebra,
then <code>F</code> is isomorphic as an <code>‚Ñù</code>-algebra either to <code>‚Ñù</code> or to <code>‚ÑÇ</code>.</p>
<p>With some additional work (TODO), this implies a
<a href="https://en.wikipedia.org/wiki/Ostrowski%27s_theorem#Another_Ostrowski%27s_theorem">Theorem of Ostrowski</a>,
which says that any field that is complete with respect to an archimedean absolute value
is isomorphic to either <code>‚Ñù</code> or <code>‚ÑÇ</code> as a field with absolute value. The additional input needed
for this is to show that any such field is in fact a normed <code>‚Ñù</code>-algebra.</p>
</li>
</ul><h3 class="markdown-heading" id="The-complex-case">The complex case <a class="hover-link" href="#The-complex-case">#</a></h3><p>The proof we use here is a variant of a proof for the complex case (any normed <code>‚ÑÇ</code>-algebra
is isomorphic to <code>‚ÑÇ</code>) that is originally due to Ostrowski
[A. Ostrowski, <em>√úber einige L√∂sungen der Funktionalgleichung œÜ(x)‚ãÖœÜ(y)=œÜ(xy)</em>
(Section 7)][ostrowski1916].
See also the concise version provided by Peter Scholze on
<a href="https://mathoverflow.net/questions/10535/ways-to-prove-the-fundamental-theorem-of-algebra/420803#420803">Math Overflow</a>.</p><p>(In the following, we write <code>a ‚Ä¢ 1</code> instead of <code><a href="../../../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a> _ F a</code> for easier reading.
In the code, we use <code><a href="../../../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a></code>.)</p><p>This proof goes as follows. Let <code>x : F</code> be arbitrary; we need to show that <code>x = z ‚Ä¢ 1</code>
for some <code>z : ‚ÑÇ</code>. We consider the function <code>z ‚Ü¶ ‚Äñx - z ‚Ä¢ 1‚Äñ</code>. It has a minimum <code>M</code>,
which it attains at some point <code>z‚ÇÄ</code>, which (upon replacing <code>x</code> by <code>x - z‚ÇÄ ‚Ä¢ 1</code>) we can
assume to be zero. If <code>M = 0</code>, we are done, so assume not. For <code>n : ‚Ñï</code>,
a primitive <code>n</code>th root of unity <code>Œ∂ : ‚ÑÇ</code>, and <code>z : ‚ÑÇ</code> with <code>|z| &lt; M = ‚Äñx‚Äñ</code> we then have that
<code>M ‚â§ ‚Äñx - z ‚Ä¢ 1‚Äñ = ‚Äñx ^ n - z ^ n ‚Ä¢ 1‚Äñ / ‚àè 0 &lt; k &lt; n, ‚Äñx - (Œ∂ ^ k * z) ‚Ä¢ 1‚Äñ</code>,
which is bounded by <code>(M ^ n + |z| ^ n) / M ^ (n - 1) = M * (1 + (|z| / M) ^ n)</code>.
Letting <code>n</code> tend to infinity then shows that <code>‚Äñx - z ‚Ä¢ 1‚Äñ = M</code>
(see <code>NormedAlgebra.norm_eq_of_isMinOn_of_forall_le</code>).
This implies that the set of <code>z</code> such that <code>‚Äñx - z ‚Ä¢ 1‚Äñ = M</code> is closed and open
(and nonempty), so it is all of <code>‚ÑÇ</code>, which contradicts <code>‚Äñx - z ‚Ä¢ 1‚Äñ ‚â• |z| - M</code>
when <code>|z|</code> is sufficiently large.</p><h3 class="markdown-heading" id="The-real-case">The real case <a class="hover-link" href="#The-real-case">#</a></h3><p>The usual proof for the real case is &quot;either <code>F</code> contains a square root of <code>-1</code>;
then <code>F</code> is in fact a normed <code>‚ÑÇ</code>-agebra and we can use the result above, or else
we adjoin a square root of <code>-1</code> to <code>F</code> to obtain a normed <code>‚ÑÇ</code>-agebra <code>F'</code> and
apply the result to <code>F'</code>&quot;. The difficulty with formalizing this is that (as of October 2025)
Mathlib does not provide a normed <code>‚ÑÇ</code>-algebra instance for <code>F'</code> (neither for
<code>F' := <a href="../../../.././Mathlib/RingTheory/AdjoinRoot.html#AdjoinRoot">AdjoinRoot</a> (X ^ 2 + 1 : F[X])</code> nor for <code>F' := <a href="../../../.././Mathlib/LinearAlgebra/TensorProduct/Basic.html#TensorProduct">TensorProduct</a> ‚Ñù ‚ÑÇ F</code>),
and it is not so straight-forward to set this up. So we take inspiration from the
proof sketched above for the complex case to obtain a direct proof.
An additional benefit is that this approach minimizes imports.</p><p>Since irreducible polynomials over <code>‚Ñù</code> have degree at most <code>2</code>, it must be the case
that each element is annihilated by a monic polynomial of degree <code>2</code>.
We fix <code>x : F</code> in the following.</p><p>The space <code>‚Ñù √ó ‚Ñù</code> of monic polynomials of degree <code>2</code> is complete and locally compact
and hence <code>‚Äñaeval x p‚Äñ</code> gets large when <code>p</code> has large coefficients.
This is actually slightly subtle. It is certainly true for <code>‚Äñx - r ‚Ä¢ 1‚Äñ</code> with <code>r : ‚Ñù</code>.
If the minimum of this is zero, then the minimum for monic polynomials of degree <code>2</code>
will also be zero (and is attained on a one-dimensional subset). Otherwise, one can
indeed show that a bound on <code>‚Äñx ^ 2 - a ‚Ä¢ x + b ‚Ä¢ 1‚Äñ</code> implies bounds on <code>|a|</code> and <code>|b|</code>.</p><p>By the first sentence of the previous paragraph, there will be some <code>p‚ÇÄ</code>
such that <code>‚Äñaeval x p‚ÇÄ‚Äñ</code> attains a minimum (see <code>NormedAlgebra.Real.exists_isMinOn_norm_œÜ</code>).
We assume that this is positive and derive a contradiction. Let <code>M := ‚Äñaeval x p‚ÇÄ‚Äñ &gt; 0</code>
be the minimal value.
Since every monic polynomial <code>f : ‚Ñù[X]</code> of even degree can be written as a product
of monic polynomials of degree <code>2</code>
(see <code><a href="../../../.././Mathlib/Analysis/Polynomial/Factorization.html#Polynomial.IsMonicOfDegree.eq_isMonicOfDegree_two_mul_isMonicOfDegree">Polynomial.IsMonicOfDegree.eq_isMonicOfDegree_two_mul_isMonicOfDegree</a></code>),
it follows that <code>‚Äñaeval x f‚Äñ ‚â• M ^ (f.natDegree / 2)</code>.</p><p>The goal is now to show that when <code>a</code> and <code>b</code> achieve the minimum <code>M</code> of <code>‚Äñx ^ 2 - a ‚Ä¢ x + b ‚Ä¢ 1‚Äñ</code>
and <code>M &gt; 0</code>, then we can find some neighborhood <code>U</code> of <code>(a, b)</code> in <code>‚Ñù √ó ‚Ñù</code>
such that <code>‚Äñx ^ 2 - a' ‚Ä¢ x + b' ‚Ä¢ 1‚Äñ = M</code> for all <code>(a', b') ‚àà U</code>
Then the set <code>S = {(a', b') | ‚Äñx ^ 2 - a' ‚Ä¢ x + b' ‚Ä¢ 1‚Äñ = M}</code> must be all of <code>‚Ñù √ó ‚Ñù</code> (as it is
closed, open, and nonempty). (see <code>NormedAlgebra.Real.norm_œÜ_eq_norm_œÜ_of_isMinOn</code>).
This will lead to a contradiction with the growth of <code>‚Äñx ^ 2 - a ‚Ä¢ x‚Äñ</code> as <code>|a|</code> gets large.</p><p>To get there, the idea is, similarly to the complex case, to use the fact that
<code>X ^ 2 - a' * X + b'</code> divides the difference
<code>(X ^ 2 - a * X + b) ^ n - ((a' - a) * X - (b' - b)) ^ n</code>;
this gives us a monic polynomial <code>p</code> of degree <code>2 * (n - 1)</code> such that <code>(X ^ 2 - a' * X + b') * p</code>
equals this difference. By the above, <code>‚Äñaeval x p‚Äñ ‚â• M ^ (n - 1)</code>.</p><p>Since <code>(a', b') ‚Ü¶ x ^ 2 - a' ‚Ä¢ x + b' ‚Ä¢ 1</code> is continuous, there will be a neighborhood <code>U</code>
of <code>(a, b)</code> such that
<code>‚Äñ(a' - a) ‚Ä¢ x - (b' - b) ‚Ä¢ 1‚Äñ = ‚Äñ(x ^ 2 - a ‚Ä¢ x + b ‚Ä¢ 1) - (x ^ 2 -a' ‚Ä¢ x + b' ‚Ä¢ 1)‚Äñ</code>
is less than <code>M</code> for <code>(a', b') ‚àà U</code>. For such <code>(a', b')</code>, it follows that
<code>‚Äñx ^ 2 - a' ‚Ä¢ x + b' ‚Ä¢ 1‚Äñ ‚â§ ‚Äñ(x ^ 2 - a ‚Ä¢ x + b ‚Ä¢ 1) ^ n - ((a' - a) ‚Ä¢ x - (b' - b) ‚Ä¢ 1) ^ n‚Äñ /</code>
<code>‚Äñaeval x p‚Äñ</code>,
which is bounded by <code>(M ^ n + c ^ n) / M ^ (n - 1) = M * (1 + (c / M) ^ n)</code>, where
<code>c = ‚Äñ(a' - a) ‚Ä¢ x - (b' - b) ‚Ä¢ 1‚Äñ &lt; M</code>. So, letting <code>n</code> tend to infinity, we obtain that
<code>M ‚â§ ‚Äñx ^ 2 - a' ‚Ä¢ x + b' ‚Ä¢ 1‚Äñ ‚â§ M</code>, as desired.</p></div><div class="mod_doc"><h3 class="markdown-heading" id="Auxiliary-results-used-in-both-cases">Auxiliary results used in both cases <a class="hover-link" href="#Auxiliary-results-used-in-both-cases">#</a></h3></div><div class="decl" id="NormedAlgebra.exists_isMinOn_norm_sub_smul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Analysis/Normed/Algebra/GelfandMazur.lean#L146-L156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.exists_isMinOn_norm_sub_smul"><span class="name">NormedAlgebra</span>.<span class="name">exists_isMinOn_norm_sub_smul</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ùïú</span> : <a href="../../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Field/Basic.html#NormedField">NormedField</a> <span class="fn">ùïú</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Topology/MetricSpace/ProperSpace.html#ProperSpace">ProperSpace</a> <span class="fn">ùïú</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#SeminormedRing">SeminormedRing</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Module/Basic.html#NormedAlgebra">NormedAlgebra</a> <span class="fn">ùïú</span> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormOneClass">NormOneClass</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">z</span> : <span class="fn">ùïú</span>), <span class="fn"><a href="../../../.././Mathlib/Order/Filter/Extr.html#IsMinOn">IsMinOn</a> <span class="fn">(fun (<span class="fn">x_1</span> : <span class="fn">ùïú</span>) =&gt; <a href="../../../.././Mathlib/Analysis/Normed/Group/Basic.html#Norm.norm">‚Äñ</a><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a> <span class="fn">ùïú</span> <span class="fn">F</span>)</span> <span class="fn">x_1</span></span><a href="../../../.././Mathlib/Analysis/Normed/Group/Basic.html#Norm.norm">‚Äñ</a>)</span> <a href="../../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <span class="fn">z</span></span></span></div></div><p>In a normed algebra <code>F</code> over a normed field <code>ùïú</code> that is a proper space, the function
<code>z : ùïú ‚Ü¶ ‚Äñx - <a href="../../../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a> ùïú F z‚Äñ</code> achieves a global minimum for every <code>x : F</code>.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="The-complex-case">The complex case <a class="hover-link" href="#The-complex-case">#</a></h3></div><div class="decl" id="NormedAlgebra.Complex.exists_norm_sub_smul_one_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Analysis/Normed/Algebra/GelfandMazur.lean#L212-L231">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.Complex.exists_norm_sub_smul_one_eq_zero"><span class="name">NormedAlgebra</span>.<span class="name">Complex</span>.<span class="name">exists_norm_sub_smul_one_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormedRing">NormedRing</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormOneClass">NormOneClass</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormMulClass">NormMulClass</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Module/Basic.html#NormedAlgebra">NormedAlgebra</a> <a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">z</span> : <a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a>), <a href="../../../.././Mathlib/Analysis/Normed/Group/Basic.html#Norm.norm">‚Äñ</a><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a> <a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a> <span class="fn">F</span>)</span> <span class="fn">z</span></span><a href="../../../.././Mathlib/Analysis/Normed/Group/Basic.html#Norm.norm">‚Äñ</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div><p>If <code>F</code> is a normed <code>‚ÑÇ</code>-algebra and <code>x : F</code>, then there is a complex number <code>z</code> such that
<code>‚Äñx - <a href="../../../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a> ‚ÑÇ F z‚Äñ = 0</code> (whence <code>x = <a href="../../../.././Mathlib/Algebra/Algebra/Defs.html#algebraMap">algebraMap</a> ‚ÑÇ F z</code>).</p></div></div><div class="decl" id="NormedAlgebra.Complex.algEquivOfNormMul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Analysis/Normed/Algebra/GelfandMazur.lean#L236-L246">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.Complex.algEquivOfNormMul"><span class="name">NormedAlgebra</span>.<span class="name">Complex</span>.<span class="name">algEquivOfNormMul</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <a href="../../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormedRing">NormedRing</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormOneClass">NormOneClass</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormMulClass">NormMulClass</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Module/Basic.html#NormedAlgebra">NormedAlgebra</a> <a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a> <a href="../../../.././Mathlib/Algebra/Algebra/Equiv.html#AlgEquiv">‚âÉ‚Çê[</a><a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a><a href="../../../.././Mathlib/Algebra/Algebra/Equiv.html#AlgEquiv">]</a> <span class="fn">F</span></div></div><p>A version of the <strong>Gelfand-Mazur Theorem</strong>.</p><p>If <code>F</code> is a nontrivial normed <code>‚ÑÇ</code>-algebra with multiplicative norm, then we obtain a
<code>‚ÑÇ</code>-algebra equivalence with <code>‚ÑÇ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.Complex.algEquivOfNormMul">NormedAlgebra.Complex.algEquivOfNormMul</a> <span class="fn">F</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Algebra/Algebra/Equiv.html#AlgEquiv.ofBijective">AlgEquiv.ofBijective</a> <span class="fn">(<a href="../../../.././Mathlib/Algebra/Algebra/Hom.html#Algebra.ofId">Algebra.ofId</a> <a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a> <span class="fn">F</span>)</span> <span class="fn">‚ãØ</span></span></li></ul></details><details id="instances-for-list-NormedAlgebra.Complex.algEquivOfNormMul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="NormedAlgebra.Complex.nonempty_algEquiv"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Analysis/Normed/Algebra/GelfandMazur.lean#L248-L250">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.Complex.nonempty_algEquiv"><span class="name">NormedAlgebra</span>.<span class="name">Complex</span>.<span class="name">nonempty_algEquiv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <a href="../../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormedRing">NormedRing</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormOneClass">NormOneClass</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormMulClass">NormMulClass</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Module/Basic.html#NormedAlgebra">NormedAlgebra</a> <a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Nonempty">Nonempty</a> (<a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a> <a href="../../../.././Mathlib/Algebra/Algebra/Equiv.html#AlgEquiv">‚âÉ‚Çê[</a><a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a><a href="../../../.././Mathlib/Algebra/Algebra/Equiv.html#AlgEquiv">]</a> <span class="fn">F</span>)</span></div></div><p>A version of the <strong>Gelfand-Mazur Theorem</strong> for nontrivial normed <code>‚ÑÇ</code>-algebras <code>F</code>
with multiplicative norm: any such <code>F</code> is isomorphic to <code>‚ÑÇ</code> as a <code>‚ÑÇ</code>-algebra.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="The-real-case">The real case <a class="hover-link" href="#The-real-case">#</a></h3></div><div class="decl" id="NormedAlgebra.Real.exists_isMonicOfDegree_two_and_aeval_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Analysis/Normed/Algebra/GelfandMazur.lean#L380-L399">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.Real.exists_isMonicOfDegree_two_and_aeval_eq_zero"><span class="name">NormedAlgebra</span>.<span class="name">Real</span>.<span class="name">exists_isMonicOfDegree_two_and_aeval_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">F</span> : <a href="../../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormedRing">NormedRing</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Module/Basic.html#NormedAlgebra">NormedAlgebra</a> <a href="../../../.././Mathlib/Data/Real/Basic.html#Real">‚Ñù</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormOneClass">NormOneClass</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Ring/Basic.html#NormMulClass">NormMulClass</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">F</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">p</span> : <span class="fn"><a href="../../../.././Mathlib/Algebra/Polynomial/Basic.html#Polynomial">Polynomial</a> <a href="../../../.././Mathlib/Data/Real/Basic.html#Real">‚Ñù</a></span>), <span class="fn"><span class="fn"><span class="fn">p</span>.<a href="../../../.././Mathlib/Algebra/Polynomial/Degree/IsMonicOfDegree.html#Polynomial.IsMonicOfDegree">IsMonicOfDegree</a></span> <span class="fn">2</span></span> <a href="../../../.././Init/Prelude.html#And">‚àß</a> <span class="fn"><span class="fn">(<a href="../../../.././Mathlib/Algebra/Polynomial/AlgebraMap.html#Polynomial.aeval">Polynomial.aeval</a> <span class="fn">x</span>)</span> <span class="fn">p</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div><p>If <code>F</code> is a normed <code>‚Ñù</code>-algebra with a multiplicative norm (and such that <code>‚Äñ1‚Äñ = 1</code>),
e.g., a normed division ring, then every <code>x : F</code> is the root of a monic quadratic polynomial
with real coefficients.</p></div></div><div class="decl" id="NormedAlgebra.Real.nonempty_algEquiv_or"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Analysis/Normed/Algebra/GelfandMazur.lean#L401-L411">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Analysis/Normed/Algebra/GelfandMazur.html#NormedAlgebra.Real.nonempty_algEquiv_or"><span class="name">NormedAlgebra</span>.<span class="name">Real</span>.<span class="name">nonempty_algEquiv_or</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <a href="../../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Field/Basic.html#NormedField">NormedField</a> <span class="fn">F</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/Analysis/Normed/Module/Basic.html#NormedAlgebra">NormedAlgebra</a> <a href="../../../.././Mathlib/Data/Real/Basic.html#Real">‚Ñù</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">F</span> <a href="../../../.././Mathlib/Algebra/Algebra/Equiv.html#AlgEquiv">‚âÉ‚Çê[</a><a href="../../../.././Mathlib/Data/Real/Basic.html#Real">‚Ñù</a><a href="../../../.././Mathlib/Algebra/Algebra/Equiv.html#AlgEquiv">]</a> <a href="../../../.././Mathlib/Data/Real/Basic.html#Real">‚Ñù</a>)</span> <a href="../../../.././Init/Prelude.html#Or">‚à®</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">F</span> <a href="../../../.././Mathlib/Algebra/Algebra/Equiv.html#AlgEquiv">‚âÉ‚Çê[</a><a href="../../../.././Mathlib/Data/Real/Basic.html#Real">‚Ñù</a><a href="../../../.././Mathlib/Algebra/Algebra/Equiv.html#AlgEquiv">]</a> <a href="../../../.././Mathlib/Data/Complex/Basic.html#Complex">‚ÑÇ</a>)</span></div></div><p>A version of the <strong>Gelfand-Mazur Theorem</strong> over <code>‚Ñù</code>.</p><p>If a field <code>F</code> is a normed <code>‚Ñù</code>-algebra, then <code>F</code> is isomorphic as an <code>‚Ñù</code>-algebra
either to <code>‚Ñù</code> or to <code>‚ÑÇ</code>.</p></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>