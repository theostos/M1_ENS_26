<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Presentable.OrthogonalReflection</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Presentable.OrthogonalReflection";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Presentable</span>.<span class="name">OrthogonalReflection</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/Adjunction/PartialAdjoint.html">Mathlib.CategoryTheory.Adjunction.PartialAdjoint</a></li><li><a href="../../.././Mathlib/CategoryTheory/Localization/BousfieldTransfiniteComposition.html">Mathlib.CategoryTheory.Localization.BousfieldTransfiniteComposition</a></li><li><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html">Mathlib.CategoryTheory.MorphismProperty.IsSmall</a></li><li><a href="../../.././Mathlib/CategoryTheory/Presentable/Adjunction.html">Mathlib.CategoryTheory.Presentable.Adjunction</a></li><li><a href="../../.././Mathlib/CategoryTheory/SmallObject/TransfiniteIteration.html">Mathlib.CategoryTheory.SmallObject.TransfiniteIteration</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html">Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Presentable.OrthogonalReflection" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.MorphismProperty.isClosedUnderColimitsOfShape_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isClosedUnderColimitsOfShape_isLocal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.MorphismProperty.isCardinalAccessible_ι_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isCardinalAccessible_ι_isLocal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.instSmallD₁OfIsSmallOfLocallySmall"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallD₁OfIsSmallOfLocallySmall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.hasCoproductsOfShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">hasCoproductsOfShape</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.obj₁"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">obj₁</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.obj₂"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">obj₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.l"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">l</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.ιLeft"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_l"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft_comp_l</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_l_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft_comp_l_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">t</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.ιRight"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.ι_comp_t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ι_comp_t</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.ι_comp_t_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ι_comp_t_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft_comp_t</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_t_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft_comp_t_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.step"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">step</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.toStep"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toStep</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanShape_L"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape_L</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanShape_fst"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape_fst</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanShape_snd"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape_snd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanShape_R"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape_R</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.instSmallD₂"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallD₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.instSmallLMultispanShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallLMultispanShape</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.hasColimitsOfShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">hasColimitsOfShape</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanIndex"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanIndex_left"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanIndex_snd"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex_snd</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanIndex_fst"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex_fst</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.multispanIndex_right"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.succ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">succ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.fromStep"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">fromStep</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.condition"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.D₂.condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.toSucc_injectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc_injectivity</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.toSucc_surjectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc_surjectivity</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_isLocal_toSucc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.leftBousfieldW_isLocal_toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">leftBousfieldW_isLocal_toSucc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isIso_toSucc_iff"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isIso_toSucc_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.succStruct"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">succStruct</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.reflectionObj"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">reflectionObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.reflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">reflection</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">transfiniteCompositionOfShapeReflection</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iterationObjSuccIso"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iterationObjSuccIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration_map_succ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration_map_succ_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration_map_succ_injectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_injectivity</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.iteration_map_succ_surjectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_surjectivity</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isLocal_isLocal_reflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_isLocal_reflection</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isLocal_reflectionObj"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_reflectionObj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.corepresentableBy"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">corepresentableBy</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.OrthogonalReflection.isRightAdjoint_ι"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isRightAdjoint_ι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.MorphismProperty.isRightAdjoint_ι_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isRightAdjoint_ι_isLocal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.MorphismProperty.isLocallyPresentable_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isLocallyPresentable_isLocal</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-Orthogonal-reflection-construction">The Orthogonal-reflection construction <a class="hover-link" href="#The-Orthogonal-reflection-construction">#</a></h1><p>Given <code>W : MorphismProperty C</code> (which should be small) and assuming the existence
of certain colimits in <code>C</code>, we construct a morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> for
any <code>Z : C</code>. This morphism belongs to <code>W.isLocal.isLocal</code> and
is an isomorphism iff <code>Z</code> belongs to <code>W.isLocal</code> (see the lemma <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isIso_toSucc_iff">isIso_toSucc_iff</a></code>).
The morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> is defined as a composition
of two morphisms that are roughly described as follows:</p><ul>
<li><code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toStep">toStep</a> W Z : Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code>: for any morphism <code>f : X ⟶ Y</code> satisfying <code>W</code>
and any morphism <code>X ⟶ Z</code>, we &quot;attach&quot; a morphism <code>Y ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> (using
coproducts and a pushout in essentially the same way as it is done in
the file <code><a href="../../.././Mathlib/CategoryTheory/SmallObject/Construction.html">Mathlib/CategoryTheory/SmallObject/Construction.lean</a></code> for the small object
argument);</li>
<li><code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> W Z : <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code>: this morphism coequalizes all pairs
of morphisms <code>g₁ g₂ : Y ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> such that there is a <code>f : X ⟶ Y</code>
satisfying <code>W</code> such that <code>f ≫ g₁ = f ≫ g₂</code>.</li>
</ul><p>The morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> is a variant of the (wrong) definition
p. 32 in the book by Adámek and Rosický. In this book, a slightly different object
as <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> is defined directly as a colimit of an intricate diagram, but
contrary to what is stated on p. 33, it does not satisfy <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isIso_toSucc_iff">isIso_toSucc_iff</a></code>.
The author of this file was unable to not understand the attempt of the authors
to fix this mistake in the errata to this book. This led to the definition
in two steps outlined above.</p><h2 class="markdown-heading" id="Main-results">Main results <a class="hover-link" href="#Main-results">#</a></h2><p>The morphisms described above <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> for all <code>Z : C</code> allow to
define <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct">succStruct</a> W Z₀ : SuccStruct C</code> for any <code>Z₀ : C</code>. By applying
a transfinite iteration to this <code>SuccStruct</code>, we obtain the following results
under the assumption that <code>W : MorphismProperty C</code> is a <code>w</code>-small property
of morphisms in a locally <code>κ</code>-presentable category <code>C</code> (with <code>κ : Cardinal.{w}</code>
a regular cardinal) such that the domains and codomains of the morphisms
satisfying <code>W</code> are <code>κ</code>-presentable:</p><ul>
<li><code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isRightAdjoint_ι_isLocal">MorphismProperty.isRightAdjoint_ι_isLocal</a></code>: existence of the left adjoint
of the inclusion <code>W.isLocal ⥤ C</code>;</li>
<li><code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isLocallyPresentable_isLocal">MorphismProperty.isLocallyPresentable_isLocal</a></code>: the full subcategory
<code>W.isLocal</code> is locally presentable.</li>
</ul><p>This is essentially the implication (i) → (ii) in Theorem 1.39 (and the corollary 1.40)
in the book by Adámek and Rosický (note that according to the
errata to this book, the implication (ii) → (i) is wrong when <code>κ = ℵ₀</code>).</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li>[Adámek, J. and Rosický, J., <em>Locally presentable and accessible categories</em>][Adamek_Rosicky_1994]</li>
</ul></div><div class="decl" id="CategoryTheory.MorphismProperty.isClosedUnderColimitsOfShape_isLocal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L74-L92">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isClosedUnderColimitsOfShape_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isClosedUnderColimitsOfShape_isLocal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">J</span> : <a href="../../.././foundational_types.html">Type</a> u')</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v', u'}</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.EssentiallySmall">EssentiallySmall.{w, v', u'}</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/IsCardinalFiltered.html#CategoryTheory.IsCardinalFiltered">IsCardinalFiltered</a> <span class="fn">J</span> <span class="fn">κ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">κ</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/ColimitsOfShape.html#CategoryTheory.ObjectProperty.IsClosedUnderColimitsOfShape">IsClosedUnderColimitsOfShape</a></span> <span class="fn">J</span></span></div></div></div></div><div class="decl" id="CategoryTheory.MorphismProperty.isCardinalAccessible_ι_isLocal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L94-L101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isCardinalAccessible_ι_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isCardinalAccessible_ι_isLocal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.HasCardinalFilteredColimits">HasCardinalFilteredColimits</a> <span class="fn">C</span> <span class="fn">κ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">κ</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.ι">ι</a></span>.<a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.Functor.IsCardinalAccessible">IsCardinalAccessible</a></span> <span class="fn">κ</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L107-L110">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u v)</div></div><p>Given <code>W : MorphismProperty C</code> and <code>Z : C</code>, this is the index type
parametrising the data of a morphism <code>f : X ⟶ Y</code> satisfying <code>W</code>
and a morphism <code>X ⟶ Z</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">CategoryTheory.OrthogonalReflection.D₁</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">((<span class="fn">f</span> : <span class="fn">↑<span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty.toSet">toSet</a></span></span>) × (<span class="fn"><span class="fn">(↑<span class="fn">f</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.left">left</a></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>))</span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₁" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.instSmallD₁OfIsSmallOfLocallySmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L112-L115">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.instSmallD₁OfIsSmallOfLocallySmall"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallD₁OfIsSmallOfLocallySmall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Small/Defs.html#Small">Small.{w, max u v}</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">D₁</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.hasCoproductsOfShape"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L117-L121">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.hasCoproductsOfShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">hasCoproductsOfShape</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproducts">Limits.HasCoproducts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproductsOfShape">Limits.HasCoproductsOfShape</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">D₁</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.obj₁"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L124-L126">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">obj₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">D₁</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>If <code>d : <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">D₁</a> W Z</code> corresponds to the data of <code>f : X ⟶ Y</code> satisfying <code>W</code> and
of a morphism <code>X ⟶ Z</code>, this is the object <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">d</span>.<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(↑<span class="fn"><span class="fn">d</span>.<a href="../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.left">left</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₁.obj₁" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.obj₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L129-L131">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">obj₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">D₁</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>If <code>d : <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">D₁</a> W Z</code> corresponds to the data of <code>f : X ⟶ Y</code> satisfying <code>W</code> and
of a morphism <code>X ⟶ Z</code>, this is the object <code>Y</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">d</span>.<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(↑<span class="fn"><span class="fn">d</span>.<a href="../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.right">right</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₁.obj₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.l"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L137-L141">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.l"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">l</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">∐</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></div></div><p>Considering all diagrams consisting of a morphism <code>f : X ⟶ Y</code> satisfying <code>W</code>
and of a morphism <code>d : X ⟶ Z</code>, this is the morphism from the coproduct of
all these <code>X</code> objects to <code>Z</code> given by these morphisms <code>d</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.l">CategoryTheory.OrthogonalReflection.D₁.l</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.desc">CategoryTheory.Limits.Sigma.desc</a> <span class="fn">fun (<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">CategoryTheory.OrthogonalReflection.D₁</a> <span class="fn">W</span> <span class="fn">Z</span></span>) =&gt; <span class="fn"><span class="fn">d</span>.<a href="../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₁.l" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.ιLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L144-L147">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">∐</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></div></div><p>The inclusion of a summand in <code>∐ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft">CategoryTheory.OrthogonalReflection.D₁.ιLeft</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι">CategoryTheory.Limits.Sigma.ι</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">CategoryTheory.OrthogonalReflection.D₁.obj₁</a> <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Arrow.html#CategoryTheory.Arrow.mk">CategoryTheory.Arrow.mk</a> <span class="fn">f</span></span>, <span class="fn">hf</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a>, <span class="fn">g</span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₁.ιLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_l"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L150-L153">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_l"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft_comp_l</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft">ιLeft</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.l">l</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_l_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L150-L150">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_l_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft_comp_l_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z✝</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z✝</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft">ιLeft</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.l">l</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.t"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L157-L160">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">t</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">∐</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">∐</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></div></div><p>The coproduct of all the morphisms <code>f</code> indexed by all diagrams
consisting of a morphism <code>f : X ⟶ Y</code> satisfying <code>W</code> and of a morphism <code>d : X ⟶ Z</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.t">CategoryTheory.OrthogonalReflection.D₁.t</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.map">CategoryTheory.Limits.Sigma.map</a> <span class="fn">fun (<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">CategoryTheory.OrthogonalReflection.D₁</a> <span class="fn">W</span> <span class="fn">Z</span></span>) =&gt; <span class="fn"><span class="fn">(↑<span class="fn"><span class="fn">d</span>.<a href="../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.hom">hom</a></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₁.t" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.ιRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L163-L166">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιRight"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">∐</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></div></div><p>The inclusion of a summand in <code>∐ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιRight">CategoryTheory.OrthogonalReflection.D₁.ιRight</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι">CategoryTheory.Limits.Sigma.ι</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">CategoryTheory.OrthogonalReflection.D₁.obj₂</a> <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><a href="../../.././Init/Prelude.html#Subtype.mk">⟨</a><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Comma/Arrow.html#CategoryTheory.Arrow.mk">CategoryTheory.Arrow.mk</a> <span class="fn">f</span></span>, <span class="fn">hf</span><a href="../../.././Init/Prelude.html#Subtype.mk">⟩</a>, <span class="fn">g</span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₁.ιRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.ι_comp_t"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L169-L172">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ι_comp_t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ι_comp_t</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">D₁</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι">Limits.Sigma.ι</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a> <span class="fn">d</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.t">t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(↑<span class="fn"><span class="fn">d</span>.<a href="../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.hom">hom</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι">Limits.Sigma.ι</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a> <span class="fn">d</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.ι_comp_t_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L169-L169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ι_comp_t_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ι_comp_t_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁">D₁</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z✝</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">∐</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z✝</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι">Limits.Sigma.ι</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a> <span class="fn">d</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.t">t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(↑<span class="fn"><span class="fn">d</span>.<a href="../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.hom">hom</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι">Limits.Sigma.ι</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a> <span class="fn">d</span>)</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_t"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L175-L178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_t"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft_comp_t</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft">ιLeft</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.t">t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιRight">ιRight</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_t_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L175-L175">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft_comp_t_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₁</span>.<span class="name">ιLeft_comp_t_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z✝</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.sigmaObj">∐</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">obj₂</a> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z✝</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιLeft">ιLeft</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.t">t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.ιRight">ιRight</a> <span class="fn">f</span> <span class="fn">hf</span> <span class="fn">g</span>)</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.step"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L182-L193">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">step</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>The intermediate object in the definition of the morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> W Z : Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code>.
It is the pushout of the following square:</p><pre><code class="language-lean">∐ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a> ⟶ ∐ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a>
   |           |
   v           v
   Z      ⟶   <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z
</code></pre><p>where the coproduct is taken over all the diagram consisting of a morphism <code>f : X ⟶ Y</code>
satisfying <code>W</code> and a morphism <code>X ⟶ Z</code>. The top map is the coproduct of all of these <code>f</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">CategoryTheory.OrthogonalReflection.step</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.pushout">CategoryTheory.Limits.pushout</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.t">CategoryTheory.OrthogonalReflection.D₁.t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>
    <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.l">CategoryTheory.OrthogonalReflection.D₁.l</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.step" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.toStep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L195-L196">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toStep"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toStep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span></div></div><p>The canonical map from <code>Z</code> to the pushout of <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.t">D₁.t</a> W Z</code> and <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.l">D₁.l</a> W Z</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toStep">CategoryTheory.OrthogonalReflection.toStep</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.pushout.inr">CategoryTheory.Limits.pushout.inr</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.t">CategoryTheory.OrthogonalReflection.D₁.t</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>
    <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.l">CategoryTheory.OrthogonalReflection.D₁.l</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.toStep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L198-L202">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u v)</div></div><p>The index type parametrising the data of two morphisms <code>g₁ g₂ : Y ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code>, and
a map <code>f : X ⟶ Y</code> satisfying <code>W</code> such that <code>f ≫ g₁ = f ≫ g₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanShape"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L204-L211">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape">Limits.MultispanShape</a></div></div><p>The shape of the multicoequalizer of all pairs of morphisms <code>g₁ g₂ : Y ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> with
a <code>f : X ⟶ Y</code> satisfying <code>W</code> such that <code>f ≫ g₁ = f ≫ g₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₂.multispanShape" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanShape_L"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L206-L206">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape_L"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape_L</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂">D₂</a> <span class="fn">W</span> <span class="fn">Z</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanShape_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L206-L206">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape_fst"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂">D₂</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.fst">fst</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../.././Init/Prelude.html#Unit.unit">)</a></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanShape_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L206-L206">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape_snd"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂">D₂</a> <span class="fn">W</span> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.snd">snd</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../.././Init/Prelude.html#Unit.unit">)</a></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanShape_R"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L206-L206">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape_R"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanShape_R</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.R">R</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.instSmallD₂"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L217-L219">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.instSmallD₂"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallD₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Small/Defs.html#Small">Small.{w, max u v}</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂">D₂</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.instSmallLMultispanShape"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L221-L221">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.instSmallLMultispanShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">instSmallLMultispanShape</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Logic/Small/Defs.html#Small">Small.{w, max u v}</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">D₂.multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.hasColimitsOfShape"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L224-L226">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.hasColimitsOfShape"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">hasColimitsOfShape</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">MorphismProperty.IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimitsOfSize">Limits.HasColimitsOfSize.{w, w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimitsOfShape">Limits.HasColimitsOfShape</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.WalkingMultispan">Limits.WalkingMultispan</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>)</span> <span class="fn">C</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanIndex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L230-L237">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex">Limits.MultispanIndex</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">C</span></span></div></div><p>The diagram of the multicoequalizer of all pair of morphisms <code>g₁ g₂ : Y ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> with
a <code>f : X ⟶ Y</code> satisfying <code>W</code> such that <code>f ≫ g₁ = f ≫ g₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.D₂.multispanIndex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanIndex_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L232-L232">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex_left"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex.left">left</a></span> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(↑<span class="fn"><span class="fn">d</span>.<a href="../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Comma/Basic.html#CategoryTheory.Comma.right">right</a></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanIndex_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L232-L232">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex_snd"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex.snd">snd</a></span> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(↑<span class="fn"><span class="fn">d</span>.<a href="../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span>.2</span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanIndex_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L232-L232">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex_fst"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">d</span> : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.L">L</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex.fst">fst</a></span> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(↑<span class="fn"><span class="fn">d</span>.<a href="../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span>.1</span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.multispanIndex_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L232-L232">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex_right"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">multispanIndex_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x✝</span> : <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanShape">multispanShape</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanShape.R">R</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.MultispanIndex.right">right</a></span> <span class="fn">x✝</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.succ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L241-L243">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>The object <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code> is the multicoequalizer of all pairs of morphisms
<code>g₁ g₂ : Y ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> with a <code>f : X ⟶ Y</code> satisfying <code>W</code> such that <code>f ≫ g₁ = f ≫ g₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">CategoryTheory.OrthogonalReflection.succ</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.multicoequalizer">CategoryTheory.Limits.multicoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">CategoryTheory.OrthogonalReflection.D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.succ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.fromStep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L245-L248">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">fromStep</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">Z</span></span></div></div><p>The projection from <code>Z</code> to the multicoequalizer of all morphisms <code>g₁ g₂ : Y ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> W Z</code> with
a <code>f : X ⟶ Y</code> satisfying <code>W</code> such that <code>f ≫ g₁ = f ≫ g₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">CategoryTheory.OrthogonalReflection.fromStep</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.Multicoequalizer.π">CategoryTheory.Limits.Multicoequalizer.π</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">CategoryTheory.OrthogonalReflection.D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <a href="../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../.././Init/Prelude.html#Unit.unit">)</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.fromStep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L251-L256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.condition"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g₁ </span><span class="fn">g₂</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.D₂.condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L251-L251">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">D₂</span>.<span class="name">condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g₁ </span><span class="fn">g₂</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.step">step</a> <span class="fn">W</span> <span class="fn">Z</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g₂</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z✝</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h✝</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z✝</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h✝</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span> <span class="fn">h✝</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.toSucc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L258-L259">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">Z</span></span></div></div><p>The morphism <code>Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> W Z</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">CategoryTheory.OrthogonalReflection.toSucc</a> <span class="fn">W</span> <span class="fn">Z</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toStep">CategoryTheory.OrthogonalReflection.toStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>
    <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">CategoryTheory.OrthogonalReflection.fromStep</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.toSucc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.toSucc_injectivity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L262-L266">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc_injectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc_injectivity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g₁ </span><span class="fn">g₂</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.toSucc_surjectivity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L269-L272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc_surjectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">toSucc_surjectivity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">g'</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">Z</span></span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L274-L286">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_isLocal_toSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/Localization/Bousfield.html#CategoryTheory.ObjectProperty.isLocal">isLocal</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.leftBousfieldW_isLocal_toSucc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L288-L289">source</a></div><div class="attributes">@[deprecated CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc (since := &quot;2025-11-20&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.leftBousfieldW_isLocal_toSucc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">leftBousfieldW_isLocal_toSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/Localization/Bousfield.html#CategoryTheory.ObjectProperty.isLocal">isLocal</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc">CategoryTheory.OrthogonalReflection.isLocal_isLocal_toSucc</a></code>.</p></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isIso_toSucc_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L291-L314">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isIso_toSucc_iff"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isIso_toSucc_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso">IsIso</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span> <span class="fn">Z</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.succStruct"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L325-L329">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">succStruct</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Z₀</span> : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/SmallObject/Iteration/Basic.html#CategoryTheory.SmallObject.SuccStruct">SmallObject.SuccStruct</a> <span class="fn">C</span></span></div></div><p>The successor structure of the orthogonal-reflection construction.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.succStruct" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.reflectionObj"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L334-L335">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">reflectionObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>The transfinite iteration of <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct">succStruct</a> W Z</code> to the power <code>κ.ord.ToType</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">CategoryTheory.OrthogonalReflection.reflectionObj</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct">CategoryTheory.OrthogonalReflection.succStruct</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/SmallObject/TransfiniteIteration.html#CategoryTheory.SmallObject.SuccStruct.iteration">iteration</a></span> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.reflectionObj" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.reflection"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L337-L340">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">reflection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span></span></div></div><p>The map which shall exhibit <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> W Z κ</code> as the image of <code>Z</code> by
the left adjoint of the inclusion of <code>W.isLocal</code>, see <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.corepresentableBy">corepresentableBy</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection">CategoryTheory.OrthogonalReflection.reflection</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct">CategoryTheory.OrthogonalReflection.succStruct</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/SmallObject/TransfiniteIteration.html#CategoryTheory.SmallObject.SuccStruct.ιIteration">ιIteration</a></span> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.reflection" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L342-L349">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">transfiniteCompositionOfShapeReflection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/Localization/Bousfield.html#CategoryTheory.ObjectProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/MorphismProperty/TransfiniteComposition.html#CategoryTheory.MorphismProperty.TransfiniteCompositionOfShape">TransfiniteCompositionOfShape</a></span> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection">reflection</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span></span></div></div><p>The morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection">reflection</a> W Z κ : Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> W Z κ</code> is a transfinite
compositions of morphisms in <code>LeftBousfield.W W.isLocal</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L351-L354">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">noncomputable abbrev</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">Functor</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span></div></div><p>The functor <code>κ.ord.ToType ⥤ C</code> that is the diagram of the
transfinite composition <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection">transfiniteCompositionOfShapeReflection</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">CategoryTheory.OrthogonalReflection.iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection">CategoryTheory.OrthogonalReflection.transfiniteCompositionOfShapeReflection</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/TransfiniteCompositionOfShape.html#CategoryTheory.TransfiniteCompositionOfShape.F">F</a></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.iteration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iterationObjSuccIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L360-L366">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iterationObjSuccIso"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iterationObjSuccIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Order/SuccPred/Basic.html#Order.succ">Order.succ</a> <span class="fn">j</span>)</span></span> <a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> <span class="fn">W</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span></span></div></div><p><code>(iteration W Z κ).obj (Order.<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a> j)</code> identifies to the image of
<code>(iteration W Z κ).obj j</code> by <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succ">succ</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iterationObjSuccIso">CategoryTheory.OrthogonalReflection.iterationObjSuccIso</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span> <span class="fn">j</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.succStruct">CategoryTheory.OrthogonalReflection.succStruct</a> <span class="fn">W</span> <span class="fn">Z</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/SmallObject/TransfiniteIteration.html#CategoryTheory.SmallObject.SuccStruct.iterationFunctorObjSuccIso">iterationFunctorObjSuccIso</a></span> <span class="fn">j</span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.iterationObjSuccIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration_map_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L368-L372">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">⋯</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toSucc">toSucc</a> <span class="fn">W</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span>)</span> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iterationObjSuccIso">iterationObjSuccIso</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span> <span class="fn">j</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration_map_succ_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L368-L368">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ_assoc"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z✝</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Order/SuccPred/Basic.html#Order.succ">Order.succ</a> <span class="fn">j</span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z✝</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">⋯</span>)</span>)</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.toStep">toStep</a> <span class="fn">W</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span>)</span>
    <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.fromStep">fromStep</a> <span class="fn">W</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span>)</span>)</span>
      <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iterationObjSuccIso">iterationObjSuccIso</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span> <span class="fn">j</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.inv">inv</a></span> <span class="fn">h</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration_map_succ_injectivity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L375-L379">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ_injectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_injectivity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g₁ </span><span class="fn">g₂</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">⋯</span>)</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">⋯</span>)</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.iteration_map_succ_surjectivity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L382-L388">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration_map_succ_surjectivity"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">iteration_map_succ_surjectivity</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Z</span> : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">W</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">j</span> : <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (<span class="fn">g'</span> : <span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Order/SuccPred/Basic.html#Order.succ">Order.succ</a> <span class="fn">j</span>)</span></span>),
  <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.iteration">iteration</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map">map</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">homOfLE</a> <span class="fn">⋯</span>)</span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isLocal_isLocal_reflection"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L392-L395">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_isLocal_reflection"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_isLocal_reflection</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/Localization/Bousfield.html#CategoryTheory.ObjectProperty.isLocal">isLocal</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection">reflection</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isLocal_reflectionObj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L402-L427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isLocal_reflectionObj"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isLocal_reflectionObj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">κ</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.corepresentableBy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L429-L434">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.corepresentableBy"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">corepresentableBy</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Z</span> : <span class="fn">C</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">κ</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.ι">ι</a></span>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">comp</a></span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.coyoneda">coyoneda</a>.<a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj">obj</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">Z</span>)</span>)</span>)</span>.<a href="../../.././Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.Functor.CorepresentableBy">CorepresentableBy</a></span> <a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory.mk">{</a> <span class="fn">obj</span> := <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> <span class="fn">W</span> <span class="fn">Z</span> <span class="fn">κ</span></span>, <span class="fn">property</span> := <span class="fn">⋯</span> <a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory.mk">}</a></span></div></div><p>The morphism <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflection">reflection</a> W Z κ : Z ⟶ <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> W Z κ</code> exhibits <code><a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.reflectionObj">reflectionObj</a> W Z κ</code>
as the image of <code>Z</code> by the left adjoint of the inclusion <code>W.isLocal.ι</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.OrthogonalReflection.corepresentableBy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.OrthogonalReflection.isRightAdjoint_ι"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L438-L442">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.isRightAdjoint_ι"><span class="name">CategoryTheory</span>.<span class="name">OrthogonalReflection</span>.<span class="name">isRightAdjoint_ι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullback/HasPullback.html#CategoryTheory.Limits.HasPushouts">Limits.HasPushouts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₁">D₁.obj₁</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.HasCoproduct">Limits.HasCoproduct</a> <a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₁.obj₂">D₁.obj₂</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">Z</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.html#CategoryTheory.Limits.HasMulticoequalizer">Limits.HasMulticoequalizer</a> <span class="fn">(<a href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.OrthogonalReflection.D₂.multispanIndex">D₂.multispanIndex</a> <span class="fn">W</span> <span class="fn">Z</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/BoundedOrder/Basic.html#OrderBot">OrderBot</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Preorder/HasIterationOfShape.html#CategoryTheory.Limits.HasIterationOfShape">Limits.HasIterationOfShape</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord">ord</a></span>.<a href="../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.ToType">ToType</a></span> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">κ</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.ι">ι</a></span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsRightAdjoint">IsRightAdjoint</a></span></div></div></div></div><div class="decl" id="CategoryTheory.MorphismProperty.isRightAdjoint_ι_isLocal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L449-L459">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isRightAdjoint_ι_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isRightAdjoint_ι_isLocal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/EssentiallySmall.html#CategoryTheory.LocallySmall">LocallySmall.{w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">κ</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/HasLimits.html#CategoryTheory.Limits.HasColimitsOfSize">Limits.HasColimitsOfSize.{w, w, v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.ι">ι</a></span>.<a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Functor.IsRightAdjoint">IsRightAdjoint</a></span></div></div></div></div><div class="decl" id="CategoryTheory.MorphismProperty.isLocallyPresentable_isLocal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Presentable/OrthogonalReflection.lean#L461-L468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Presentable/OrthogonalReflection.html#CategoryTheory.MorphismProperty.isLocallyPresentable_isLocal"><span class="name">CategoryTheory</span>.<span class="name">MorphismProperty</span>.<span class="name">isLocallyPresentable_isLocal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">C</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">Category.{v, u}</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">W</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/Basic.html#CategoryTheory.MorphismProperty">MorphismProperty</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">κ</span> : <a href="../../.././Mathlib/SetTheory/Cardinal/Defs.html#Cardinal">Cardinal.{w}</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Logic/Basic.html#Fact">Fact</a> <span class="fn"><span class="fn">κ</span>.<a href="../../.././Mathlib/SetTheory/Cardinal/Regular.html#Cardinal.IsRegular">IsRegular</a></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/LocallyPresentable.html#CategoryTheory.IsCardinalLocallyPresentable">IsCardinalLocallyPresentable</a> <span class="fn">C</span> <span class="fn">κ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/MorphismProperty/IsSmall.html#CategoryTheory.MorphismProperty.IsSmall">IsSmall.{w, v, u}</a> <span class="fn">W</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hW</span> : <span class="fn">∀ ⦃<span class="fn">X </span><span class="fn">Y</span> : <span class="fn">C</span>⦄ (<span class="fn">f</span> : <span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span>), <span class="fn"><span class="fn"><span class="fn">W</span> <span class="fn">f</span></span> → <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">X</span> <span class="fn">κ</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/Basic.html#CategoryTheory.IsCardinalPresentable">IsCardinalPresentable</a> <span class="fn">Y</span> <span class="fn">κ</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Presentable/LocallyPresentable.html#CategoryTheory.IsCardinalLocallyPresentable">IsCardinalLocallyPresentable</a> <span class="fn"><span class="fn"><span class="fn">W</span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/Local.html#CategoryTheory.MorphismProperty.isLocal">isLocal</a></span>.<a href="../../.././Mathlib/CategoryTheory/ObjectProperty/FullSubcategory.html#CategoryTheory.ObjectProperty.FullSubcategory">FullSubcategory</a></span> <span class="fn">κ</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>