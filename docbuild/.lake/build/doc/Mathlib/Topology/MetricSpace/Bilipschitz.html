<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Topology.MetricSpace.Bilipschitz</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Topology.MetricSpace.Bilipschitz";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Topology</span>.<span class="name">MetricSpace</span>.<span class="name">Bilipschitz</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/MetricSpace/Bilipschitz.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Topology/MetricSpace/Antilipschitz.html">Mathlib.Topology.MetricSpace.Antilipschitz</a></li><li><a href="../../.././Mathlib/Topology/MetricSpace/Lipschitz.html">Mathlib.Topology.MetricSpace.Lipschitz</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Topology.MetricSpace.Bilipschitz" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#uniformity_eq_of_bilipschitz"><span class="name">uniformity_eq_of_bilipschitz</span></a></div><div class="nav_link"><a class="break_within" href="#bornology_eq_of_bilipschitz"><span class="name">bornology_eq_of_bilipschitz</span></a></div><div class="nav_link"><a class="break_within" href="#isBounded_iff_of_bilipschitz"><span class="name">isBounded_iff_of_bilipschitz</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Bilipschitz-equivalence">Bilipschitz equivalence <a class="hover-link" href="#Bilipschitz-equivalence">#</a></h1><p>A common pattern in Mathlib is to replace the topology, uniformity and bornology on a type
synonym with those of the underlying type.</p><p>The most common way to do this is to activate a local instance for something which puts a
<code><a href="../../.././Mathlib/Topology/MetricSpace/Pseudo/Defs.html#PseudoMetricSpace">PseudoMetricSpace</a></code> structure on the type synonym, prove that this metric is bilipschitz equivalent
to the metric on the underlying type, and then use this to show that the uniformities and
bornologies agree, which can then be used with <code><a href="../../.././Mathlib/Topology/MetricSpace/Pseudo/Defs.html#PseudoMetricSpace.replaceUniformity">PseudoMetricSpace.replaceUniformity</a></code> or
<code><a href="../../.././Mathlib/Topology/MetricSpace/Pseudo/Defs.html#PseudoMetricSpace.replaceBornology">PseudoMetricSpace.replaceBornology</a></code>.</p><p>With the tooling outside this file, this can be a bit cumbersome, especially when it occurs
repeatedly, and moreover it can lend itself to abuse of the definitional equality inherent in the
type synonym. In this file, we make this pattern more convenient by providing lemmas which take
directly the conditions that the map is bilipschitz, and then prove the relevant equalities.
Moreover, because there are no type synonyms here, it is necessary to phrase these equalities in
terms of the induced uniformity and bornology, which means users will need to do the same if they
choose to use these convenience lemmas. This encourages good hygiene in the development of type
synonyms.</p></div><div class="decl" id="uniformity_eq_of_bilipschitz"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/MetricSpace/Bilipschitz.lean#L43-L62">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/MetricSpace/Bilipschitz.html#uniformity_eq_of_bilipschitz"><span class="name">uniformity_eq_of_bilipschitz</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/EMetricSpace/Defs.html#PseudoEMetricSpace">PseudoEMetricSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/EMetricSpace/Defs.html#PseudoEMetricSpace">PseudoEMetricSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K₁ </span><span class="fn">K₂</span> : <a href="../../.././Mathlib/Data/NNReal/Defs.html#NNReal">NNReal</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf₁</span> : <span class="fn"><a href="../../.././Mathlib/Topology/MetricSpace/Antilipschitz.html#AntilipschitzWith">AntilipschitzWith</a> <span class="fn">K₁</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf₂</span> : <span class="fn"><a href="../../.././Mathlib/Topology/EMetricSpace/Lipschitz.html#LipschitzWith">LipschitzWith</a> <span class="fn">K₂</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#uniformity">uniformity</a> <span class="fn">α</span></span></div></div><p>If <code>f : α → β</code> is bilipschitz, then the pullback of the uniformity on <code>β</code> through <code>f</code> agrees
with the uniformity on <code>α</code>.</p><p>This can be used to provide the replacement equality when applying
<code><a href="../../.././Mathlib/Topology/MetricSpace/Pseudo/Defs.html#PseudoMetricSpace.replaceUniformity">PseudoMetricSpace.replaceUniformity</a></code>, which can be useful when following the forgetful inheritance
pattern when creating type synonyms.</p><p>Important Note: if <code>α</code> is some synonym of a type <code>β</code> (at default transparency), and <code>f : α ≃ β</code> is
some bilipschitz equivalence, then instead of writing:</p><pre><code>instance : <a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> α := <a href="../../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> (UniformSpace β)
</code></pre><p>Users should instead write something like:</p><pre><code>instance : <a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> α := (inferInstance : <a href="../../.././Mathlib/Topology/UniformSpace/Defs.html#UniformSpace">UniformSpace</a> β).comap f
</code></pre><p>in order to avoid abuse of the definitional equality <code>α := β</code>.</p></div></div><div class="decl" id="bornology_eq_of_bilipschitz"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/MetricSpace/Bilipschitz.lean#L73-L77">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/MetricSpace/Bilipschitz.html#bornology_eq_of_bilipschitz"><span class="name">bornology_eq_of_bilipschitz</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/MetricSpace/Pseudo/Defs.html#PseudoMetricSpace">PseudoMetricSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/MetricSpace/Pseudo/Defs.html#PseudoMetricSpace">PseudoMetricSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K₁ </span><span class="fn">K₂</span> : <a href="../../.././Mathlib/Data/NNReal/Defs.html#NNReal">NNReal</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf₁</span> : <span class="fn"><a href="../../.././Mathlib/Topology/MetricSpace/Antilipschitz.html#AntilipschitzWith">AntilipschitzWith</a> <span class="fn">K₁</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf₂</span> : <span class="fn"><a href="../../.././Mathlib/Topology/EMetricSpace/Lipschitz.html#LipschitzWith">LipschitzWith</a> <span class="fn">K₂</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology.cobounded">Bornology.cobounded</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology.cobounded">Bornology.cobounded</a> <span class="fn">α</span></span></div></div><p>If <code>f : α → β</code> is bilipschitz, then the pullback of the bornology on <code>β</code> through <code>f</code> agrees
with the bornology on <code>α</code>.</p></div></div><div class="decl" id="isBounded_iff_of_bilipschitz"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/MetricSpace/Bilipschitz.lean#L80-L99">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/MetricSpace/Bilipschitz.html#isBounded_iff_of_bilipschitz"><span class="name">isBounded_iff_of_bilipschitz</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/MetricSpace/Pseudo/Defs.html#PseudoMetricSpace">PseudoMetricSpace</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/MetricSpace/Pseudo/Defs.html#PseudoMetricSpace">PseudoMetricSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K₁ </span><span class="fn">K₂</span> : <a href="../../.././Mathlib/Data/NNReal/Defs.html#NNReal">NNReal</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf₁</span> : <span class="fn"><a href="../../.././Mathlib/Topology/MetricSpace/Antilipschitz.html#AntilipschitzWith">AntilipschitzWith</a> <span class="fn">K₁</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf₂</span> : <span class="fn"><a href="../../.././Mathlib/Topology/EMetricSpace/Lipschitz.html#LipschitzWith">LipschitzWith</a> <span class="fn">K₂</span> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology.IsBounded">Bornology.IsBounded</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology.IsBounded">Bornology.IsBounded</a> <span class="fn">s</span></span></div></div><p>If <code>f : α → β</code> is bilipschitz, then the pullback of the bornology on <code>β</code> through <code>f</code> agrees
with the bornology on <code>α</code>.</p><p>This can be used to provide the replacement equality when applying
<code><a href="../../.././Mathlib/Topology/MetricSpace/Pseudo/Defs.html#PseudoMetricSpace.replaceBornology">PseudoMetricSpace.replaceBornology</a></code>, which can be useful when following the forgetful inheritance
pattern when creating type synonyms.</p><p>Important Note: if <code>α</code> is some synonym of a type <code>β</code> (at default transparency), and <code>f : α ≃ β</code> is
some bilipschitz equivalence, then instead of writing:</p><pre><code>instance : <a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology">Bornology</a> α := <a href="../../.././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> (Bornology β)
</code></pre><p>Users should instead write something like:</p><pre><code>instance : <a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology">Bornology</a> α := <a href="../../.././Mathlib/Topology/Bornology/Constructions.html#Bornology.induced">Bornology.induced</a> (f : α → β)
</code></pre><p>in order to avoid abuse of the definitional equality <code>α := β</code>.</p></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>