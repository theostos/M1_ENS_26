<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Topology.Compactness.Compact</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Topology.Compactness.Compact";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Topology</span>.<span class="name">Compactness</span>.<span class="name">Compact</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Topology/ContinuousOn.html">Mathlib.Topology.ContinuousOn</a></li><li><a href="../../.././Mathlib/Topology/Ultrafilter.html">Mathlib.Topology.Ultrafilter</a></li><li><a href="../../.././Mathlib/Data/Set/Accumulate.html">Mathlib.Data.Set.Accumulate</a></li><li><a href="../../.././Mathlib/Order/Filter/Tendsto.html">Mathlib.Order.Filter.Tendsto</a></li><li><a href="../../.././Mathlib/Topology/Bornology/Basic.html">Mathlib.Topology.Bornology.Basic</a></li><li><a href="../../.././Mathlib/Topology/Defs/Ultrafilter.html">Mathlib.Topology.Defs.Ultrafilter</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Topology.Compactness.Compact" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#IsCompact.exists_clusterPt"><span class="name">IsCompact</span>.<span class="name">exists_clusterPt</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.exists_mapClusterPt"><span class="name">IsCompact</span>.<span class="name">exists_mapClusterPt</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.exists_clusterPt_of_frequently"><span class="name">IsCompact</span>.<span class="name">exists_clusterPt_of_frequently</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.exists_mapClusterPt_of_frequently"><span class="name">IsCompact</span>.<span class="name">exists_mapClusterPt_of_frequently</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.compl_mem_sets"><span class="name">IsCompact</span>.<span class="name">compl_mem_sets</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.compl_mem_sets_of_nhdsWithin"><span class="name">IsCompact</span>.<span class="name">compl_mem_sets_of_nhdsWithin</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.induction_on"><span class="name">IsCompact</span>.<span class="name">induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.inter_right"><span class="name">IsCompact</span>.<span class="name">inter_right</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.inter_left"><span class="name">IsCompact</span>.<span class="name">inter_left</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.diff"><span class="name">IsCompact</span>.<span class="name">diff</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.of_isClosed_subset"><span class="name">IsCompact</span>.<span class="name">of_isClosed_subset</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.image_of_continuousOn"><span class="name">IsCompact</span>.<span class="name">image_of_continuousOn</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.image"><span class="name">IsCompact</span>.<span class="name">image</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.adherence_nhdset"><span class="name">IsCompact</span>.<span class="name">adherence_nhdset</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_iff_ultrafilter_le_nhds"><span class="name">isCompact_iff_ultrafilter_le_nhds</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.ultrafilter_le_nhds"><span class="name">IsCompact</span>.<span class="name">ultrafilter_le_nhds</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_iff_ultrafilter_le_nhds'"><span class="name">isCompact_iff_ultrafilter_le_nhds'</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.ultrafilter_le_nhds'"><span class="name">IsCompact</span>.<span class="name">ultrafilter_le_nhds'</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.le_nhds_of_unique_clusterPt"><span class="name">IsCompact</span>.<span class="name">le_nhds_of_unique_clusterPt</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.tendsto_nhds_of_unique_mapClusterPt"><span class="name">IsCompact</span>.<span class="name">tendsto_nhds_of_unique_mapClusterPt</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_directed_cover"><span class="name">IsCompact</span>.<span class="name">elim_directed_cover</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_finite_subcover"><span class="name">IsCompact</span>.<span class="name">elim_finite_subcover</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_nhds_subcover_nhdsSet'"><span class="name">IsCompact</span>.<span class="name">elim_nhds_subcover_nhdsSet'</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_nhds_subcover_nhdsSet"><span class="name">IsCompact</span>.<span class="name">elim_nhds_subcover_nhdsSet</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_nhds_subcover'"><span class="name">IsCompact</span>.<span class="name">elim_nhds_subcover'</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_nhds_subcover"><span class="name">IsCompact</span>.<span class="name">elim_nhds_subcover</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_nhdsWithin_subcover'"><span class="name">IsCompact</span>.<span class="name">elim_nhdsWithin_subcover'</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_nhdsWithin_subcover"><span class="name">IsCompact</span>.<span class="name">elim_nhdsWithin_subcover</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.disjoint_nhdsSet_left"><span class="name">IsCompact</span>.<span class="name">disjoint_nhdsSet_left</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.disjoint_nhdsSet_right"><span class="name">IsCompact</span>.<span class="name">disjoint_nhdsSet_right</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_directed_family_closed"><span class="name">IsCompact</span>.<span class="name">elim_directed_family_closed</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_finite_subfamily_closed"><span class="name">IsCompact</span>.<span class="name">elim_finite_subfamily_closed</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.inter_iInter_nonempty"><span class="name">IsCompact</span>.<span class="name">inter_iInter_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed"><span class="name">IsCompact</span>.<span class="name">nonempty_iInter_of_directed_nonempty_isCompact_isClosed</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.nonempty_sInter_of_directed_nonempty_isCompact_isClosed"><span class="name">IsCompact</span>.<span class="name">nonempty_sInter_of_directed_nonempty_isCompact_isClosed</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed"><span class="name">IsCompact</span>.<span class="name">nonempty_iInter_of_sequence_nonempty_isCompact_isClosed</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_finite_subcover_image"><span class="name">IsCompact</span>.<span class="name">elim_finite_subcover_image</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_of_finite_subcover"><span class="name">isCompact_of_finite_subcover</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_of_finite_subfamily_closed"><span class="name">isCompact_of_finite_subfamily_closed</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_iff_finite_subcover"><span class="name">isCompact_iff_finite_subcover</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_iff_finite_subfamily_closed"><span class="name">isCompact_iff_finite_subfamily_closed</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.mem_nhdsSet_prod_of_forall"><span class="name">IsCompact</span>.<span class="name">mem_nhdsSet_prod_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.nhdsSet_prod_eq_biSup"><span class="name">IsCompact</span>.<span class="name">nhdsSet_prod_eq_biSup</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.prod_nhdsSet_eq_biSup"><span class="name">IsCompact</span>.<span class="name">prod_nhdsSet_eq_biSup</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.mem_prod_nhdsSet_of_forall"><span class="name">IsCompact</span>.<span class="name">mem_prod_nhdsSet_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.nhdsSet_inf_eq_biSup"><span class="name">IsCompact</span>.<span class="name">nhdsSet_inf_eq_biSup</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.inf_nhdsSet_eq_biSup"><span class="name">IsCompact</span>.<span class="name">inf_nhdsSet_eq_biSup</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.mem_nhdsSet_inf_of_forall"><span class="name">IsCompact</span>.<span class="name">mem_nhdsSet_inf_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.mem_inf_nhdsSet_of_forall"><span class="name">IsCompact</span>.<span class="name">mem_inf_nhdsSet_of_forall</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.eventually_forall_of_forall_eventually"><span class="name">IsCompact</span>.<span class="name">eventually_forall_of_forall_eventually</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_empty"><span class="name">isCompact_empty</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_singleton"><span class="name">isCompact_singleton</span></a></div><div class="nav_link"><a class="break_within" href="#Set.Subsingleton.isCompact"><span class="name">Set</span>.<span class="name">Subsingleton</span>.<span class="name">isCompact</span></a></div><div class="nav_link"><a class="break_within" href="#Set.Finite.isCompact_biUnion"><span class="name">Set</span>.<span class="name">Finite</span>.<span class="name">isCompact_biUnion</span></a></div><div class="nav_link"><a class="break_within" href="#Finset.isCompact_biUnion"><span class="name">Finset</span>.<span class="name">isCompact_biUnion</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_accumulate"><span class="name">isCompact_accumulate</span></a></div><div class="nav_link"><a class="break_within" href="#Set.Finite.isCompact_sUnion"><span class="name">Set</span>.<span class="name">Finite</span>.<span class="name">isCompact_sUnion</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_iUnion"><span class="name">isCompact_iUnion</span></a></div><div class="nav_link"><a class="break_within" href="#Set.Finite.isCompact"><span class="name">Set</span>.<span class="name">Finite</span>.<span class="name">isCompact</span></a></div><div class="nav_link"><a class="break_within" href="#Set.sUnion_isCompact_eq_univ"><span class="name">Set</span>.<span class="name">sUnion_isCompact_eq_univ</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.finite_of_discrete"><span class="name">IsCompact</span>.<span class="name">finite_of_discrete</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_iff_finite"><span class="name">isCompact_iff_finite</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.union"><span class="name">IsCompact</span>.<span class="name">union</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.insert"><span class="name">IsCompact</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#exists_subset_nhds_of_isCompact'"><span class="name">exists_subset_nhds_of_isCompact'</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_generateFrom"><span class="name">isCompact_generateFrom</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_generateFrom'"><span class="name">isCompact_generateFrom'</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.hasBasis_cocompact"><span class="name">Filter</span>.<span class="name">hasBasis_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_cocompact"><span class="name">Filter</span>.<span class="name">mem_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_cocompact'"><span class="name">Filter</span>.<span class="name">mem_cocompact'</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.compl_mem_cocompact"><span class="name">IsCompact</span>.<span class="name">compl_mem_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.cocompact_le_cofinite"><span class="name">Filter</span>.<span class="name">cocompact_le_cofinite</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.cocompact_eq_cofinite"><span class="name">Filter</span>.<span class="name">cocompact_eq_cofinite</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.disjoint_cocompact_left"><span class="name">Filter</span>.<span class="name">disjoint_cocompact_left</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.disjoint_cocompact_right"><span class="name">Filter</span>.<span class="name">disjoint_cocompact_right</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.Tendsto.isCompact_insert_range_of_cocompact"><span class="name">Filter</span>.<span class="name">Tendsto</span>.<span class="name">isCompact_insert_range_of_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.Tendsto.isCompact_insert_range_of_cofinite"><span class="name">Filter</span>.<span class="name">Tendsto</span>.<span class="name">isCompact_insert_range_of_cofinite</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.Tendsto.isCompact_insert_range"><span class="name">Filter</span>.<span class="name">Tendsto</span>.<span class="name">isCompact_insert_range</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.hasBasis_coclosedCompact"><span class="name">Filter</span>.<span class="name">hasBasis_coclosedCompact</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.mem_coclosedCompact_iff"><span class="name">Filter</span>.<span class="name">mem_coclosedCompact_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.compl_mem_coclosedCompact"><span class="name">Filter</span>.<span class="name">compl_mem_coclosedCompact</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.cocompact_le_coclosedCompact"><span class="name">Filter</span>.<span class="name">cocompact_le_coclosedCompact</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.compl_mem_coclosedCompact_of_isClosed"><span class="name">IsCompact</span>.<span class="name">compl_mem_coclosedCompact_of_isClosed</span></a></div><div class="nav_link"><a class="break_within" href="#Bornology.inCompact"><span class="name">Bornology</span>.<span class="name">inCompact</span></a></div><div class="nav_link"><a class="break_within" href="#Bornology.inCompact.isBounded_iff"><span class="name">Bornology</span>.<span class="name">inCompact</span>.<span class="name">isBounded_iff</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.nhdsSet_prod_eq"><span class="name">IsCompact</span>.<span class="name">nhdsSet_prod_eq</span></a></div><div class="nav_link"><a class="break_within" href="#nhdsSet_prod_le_of_disjoint_cocompact"><span class="name">nhdsSet_prod_le_of_disjoint_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#prod_nhdsSet_le_of_disjoint_cocompact"><span class="name">prod_nhdsSet_le_of_disjoint_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#nhds_prod_le_of_disjoint_cocompact"><span class="name">nhds_prod_le_of_disjoint_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#prod_nhds_le_of_disjoint_cocompact"><span class="name">prod_nhds_le_of_disjoint_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#generalized_tube_lemma"><span class="name">generalized_tube_lemma</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.nhdsSetWithin_prod_eq"><span class="name">IsCompact</span>.<span class="name">nhdsSetWithin_prod_eq</span></a></div><div class="nav_link"><a class="break_within" href="#generalized_tube_lemma'"><span class="name">generalized_tube_lemma'</span></a></div><div class="nav_link"><a class="break_within" href="#generalized_tube_lemma_left"><span class="name">generalized_tube_lemma_left</span></a></div><div class="nav_link"><a class="break_within" href="#generalized_tube_lemma_right"><span class="name">generalized_tube_lemma_right</span></a></div><div class="nav_link"><a class="break_within" href="#Subsingleton.compactSpace"><span class="name">Subsingleton</span>.<span class="name">compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_univ_iff"><span class="name">isCompact_univ_iff</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_univ"><span class="name">isCompact_univ</span></a></div><div class="nav_link"><a class="break_within" href="#exists_clusterPt_of_compactSpace"><span class="name">exists_clusterPt_of_compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#Ultrafilter.le_nhds_lim"><span class="name">Ultrafilter</span>.<span class="name">le_nhds_lim</span></a></div><div class="nav_link"><a class="break_within" href="#CompactSpace.elim_nhds_subcover"><span class="name">CompactSpace</span>.<span class="name">elim_nhds_subcover</span></a></div><div class="nav_link"><a class="break_within" href="#compactSpace_of_finite_subfamily_closed"><span class="name">compactSpace_of_finite_subfamily_closed</span></a></div><div class="nav_link"><a class="break_within" href="#CompactSpace.iInter_nonempty"><span class="name">CompactSpace</span>.<span class="name">iInter_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#compactSpace_generateFrom"><span class="name">compactSpace_generateFrom</span></a></div><div class="nav_link"><a class="break_within" href="#compactSpace_generateFrom'"><span class="name">compactSpace_generateFrom'</span></a></div><div class="nav_link"><a class="break_within" href="#IsClosed.isCompact"><span class="name">IsClosed</span>.<span class="name">isCompact</span></a></div><div class="nav_link"><a class="break_within" href="#le_nhds_of_unique_clusterPt"><span class="name">le_nhds_of_unique_clusterPt</span></a></div><div class="nav_link"><a class="break_within" href="#tendsto_nhds_of_unique_mapClusterPt"><span class="name">tendsto_nhds_of_unique_mapClusterPt</span></a></div><div class="nav_link"><a class="break_within" href="#noncompact_univ"><span class="name">noncompact_univ</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.ne_univ"><span class="name">IsCompact</span>.<span class="name">ne_univ</span></a></div><div class="nav_link"><a class="break_within" href="#instNeBotCocompactOfNoncompactSpace"><span class="name">instNeBotCocompactOfNoncompactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.cocompact_eq_bot"><span class="name">Filter</span>.<span class="name">cocompact_eq_bot</span></a></div><div class="nav_link"><a class="break_within" href="#instNeBotCoclosedCompactOfNoncompactSpace"><span class="name">instNeBotCoclosedCompactOfNoncompactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#noncompactSpace_of_neBot"><span class="name">noncompactSpace_of_neBot</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.cocompact_neBot_iff"><span class="name">Filter</span>.<span class="name">cocompact_neBot_iff</span></a></div><div class="nav_link"><a class="break_within" href="#not_compactSpace_iff"><span class="name">not_compactSpace_iff</span></a></div><div class="nav_link"><a class="break_within" href="#instNoncompactSpaceInt"><span class="name">instNoncompactSpaceInt</span></a></div><div class="nav_link"><a class="break_within" href="#finite_of_compact_of_discrete"><span class="name">finite_of_compact_of_discrete</span></a></div><div class="nav_link"><a class="break_within" href="#Set.Infinite.exists_accPt_cofinite_inf_principal_of_subset_isCompact"><span class="name">Set</span>.<span class="name">Infinite</span>.<span class="name">exists_accPt_cofinite_inf_principal_of_subset_isCompact</span></a></div><div class="nav_link"><a class="break_within" href="#Set.Infinite.exists_accPt_of_subset_isCompact"><span class="name">Set</span>.<span class="name">Infinite</span>.<span class="name">exists_accPt_of_subset_isCompact</span></a></div><div class="nav_link"><a class="break_within" href="#Set.Infinite.exists_accPt_cofinite_inf_principal"><span class="name">Set</span>.<span class="name">Infinite</span>.<span class="name">exists_accPt_cofinite_inf_principal</span></a></div><div class="nav_link"><a class="break_within" href="#Set.Infinite.exists_accPt_principal"><span class="name">Set</span>.<span class="name">Infinite</span>.<span class="name">exists_accPt_principal</span></a></div><div class="nav_link"><a class="break_within" href="#exists_nhds_ne_neBot"><span class="name">exists_nhds_ne_neBot</span></a></div><div class="nav_link"><a class="break_within" href="#finite_cover_nhds_interior"><span class="name">finite_cover_nhds_interior</span></a></div><div class="nav_link"><a class="break_within" href="#finite_cover_nhds"><span class="name">finite_cover_nhds</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.comap_cocompact_le"><span class="name">Filter</span>.<span class="name">comap_cocompact_le</span></a></div><div class="nav_link"><a class="break_within" href="#disjoint_map_cocompact"><span class="name">disjoint_map_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_range"><span class="name">isCompact_range</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_diagonal"><span class="name">isCompact_diagonal</span></a></div><div class="nav_link"><a class="break_within" href="#exists_subset_nhds_of_compactSpace"><span class="name">exists_subset_nhds_of_compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.IsInducing.isCompact_iff"><span class="name">Topology</span>.<span class="name">IsInducing</span>.<span class="name">isCompact_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.IsEmbedding.isCompact_iff"><span class="name">Topology</span>.<span class="name">IsEmbedding</span>.<span class="name">isCompact_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.IsInducing.isCompact_preimage"><span class="name">Topology</span>.<span class="name">IsInducing</span>.<span class="name">isCompact_preimage</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.IsInducing.isCompact_preimage_iff"><span class="name">Topology</span>.<span class="name">IsInducing</span>.<span class="name">isCompact_preimage_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.IsInducing.isCompact_preimage'"><span class="name">Topology</span>.<span class="name">IsInducing</span>.<span class="name">isCompact_preimage'</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.IsClosedEmbedding.isCompact_preimage"><span class="name">Topology</span>.<span class="name">IsClosedEmbedding</span>.<span class="name">isCompact_preimage</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.IsClosedEmbedding.tendsto_cocompact"><span class="name">Topology</span>.<span class="name">IsClosedEmbedding</span>.<span class="name">tendsto_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#Subtype.isCompact_iff"><span class="name">Subtype</span>.<span class="name">isCompact_iff</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_iff_isCompact_univ"><span class="name">isCompact_iff_isCompact_univ</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.elim_finite_subfamily_isClosed_subtype"><span class="name">IsCompact</span>.<span class="name">elim_finite_subfamily_isClosed_subtype</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_iff_compactSpace"><span class="name">isCompact_iff_compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.finite"><span class="name">IsCompact</span>.<span class="name">finite</span></a></div><div class="nav_link"><a class="break_within" href="#exists_nhds_ne_inf_principal_neBot"><span class="name">exists_nhds_ne_inf_principal_neBot</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.IsClosedEmbedding.noncompactSpace"><span class="name">Topology</span>.<span class="name">IsClosedEmbedding</span>.<span class="name">noncompactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#Topology.IsClosedEmbedding.compactSpace"><span class="name">Topology</span>.<span class="name">IsClosedEmbedding</span>.<span class="name">compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.prod"><span class="name">IsCompact</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#Finite.compactSpace"><span class="name">Finite</span>.<span class="name">compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#ULift.compactSpace"><span class="name">ULift</span>.<span class="name">compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#instCompactSpaceProd"><span class="name">instCompactSpaceProd</span></a></div><div class="nav_link"><a class="break_within" href="#instCompactSpaceSum"><span class="name">instCompactSpaceSum</span></a></div><div class="nav_link"><a class="break_within" href="#instCompactSpaceSigmaOfFinite"><span class="name">instCompactSpaceSigmaOfFinite</span></a></div><div class="nav_link"><a class="break_within" href="#Set.isCompact_sigma"><span class="name">Set</span>.<span class="name">isCompact_sigma</span></a></div><div class="nav_link"><a class="break_within" href="#IsCompact.sigma_exists_finite_sigma_eq"><span class="name">IsCompact</span>.<span class="name">sigma_exists_finite_sigma_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.coprod_cocompact"><span class="name">Filter</span>.<span class="name">coprod_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.noncompactSpace_iff"><span class="name">Prod</span>.<span class="name">noncompactSpace_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.noncompactSpace_left"><span class="name">Prod</span>.<span class="name">noncompactSpace_left</span></a></div><div class="nav_link"><a class="break_within" href="#Prod.noncompactSpace_right"><span class="name">Prod</span>.<span class="name">noncompactSpace_right</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_pi_infinite"><span class="name">isCompact_pi_infinite</span></a></div><div class="nav_link"><a class="break_within" href="#isCompact_univ_pi"><span class="name">isCompact_univ_pi</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.compactSpace"><span class="name">Pi</span>.<span class="name">compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#Function.compactSpace"><span class="name">Function</span>.<span class="name">compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.isCompact_iff_of_isClosed"><span class="name">Pi</span>.<span class="name">isCompact_iff_of_isClosed</span></a></div><div class="nav_link"><a class="break_within" href="#Pi.exists_compact_superset_iff"><span class="name">Pi</span>.<span class="name">exists_compact_superset_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Filter.coprod·µ¢_cocompact"><span class="name">Filter</span>.<span class="name">coprod·µ¢_cocompact</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.compactSpace"><span class="name">Quot</span>.<span class="name">compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#Quotient.compactSpace"><span class="name">Quotient</span>.<span class="name">compactSpace</span></a></div><div class="nav_link"><a class="break_within" href="#IsClosed.exists_minimal_nonempty_closed_subset"><span class="name">IsClosed</span>.<span class="name">exists_minimal_nonempty_closed_subset</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Compact-sets-and-compact-spaces">Compact sets and compact spaces <a class="hover-link" href="#Compact-sets-and-compact-spaces">#</a></h1><h2 class="markdown-heading" id="Main-results">Main results <a class="hover-link" href="#Main-results">#</a></h2><ul>
<li><p><code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_univ_pi">isCompact_univ_pi</a></code>: <strong>Tychonov's theorem</strong> - an arbitrary product of compact sets
is compact.</p>
</li>
<li><p><code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_generateFrom">isCompact_generateFrom</a></code>: <strong>Alexander's subbasis theorem</strong> - suppose <code>X</code> is a topological space
with a subbasis <code>S</code> and <code>s</code> is a subset of <code>X</code>, then <code>s</code> is compact if for any open cover of <code>s</code>
with all elements taken from <code>S</code>, there is a finite subcover.</p>
</li>
</ul></div><div class="decl" id="IsCompact.exists_clusterPt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L40-L41">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.exists_clusterPt"><span class="name">IsCompact</span>.<span class="name">exists_clusterPt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">f</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> <span class="fn">x</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="IsCompact.exists_mapClusterPt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L43-L45">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.exists_mapClusterPt"><span class="name">IsCompact</span>.<span class="name">exists_mapClusterPt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">Œπ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">u</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#MapClusterPt">MapClusterPt</a> <span class="fn">x</span> <span class="fn">f</span> <span class="fn">u</span></span></span></div></div></div></div><div class="decl" id="IsCompact.exists_clusterPt_of_frequently"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L47-L50">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.exists_clusterPt_of_frequently"><span class="name">IsCompact</span>.<span class="name">exists_clusterPt_of_frequently</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">‚àÉ·∂†</a> (<span class="fn">x</span> : <span class="fn">X</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">in</a> <span class="fn">l</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">,</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">a</span> ‚àà <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="IsCompact.exists_mapClusterPt_of_frequently"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L52-L54">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.exists_mapClusterPt_of_frequently"><span class="name">IsCompact</span>.<span class="name">exists_mapClusterPt_of_frequently</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">Œπ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">‚àÉ·∂†</a> (<span class="fn">x</span> : <span class="fn">Œπ</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">in</a> <span class="fn">l</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Frequently">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">a</span> ‚àà <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#MapClusterPt">MapClusterPt</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="IsCompact.compl_mem_sets"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L56-L62">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.compl_mem_sets"><span class="name">IsCompact</span>.<span class="name">compl_mem_sets</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> ‚äì <span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">f</span></div></div><p>The complement to a compact set belongs to a filter <code>f</code> if it belongs to each filter
<code>ùìù x ‚äì f</code>, <code>x ‚àà s</code>.</p></div></div><div class="decl" id="IsCompact.compl_mem_sets_of_nhdsWithin"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L64-L73">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.compl_mem_sets_of_nhdsWithin"><span class="name">IsCompact</span>.<span class="name">compl_mem_sets_of_nhdsWithin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn">‚àÉ <span class="fn">t</span> ‚àà <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> <span class="fn">x</span> <span class="fn">s</span></span>, <span class="fn">t</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">f</span></div></div><p>The complement to a compact set belongs to a filter <code>f</code> if each <code>x ‚àà s</code> has a neighborhood <code>t</code>
within <code>s</code> such that <code>t·∂ú</code> belongs to <code>f</code>.</p></div></div><div class="decl" id="IsCompact.induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L75-L83">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.induction_on"><span class="name">IsCompact</span>.<span class="name">induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">p</span> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmono</span> : <span class="fn">‚àÄ ‚¶É<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>‚¶Ñ, <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">t</span> ‚Üí <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">t</span></span> ‚Üí <span class="fn"><span class="fn">p</span> <span class="fn">s</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hunion</span> : <span class="fn">‚àÄ ‚¶É<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>‚¶Ñ, <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">s</span></span> ‚Üí <span class="fn"><span class="fn"><span class="fn">p</span> <span class="fn">t</span></span> ‚Üí <span class="fn"><span class="fn">p</span> (<span class="fn">s</span> <a href="../../.././Init/Core.html#Union.union">‚à™</a> <span class="fn">t</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hnhds</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn">‚àÉ <span class="fn">t</span> ‚àà <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> <span class="fn">x</span> <span class="fn">s</span></span>, <span class="fn"><span class="fn">p</span> <span class="fn">t</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> <span class="fn">s</span></span></div></div><p>If <code>p : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> X ‚Üí Prop</code> is stable under restriction and union, and each point <code>x</code>
of a compact set <code>s</code> has a neighborhood <code>t</code> within <code>s</code> such that <code>p t</code>, then <code>p s</code> holds.</p></div></div><div class="decl" id="IsCompact.inter_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L85-L92">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.inter_right"><span class="name">IsCompact</span>.<span class="name">inter_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">t</span>)</span></div></div><p>The intersection of a compact set and a closed set is a compact set.</p></div></div><div class="decl" id="IsCompact.inter_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L94-L96">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.inter_left"><span class="name">IsCompact</span>.<span class="name">inter_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">t</span>)</span></div></div><p>The intersection of a closed set and a compact set is a compact set.</p></div></div><div class="decl" id="IsCompact.diff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L98-L100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.diff"><span class="name">IsCompact</span>.<span class="name">diff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">s</span> <a href="../../.././Init/Core.html#SDiff.sdiff">\</a> <span class="fn">t</span>)</span></div></div><p>The set difference of a compact set and an open set is a compact set.</p></div></div><div class="decl" id="IsCompact.of_isClosed_subset"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L102-L105">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.of_isClosed_subset"><span class="name">IsCompact</span>.<span class="name">of_isClosed_subset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">t</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span></div></div><p>A closed subset of a compact set is a compact set.</p></div></div><div class="decl" id="IsCompact.image_of_continuousOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L107-L119">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.image_of_continuousOn"><span class="name">IsCompact</span>.<span class="name">image_of_continuousOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ContinuousOn">ContinuousOn</a> <span class="fn">f</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></div></div></div></div><div class="decl" id="IsCompact.image"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L121-L122">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.image"><span class="name">IsCompact</span>.<span class="name">image</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></div></div></div></div><div class="decl" id="IsCompact.adherence_nhdset"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L124-L132">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.adherence_nhdset"><span class="name">IsCompact</span>.<span class="name">adherence_nhdset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf‚ÇÇ</span> : <span class="fn">f</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht‚ÇÅ</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht‚ÇÇ</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> <span class="fn">x</span> <span class="fn">f</span></span> ‚Üí <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">t</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">t</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">f</span></div></div></div></div><div class="decl" id="isCompact_iff_ultrafilter_le_nhds"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L134-L139">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iff_ultrafilter_le_nhds"><span class="name">isCompact_iff_ultrafilter_le_nhds</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÄ (<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Ultrafilter/Defs.html#Ultrafilter">Ultrafilter</a> <span class="fn">X</span></span>), <span class="fn"><span class="fn">‚Üë<span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span> ‚Üí <span class="fn">‚àÉ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn">‚Üë<span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="IsCompact.ultrafilter_le_nhds"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L141-L141">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.ultrafilter_le_nhds"><span class="name">IsCompact</span>.<span class="name">ultrafilter_le_nhds</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> ‚Üí <span class="fn">‚àÄ (<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Ultrafilter/Defs.html#Ultrafilter">Ultrafilter</a> <span class="fn">X</span></span>), <span class="fn"><span class="fn">‚Üë<span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span> ‚Üí <span class="fn">‚àÉ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn">‚Üë<span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iff_ultrafilter_le_nhds">isCompact_iff_ultrafilter_le_nhds</a></code>.</p></div></div><div class="decl" id="isCompact_iff_ultrafilter_le_nhds'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L143-L145">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iff_ultrafilter_le_nhds'"><span class="name">isCompact_iff_ultrafilter_le_nhds'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÄ (<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Ultrafilter/Defs.html#Ultrafilter">Ultrafilter</a> <span class="fn">X</span></span>), <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">f</span> ‚Üí <span class="fn">‚àÉ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn">‚Üë<span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="IsCompact.ultrafilter_le_nhds'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L147-L147">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.ultrafilter_le_nhds'"><span class="name">IsCompact</span>.<span class="name">ultrafilter_le_nhds'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> ‚Üí <span class="fn">‚àÄ (<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Ultrafilter/Defs.html#Ultrafilter">Ultrafilter</a> <span class="fn">X</span></span>), <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">f</span> ‚Üí <span class="fn">‚àÉ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn">‚Üë<span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iff_ultrafilter_le_nhds'">isCompact_iff_ultrafilter_le_nhds'</a></code>.</p></div></div><div class="decl" id="IsCompact.le_nhds_of_unique_clusterPt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L149-L156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.le_nhds_of_unique_clusterPt"><span class="name">IsCompact</span>.<span class="name">le_nhds_of_unique_clusterPt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hmem</span> : <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> <span class="fn">x</span> <span class="fn">l</span></span> ‚Üí <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span></span></div></div><p>If a compact set belongs to a filter and this filter has a unique cluster point <code>y</code> in this set,
then the filter is less than or equal to <code>ùìù y</code>.</p></div></div><div class="decl" id="IsCompact.tendsto_nhds_of_unique_mapClusterPt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L158-L164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.tendsto_nhds_of_unique_mapClusterPt"><span class="name">IsCompact</span>.<span class="name">tendsto_nhds_of_unique_mapClusterPt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Y</span> ‚Üí <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmem</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">‚àÄ·∂†</a> (<span class="fn">x</span> : <span class="fn">Y</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn">l</span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#MapClusterPt">MapClusterPt</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">f</span></span> ‚Üí <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">f</span> <span class="fn">l</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span>)</span></span></div></div><p>If values of <code>f : Y ‚Üí X</code> belong to a compact set <code>s</code> eventually along a filter <code>l</code>
and <code>y</code> is a unique <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#MapClusterPt">MapClusterPt</a></code> for <code>f</code> along <code>l</code> in <code>s</code>,
then <code>f</code> tends to <code>ùìù y</code> along <code>l</code>.</p></div></div><div class="decl" id="IsCompact.elim_directed_cover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L166-L178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_directed_cover"><span class="name">IsCompact</span>.<span class="name">elim_directed_cover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hŒπ</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hUo</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">(<span class="fn">U</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hsU</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hdU</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">x2</span>)</span> <span class="fn">U</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></div></div><p>For every open directed cover of a compact set, there exists a single element of the
cover which itself includes the set.</p></div></div><div class="decl" id="IsCompact.elim_finite_subcover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L180-L185">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_finite_subcover"><span class="name">IsCompact</span>.<span class="name">elim_finite_subcover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hUo</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">(<span class="fn">U</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hsU</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">i</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></span></div></div><p>For every open cover of a compact set, there exists a finite subcover.</p></div></div><div class="decl" id="IsCompact.elim_nhds_subcover_nhdsSet'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L187-L194">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_nhds_subcover_nhdsSet'"><span class="name">IsCompact</span>.<span class="name">elim_nhds_subcover_nhdsSet'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>) ‚Üí <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">X</span>) (<span class="fn">hx</span> : <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span>), <span class="fn"><span class="fn">U</span> <span class="fn">x</span> <span class="fn">hx</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">‚Üë<span class="fn">s</span></span></span>), <span class="fn">‚ãÉ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">‚Üë<span class="fn">x</span></span> <span class="fn">‚ãØ</span></span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="IsCompact.elim_nhds_subcover_nhdsSet"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L196-L203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_nhds_subcover_nhdsSet"><span class="name">IsCompact</span>.<span class="name">elim_nhds_subcover_nhdsSet</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">X</span></span>), <span class="fn">(‚àÄ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span>)</span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">‚ãÉ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="IsCompact.elim_nhds_subcover'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L205-L207">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_nhds_subcover'"><span class="name">IsCompact</span>.<span class="name">elim_nhds_subcover'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>) ‚Üí <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">X</span>) (<span class="fn">hx</span> : <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span>), <span class="fn"><span class="fn">U</span> <span class="fn">x</span> <span class="fn">hx</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">‚Üë<span class="fn">s</span></span></span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">‚Üë<span class="fn">x</span></span> <span class="fn">‚ãØ</span></span></span></span></div></div></div></div><div class="decl" id="IsCompact.elim_nhds_subcover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L209-L211">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_nhds_subcover"><span class="name">IsCompact</span>.<span class="name">elim_nhds_subcover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">X</span></span>), <span class="fn">(‚àÄ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span>)</span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="IsCompact.elim_nhdsWithin_subcover'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L213-L218">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_nhdsWithin_subcover'"><span class="name">IsCompact</span>.<span class="name">elim_nhdsWithin_subcover'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>) ‚Üí <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">X</span>) (<span class="fn">hx</span> : <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span>), <span class="fn"><span class="fn">U</span> <span class="fn">x</span> <span class="fn">hx</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> <span class="fn">x</span> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">‚Üë<span class="fn">s</span></span></span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">‚Üë<span class="fn">x</span></span> <span class="fn">‚ãØ</span></span></span></span></div></div></div></div><div class="decl" id="IsCompact.elim_nhdsWithin_subcover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L220-L225">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_nhdsWithin_subcover"><span class="name">IsCompact</span>.<span class="name">elim_nhdsWithin_subcover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> <span class="fn">x</span> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">X</span></span>), <span class="fn">(‚àÄ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">s</span>)</span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="IsCompact.disjoint_nhdsSet_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L227-L238">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.disjoint_nhdsSet_left"><span class="name">IsCompact</span>.<span class="name">disjoint_nhdsSet_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">s</span>)</span> <span class="fn">l</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span>)</span> <span class="fn">l</span></span></span></div></div><p>The neighborhood filter of a compact set is disjoint with a filter <code>l</code> if and only if the
neighborhood filter of each point of this set is disjoint with <code>l</code>.</p></div></div><div class="decl" id="IsCompact.disjoint_nhdsSet_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L240-L244">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.disjoint_nhdsSet_right"><span class="name">IsCompact</span>.<span class="name">disjoint_nhdsSet_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">l</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">s</span>)</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">l</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span>)</span></span></span></div></div><p>A filter <code>l</code> is disjoint with the neighborhood filter of a compact set if and only if it is
disjoint with the neighborhood filter of each point of this set.</p></div></div><div class="decl" id="IsCompact.elim_directed_family_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L247-L260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_directed_family_closed"><span class="name">IsCompact</span>.<span class="name">elim_directed_family_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htc</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hst</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hdt</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#Superset">‚äá</a> <span class="fn">x2</span>)</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a></span></div></div><p>For every directed family of closed sets whose intersection avoids a compact set,
there exists a single element of the family which itself avoids this compact set.</p></div></div><div class="decl" id="IsCompact.elim_finite_subfamily_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L263-L270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_finite_subfamily_closed"><span class="name">IsCompact</span>.<span class="name">elim_finite_subfamily_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htc</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hst</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">u</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ <span class="fn">i</span> ‚àà <span class="fn">u</span>, <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a></span></div></div><p>For every family of closed sets whose intersection avoids a compact set,
there exists a finite subfamily whose intersection avoids this compact set.</p></div></div><div class="decl" id="IsCompact.inter_iInter_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L272-L278">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.inter_iInter_nonempty"><span class="name">IsCompact</span>.<span class="name">inter_iInter_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htc</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hst</span> : <span class="fn">‚àÄ (<span class="fn">u</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>), <span class="fn">(<span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ <span class="fn">i</span> ‚àà <span class="fn">u</span>, <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span>).<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span>).<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></div></div><p>To show that a compact set intersects the intersection of a family of closed sets,
it is sufficient to show that it intersects every finite subfamily.</p></div></div><div class="decl" id="IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L280-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed"><span class="name">IsCompact</span>.<span class="name">nonempty_iInter_of_directed_nonempty_isCompact_isClosed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hŒπ</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htd</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#Superset">‚äá</a> <span class="fn">x2</span>)</span> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htn</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htc</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htcl</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span>)</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></div></div><p>Cantor's intersection theorem for <code>iInter</code>:
the intersection of a directed family of nonempty compact closed sets is nonempty.</p></div></div><div class="decl" id="IsCompact.nonempty_sInter_of_directed_nonempty_isCompact_isClosed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L297-L304">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.nonempty_sInter_of_directed_nonempty_isCompact_isClosed"><span class="name">IsCompact</span>.<span class="name">nonempty_sInter_of_directed_nonempty_isCompact_isClosed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hS</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">‚Üë<span class="fn">S</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hSd</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#Superset">‚äá</a> <span class="fn">x2</span>)</span> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hSn</span> : <span class="fn">‚àÄ <span class="fn">U</span> ‚àà <span class="fn">S</span>, <span class="fn"><span class="fn">U</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hSc</span> : <span class="fn">‚àÄ <span class="fn">U</span> ‚àà <span class="fn">S</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hScl</span> : <span class="fn">‚àÄ <span class="fn">U</span> ‚àà <span class="fn">S</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../.././Mathlib/Order/SetNotation.html#Set.sInter">‚ãÇ‚ÇÄ</a> <span class="fn">S</span>).<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></div></div><p>Cantor's intersection theorem for <code>sInter</code>:
the intersection of a directed family of nonempty compact closed sets is nonempty.</p></div></div><div class="decl" id="IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L306-L315">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed"><span class="name">IsCompact</span>.<span class="name">nonempty_iInter_of_sequence_nonempty_isCompact_isClosed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Nat">‚Ñï</a> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htd</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>), <span class="fn"><span class="fn">t</span> (<span class="fn">i</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span>)</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htn</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>), <span class="fn"><span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht0</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">t</span> <span class="fn">0</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">htcl</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚ãÇ (<span class="fn">i</span> : <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span>)</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></div></div><p>Cantor's intersection theorem for sequences indexed by <code>‚Ñï</code>:
the intersection of a decreasing sequence of nonempty compact closed sets is nonempty.</p></div></div><div class="decl" id="IsCompact.elim_finite_subcover_image"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L317-L325">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_finite_subcover_image"><span class="name">IsCompact</span>.<span class="name">elim_finite_subcover_image</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œπ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc‚ÇÅ</span> : <span class="fn">‚àÄ <span class="fn">i</span> ‚àà <span class="fn">b</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">(<span class="fn">c</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc‚ÇÇ</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">i</span> ‚àà <span class="fn">b</span>, <span class="fn"><span class="fn">c</span> <span class="fn">i</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">b'</span> ‚äÜ <span class="fn">b</span>, <span class="fn"><span class="fn">b'</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">i</span> ‚àà <span class="fn">b'</span>, <span class="fn"><span class="fn">c</span> <span class="fn">i</span></span></span></span></div></div><p>For every open cover of a compact set, there exists a finite subcover.</p></div></div><div class="decl" id="isCompact_of_finite_subcover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L327-L340">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_of_finite_subcover"><span class="name">isCompact_of_finite_subcover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn">‚àÄ {<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u} (<span class="fn">U</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>), <span class="fn"><span class="fn">(‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">(<span class="fn">U</span> <span class="fn">i</span>)</span></span>)</span> ‚Üí <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span> ‚Üí <span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">i</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span></div></div><p>A set <code>s</code> is compact if for every open cover of <code>s</code>, there exists a finite subcover.</p></div></div><div class="decl" id="isCompact_of_finite_subfamily_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L343-L353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_of_finite_subfamily_closed"><span class="name">isCompact_of_finite_subfamily_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn">‚àÄ {<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u} (<span class="fn">t</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>),
    <span class="fn"><span class="fn">(‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span>)</span> ‚Üí <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a> ‚Üí <span class="fn">‚àÉ (<span class="fn">u</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ <span class="fn">i</span> ‚àà <span class="fn">u</span>, <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span></div></div><p>A set <code>s</code> is compact if for every family of closed sets whose intersection avoids <code>s</code>,
there exists a finite subfamily whose intersection avoids <code>s</code>.</p></div></div><div class="decl" id="isCompact_iff_finite_subcover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L355-L360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iff_finite_subcover"><span class="name">isCompact_iff_finite_subcover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a>   <span class="fn">‚àÄ {<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u} (<span class="fn">U</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>), <span class="fn"><span class="fn">(‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">(<span class="fn">U</span> <span class="fn">i</span>)</span></span>)</span> ‚Üí <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span> ‚Üí <span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">i</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></span></span></span></span></div></div><p>A set <code>s</code> is compact if and only if
for every open cover of <code>s</code>, there exists a finite subcover.</p></div></div><div class="decl" id="isCompact_iff_finite_subfamily_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L362-L368">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iff_finite_subfamily_closed"><span class="name">isCompact_iff_finite_subfamily_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a>   <span class="fn">‚àÄ {<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u} (<span class="fn">t</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>),
    <span class="fn"><span class="fn">(‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span>)</span> ‚Üí <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a> ‚Üí <span class="fn">‚àÉ (<span class="fn">u</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ <span class="fn">i</span> ‚àà <span class="fn">u</span>, <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a></span></span></span></span></div></div><p>A set <code>s</code> is compact if and only if
for every family of closed sets whose intersection avoids <code>s</code>,
there exists a finite subfamily whose intersection avoids <code>s</code>.</p></div></div><div class="decl" id="IsCompact.mem_nhdsSet_prod_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L370-L381">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.mem_nhdsSet_prod_of_forall"><span class="name">IsCompact</span>.<span class="name">mem_nhdsSet_prod_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">K</span>, <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">K</span></span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">l</span></div></div><p>If <code>s : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (X √ó Y)</code> belongs to <code>ùìù x √óÀ¢ l</code> for all <code>x</code> from a compact set <code>K</code>,
then it belongs to <code>(ùìùÀ¢ K) √óÀ¢ l</code>,
i.e., there exist an open <code>U ‚äá K</code> and <code>t ‚àà l</code> such that <code>U √óÀ¢ t ‚äÜ s</code>.</p></div></div><div class="decl" id="IsCompact.nhdsSet_prod_eq_biSup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L383-L386">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.nhdsSet_prod_eq_biSup"><span class="name">IsCompact</span>.<span class="name">nhdsSet_prod_eq_biSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">K</span></span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">l</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">‚®Ü <span class="fn">x</span> ‚àà <span class="fn">K</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="IsCompact.prod_nhdsSet_eq_biSup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L388-L390">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.prod_nhdsSet_eq_biSup"><span class="name">IsCompact</span>.<span class="name">prod_nhdsSet_eq_biSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">K</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">‚®Ü <span class="fn">y</span> ‚àà <span class="fn">K</span>, <span class="fn">l</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="IsCompact.mem_prod_nhdsSet_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L392-L397">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.mem_prod_nhdsSet_of_forall"><span class="name">IsCompact</span>.<span class="name">mem_prod_nhdsSet_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">‚àÄ <span class="fn">y</span> ‚àà <span class="fn">K</span>, <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">l</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn">l</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">K</span></span></div></div><p>If <code>s : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (X √ó Y)</code> belongs to <code>l √óÀ¢ ùìù y</code> for all <code>y</code> from a compact set <code>K</code>,
then it belongs to <code>l √óÀ¢ (ùìùÀ¢ K)</code>,
i.e., there exist <code>t ‚àà l</code> and an open <code>U ‚äá K</code> such that <code>t √óÀ¢ U ‚äÜ s</code>.</p></div></div><div class="decl" id="IsCompact.nhdsSet_inf_eq_biSup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L401-L405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.nhdsSet_inf_eq_biSup"><span class="name">IsCompact</span>.<span class="name">nhdsSet_inf_eq_biSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">K</span></span> ‚äì <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">‚®Ü <span class="fn">x</span> ‚àà <span class="fn">K</span>, <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> ‚äì <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="IsCompact.inf_nhdsSet_eq_biSup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L407-L409">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.inf_nhdsSet_eq_biSup"><span class="name">IsCompact</span>.<span class="name">inf_nhdsSet_eq_biSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span> ‚äì <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">K</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">‚®Ü <span class="fn">x</span> ‚àà <span class="fn">K</span>, <span class="fn"><span class="fn">l</span> ‚äì <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="IsCompact.mem_nhdsSet_inf_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L411-L416">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.mem_nhdsSet_inf_of_forall"><span class="name">IsCompact</span>.<span class="name">mem_nhdsSet_inf_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">K</span>, <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> ‚äì <span class="fn">l</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">K</span></span> ‚äì <span class="fn">l</span></span></div></div><p>If <code>s : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> X</code> belongs to <code>ùìù x ‚äì l</code> for all <code>x</code> from a compact set <code>K</code>,
then it belongs to <code>(ùìùÀ¢ K) ‚äì l</code>,
i.e., there exist an open <code>U ‚äá K</code> and <code>T ‚àà l</code> such that <code>U ‚à© T ‚äÜ s</code>.</p></div></div><div class="decl" id="IsCompact.mem_inf_nhdsSet_of_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L418-L423">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.mem_inf_nhdsSet_of_forall"><span class="name">IsCompact</span>.<span class="name">mem_inf_nhdsSet_of_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">‚àÄ <span class="fn">y</span> ‚àà <span class="fn">K</span>, <span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><span class="fn">l</span> ‚äì <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><span class="fn">l</span> ‚äì <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">K</span></span></span></div></div><p>If <code>s : <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> S</code> belongs to <code>l ‚äì ùìù x</code> for all <code>x</code> from a compact set <code>K</code>,
then it belongs to <code>l ‚äì (ùìùÀ¢ K)</code>,
i.e., there exist <code>T ‚àà l</code> and an open <code>U ‚äá K</code> such that <code>T ‚à© U ‚äÜ s</code>.</p></div></div><div class="decl" id="IsCompact.eventually_forall_of_forall_eventually"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L425-L436">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.eventually_forall_of_forall_eventually"><span class="name">IsCompact</span>.<span class="name">eventually_forall_of_forall_eventually</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x‚ÇÄ</span> : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn"><span class="fn">Y</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hP</span> : <span class="fn">‚àÄ <span class="fn">y</span> ‚àà <span class="fn">K</span>, <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">‚àÄ·∂†</a> (<span class="fn">z</span> : <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">x‚ÇÄ</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">y</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a></span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <span class="fn"><span class="fn">P</span> <span class="fn"><span class="fn">z</span>.1</span> <span class="fn"><span class="fn">z</span>.2</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">‚àÄ·∂†</a> (<span class="fn">x</span> : <span class="fn">X</span>) <a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">in</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x‚ÇÄ</span></span><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Eventually">,</a> <span class="fn">‚àÄ <span class="fn">y</span> ‚àà <span class="fn">K</span>, <span class="fn"><span class="fn">P</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span></div></div><p>To show that <code>‚àÄ y ‚àà K, P x y</code> holds for <code>x</code> close enough to <code>x‚ÇÄ</code> when <code>K</code> is compact,
it is sufficient to show that for all <code>y‚ÇÄ ‚àà K</code> there <code>P x y</code> holds for <code>(x, y)</code> close enough
to <code>(x‚ÇÄ, y‚ÇÄ)</code>.</p><p>Provided for backwards compatibility,
see <code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.mem_prod_nhdsSet_of_forall">IsCompact.mem_prod_nhdsSet_of_forall</a></code> for a stronger statement.</p></div></div><div class="decl" id="isCompact_empty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L438-L439">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_empty"><span class="name">isCompact_empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a></span></div></div></div></div><div class="decl" id="isCompact_singleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L441-L443">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_singleton"><span class="name">isCompact_singleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Init/Core.html#Singleton.singleton">{</a><span class="fn">x</span><a href="../../.././Init/Core.html#Singleton.singleton">}</a></span></div></div></div></div><div class="decl" id="Set.Subsingleton.isCompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L445-L446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.Subsingleton.isCompact"><span class="name">Set</span>.<span class="name">Subsingleton</span>.<span class="name">isCompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Subsingleton.html#Set.Subsingleton">Subsingleton</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="Set.Finite.isCompact_biUnion"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L448-L454">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.Finite.isCompact_biUnion"><span class="name">Set</span>.<span class="name">Finite</span>.<span class="name">isCompact_biUnion</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œπ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">‚àÄ <span class="fn">i</span> ‚àà <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(‚ãÉ <span class="fn">i</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="Finset.isCompact_biUnion"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L456-L458">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Finset.isCompact_biUnion"><span class="name">Finset</span>.<span class="name">isCompact_biUnion</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">‚àÄ <span class="fn">i</span> ‚àà <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(‚ãÉ <span class="fn">i</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="isCompact_accumulate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L460-L462">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_accumulate"><span class="name">isCompact_accumulate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Nat">‚Ñï</a> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn">‚àÄ (<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">K</span> <span class="fn">n</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">‚Ñï</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Accumulate.html#Set.accumulate">Set.accumulate</a> <span class="fn">K</span> <span class="fn">n</span>)</span></span></div></div></div></div><div class="decl" id="Set.Finite.isCompact_sUnion"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L464-L466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.Finite.isCompact_sUnion"><span class="name">Set</span>.<span class="name">Finite</span>.<span class="name">isCompact_sUnion</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn">‚àÄ <span class="fn">s</span> ‚àà <span class="fn">S</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">‚ãÉ‚ÇÄ</a> <span class="fn">S</span>)</span></div></div></div></div><div class="decl" id="isCompact_iUnion"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L468-L470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iUnion"><span class="name">isCompact_iUnion</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">f</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(‚ãÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">f</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="Set.Finite.isCompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L472-L473">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.Finite.isCompact"><span class="name">Set</span>.<span class="name">Finite</span>.<span class="name">isCompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="Set.sUnion_isCompact_eq_univ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L475-L476">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.sUnion_isCompact_eq_univ"><span class="name">Set</span>.<span class="name">sUnion_isCompact_eq_univ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">‚ãÉ‚ÇÄ</a> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">s</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">univ</a></div></div></div></div><div class="decl" id="IsCompact.finite_of_discrete"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L478-L482">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.finite_of_discrete"><span class="name">IsCompact</span>.<span class="name">finite_of_discrete</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Order.html#DiscreteTopology">DiscreteTopology</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span></div></div></div></div><div class="decl" id="isCompact_iff_finite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L484-L485">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iff_finite"><span class="name">isCompact_iff_finite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Order.html#DiscreteTopology">DiscreteTopology</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span></div></div></div></div><div class="decl" id="IsCompact.union"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L487-L488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.union"><span class="name">IsCompact</span>.<span class="name">union</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">s</span> <a href="../../.././Init/Core.html#Union.union">‚à™</a> <span class="fn">t</span>)</span></div></div></div></div><div class="decl" id="IsCompact.insert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L490-L491">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.insert"><span class="name">IsCompact</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">a</span> <span class="fn">s</span>)</span></span></div></div></div></div><div class="decl" id="exists_subset_nhds_of_isCompact'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L494-L513">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#exists_subset_nhds_of_isCompact'"><span class="name">exists_subset_nhds_of_isCompact'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hV</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#Superset">‚äá</a> <span class="fn">x2</span>)</span> <span class="fn">V</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hV_cpct</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">V</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hV_closed</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">V</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">V</span> <span class="fn">i</span></span></span>, <span class="fn">U</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">V</span> <span class="fn">i</span></span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">U</span></span></div></div><p>If <code>V : Œπ ‚Üí <a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> X</code> is a decreasing family of closed compact sets then any neighborhood of
<code>‚ãÇ i, V i</code> contains some <code>V i</code>. We assume each <code>V i</code> is compact <em>and</em> closed because <code>X</code> is
not assumed to be Hausdorff. See <code>exists_subset_nhds_of_compact</code> for version assuming this.</p></div></div><div class="decl" id="isCompact_generateFrom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L516-L536">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_generateFrom"><span class="name">isCompact_generateFrom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">T</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hTS</span> : <span class="fn">T</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Order.html#TopologicalSpace.generateFrom">TopologicalSpace.generateFrom</a> <span class="fn">S</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ <span class="fn">P</span> ‚äÜ <span class="fn">S</span>, <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">‚ãÉ‚ÇÄ</a> <span class="fn">P</span> ‚Üí <span class="fn">‚àÉ <span class="fn">Q</span> ‚äÜ <span class="fn">P</span>, <span class="fn"><span class="fn">Q</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">‚ãÉ‚ÇÄ</a> <span class="fn">Q</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span></div></div><p><strong>Alexander's subbasis theorem</strong>. Suppose <code>X</code> is a topological space with a subbasis <code>S</code> and <code>s</code> is
a subset of <code>X</code>. Then <code>s</code> is compact if for any open cover of <code>s</code> with all elements taken from <code>S</code>,
there is a finite subcover.</p></div></div><div class="decl" id="isCompact_generateFrom'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L539-L549">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_generateFrom'"><span class="name">isCompact_generateFrom'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">T</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hTS</span> : <span class="fn">T</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Order.html#TopologicalSpace.generateFrom">TopologicalSpace.generateFrom</a> <span class="fn">S</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u) (<span class="fn">U</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn">‚Üë<span class="fn">S</span></span></span>), <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn">‚Üë<span class="fn">(<span class="fn">U</span> <span class="fn">i</span>)</span></span></span> ‚Üí <span class="fn">‚àÉ (<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œπ</span></span>), <span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">‚ãÉ <span class="fn">i</span> ‚àà <span class="fn">J</span>, <span class="fn">‚Üë<span class="fn">(<span class="fn">U</span> <span class="fn">i</span>)</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="Filter.hasBasis_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L553-L558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.hasBasis_cocompact"><span class="name">Filter</span>.<span class="name">hasBasis_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">compl</a></span></div></div></div></div><div class="decl" id="Filter.mem_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L560-L561">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.mem_cocompact"><span class="name">Filter</span>.<span class="name">mem_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">t</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="Filter.mem_cocompact'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L563-L564">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.mem_cocompact'"><span class="name">Filter</span>.<span class="name">mem_cocompact'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="IsCompact.compl_mem_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L566-L567">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.compl_mem_cocompact"><span class="name">IsCompact</span>.<span class="name">compl_mem_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="Filter.cocompact_le_cofinite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L569-L570">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.cocompact_le_cofinite"><span class="name">Filter</span>.<span class="name">cocompact_le_cofinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <a href="../../.././Mathlib/Order/Filter/Cofinite.html#Filter.cofinite">cofinite</a></div></div></div></div><div class="decl" id="Filter.cocompact_eq_cofinite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L572-L574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.cocompact_eq_cofinite"><span class="name">Filter</span>.<span class="name">cocompact_eq_cofinite</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Order.html#DiscreteTopology">DiscreteTopology</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Filter/Cofinite.html#Filter.cofinite">cofinite</a></div></div></div></div><div class="decl" id="Filter.disjoint_cocompact_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L576-L580">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.disjoint_cocompact_left"><span class="name">Filter</span>.<span class="name">disjoint_cocompact_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÉ <span class="fn">K</span> ‚àà <span class="fn">f</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span></span></div></div><p>A filter is disjoint from the cocompact filter if and only if it contains a compact set.</p></div></div><div class="decl" id="Filter.disjoint_cocompact_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L582-L586">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.disjoint_cocompact_right"><span class="name">Filter</span>.<span class="name">disjoint_cocompact_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span>)</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÉ <span class="fn">K</span> ‚àà <span class="fn">f</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span></span></div></div><p>A filter is disjoint from the cocompact filter if and only if it contains a compact set.</p></div></div><div class="decl" id="Filter.Tendsto.isCompact_insert_range_of_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L588-L602">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.Tendsto.isCompact_insert_range_of_cocompact"><span class="name">Filter</span>.<span class="name">Tendsto</span>.<span class="name">isCompact_insert_range_of_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">Y</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Tendsto</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hfc</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">y</span> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Filter.Tendsto.isCompact_insert_range_of_cofinite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L604-L608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.Tendsto.isCompact_insert_range_of_cofinite"><span class="name">Filter</span>.<span class="name">Tendsto</span>.<span class="name">isCompact_insert_range_of_cofinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Tendsto</a> <span class="fn">f</span> <a href="../../.././Mathlib/Order/Filter/Cofinite.html#Filter.cofinite">cofinite</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Filter.Tendsto.isCompact_insert_range"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L610-L612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.Tendsto.isCompact_insert_range"><span class="name">Filter</span>.<span class="name">Tendsto</span>.<span class="name">isCompact_insert_range</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Nat">‚Ñï</a> ‚Üí <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Tendsto</a> <span class="fn">f</span> <a href="../../.././Mathlib/Order/Filter/AtTopBot/Defs.html#Filter.atTop">atTop</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<a href="../../.././Init/Core.html#Insert.insert">insert</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Filter.hasBasis_coclosedCompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L614-L620">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.hasBasis_coclosedCompact"><span class="name">Filter</span>.<span class="name">hasBasis_coclosedCompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact">coclosedCompact</a> <span class="fn">X</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Bases/Basic.html#Filter.HasBasis">HasBasis</a></span> <span class="fn">(fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span> <a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">compl</a></span></div></div></div></div><div class="decl" id="Filter.mem_coclosedCompact_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L622-L629">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.mem_coclosedCompact_iff"><span class="name">Filter</span>.<span class="name">mem_coclosedCompact_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact">coclosedCompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> <span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a>)</span></span></div></div><p>A set belongs to <code>coclosedCompact</code> if and only if the closure of its complement is compact.</p></div></div><div class="decl" id="Filter.compl_mem_coclosedCompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L631-L633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.compl_mem_coclosedCompact"><span class="name">Filter</span>.<span class="name">compl_mem_coclosedCompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact">coclosedCompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Basic.html#closure">closure</a> <span class="fn">s</span>)</span></span></div></div><p>Complement of a set belongs to <code>coclosedCompact</code> if and only if its closure is compact.</p></div></div><div class="decl" id="Filter.cocompact_le_coclosedCompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L635-L636">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.cocompact_le_coclosedCompact"><span class="name">Filter</span>.<span class="name">cocompact_le_coclosedCompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact">coclosedCompact</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="IsCompact.compl_mem_coclosedCompact_of_isClosed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L640-L642">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.compl_mem_coclosedCompact_of_isClosed"><span class="name">IsCompact</span>.<span class="name">compl_mem_coclosedCompact_of_isClosed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs'</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact">Filter.coclosedCompact</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="Bornology.inCompact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L647-L652">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Bornology.inCompact"><span class="name">Bornology</span>.<span class="name">inCompact</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology">Bornology</a> <span class="fn">X</span></span></div></div><p>Sets that are contained in a compact set form a bornology. Its <code>cobounded</code> filter is
<code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a></code>. See also <code>Bornology.relativelyCompact</code> the bornology of sets with compact
closure.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Topology/Compactness/Compact.html#Bornology.inCompact">Bornology.inCompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology.mk">{</a> <span class="fn">cobounded</span> := <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">X</span></span>, <span class="fn">le_cofinite</span> := <span class="fn">‚ãØ</span> <a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology.mk">}</a></li></ul></details><details id="instances-for-list-Bornology.inCompact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Bornology.inCompact.isBounded_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L654-L657">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Bornology.inCompact.isBounded_iff"><span class="name">Bornology</span>.<span class="name">inCompact</span>.<span class="name">isBounded_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology.IsBounded">IsBounded</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="IsCompact.nhdsSet_prod_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L661-L668">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.nhdsSet_prod_eq"><span class="name">IsCompact</span>.<span class="name">nhdsSet_prod_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> (<span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">s</span></span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">t</span></span></div></div><p>If <code>s</code> and <code>t</code> are compact sets, then the set neighborhoods filter of <code>s √óÀ¢ t</code>
is the product of set neighborhoods filters for <code>s</code> and <code>t</code>.</p><p>For general sets, only the <code>‚â§</code> inequality holds, see <code><a href="../../.././Mathlib/Topology/Constructions.html#nhdsSet_prod_le">nhdsSet_prod_le</a></code>.</p></div></div><div class="decl" id="nhdsSet_prod_le_of_disjoint_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L670-L679">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#nhdsSet_prod_le_of_disjoint_cocompact"><span class="name">nhdsSet_prod_le_of_disjoint_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">Y</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">s</span></span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">f</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> (<span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a>)</span></div></div></div></div><div class="decl" id="prod_nhdsSet_le_of_disjoint_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L681-L690">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#prod_nhdsSet_le_of_disjoint_cocompact"><span class="name">prod_nhdsSet_le_of_disjoint_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> (<a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span>)</span></div></div></div></div><div class="decl" id="nhds_prod_le_of_disjoint_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L692-L695">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#nhds_prod_le_of_disjoint_cocompact"><span class="name">nhds_prod_le_of_disjoint_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">Y</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">f</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> (<a href="../../.././Init/Core.html#Singleton.singleton">{</a><span class="fn">x</span><a href="../../.././Init/Core.html#Singleton.singleton">}</a> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a>)</span></div></div></div></div><div class="decl" id="prod_nhds_le_of_disjoint_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L697-L700">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#prod_nhds_le_of_disjoint_cocompact"><span class="name">prod_nhds_le_of_disjoint_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">y</span> : <span class="fn">Y</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">f</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSet">nhdsSet</a> (<a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <a href="../../.././Init/Core.html#Singleton.singleton">{</a><span class="fn">y</span><a href="../../.././Init/Core.html#Singleton.singleton">}</a>)</span></div></div></div></div><div class="decl" id="generalized_tube_lemma"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L702-L712">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#generalized_tube_lemma"><span class="name">generalized_tube_lemma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hn</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">n</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">u</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>) (<span class="fn">v</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">u</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsOpen">IsOpen</a> <span class="fn">v</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">u</span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">t</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">v</span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">u</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">v</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">n</span></span></div></div><p>If <code>s</code> and <code>t</code> are compact sets and <code>n</code> is an open neighborhood of <code>s √ó t</code>, then there exist
open neighborhoods <code>u ‚äá s</code> and <code>v ‚äá t</code> such that <code>u √ó v ‚äÜ n</code>.</p><p>See also <code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.nhdsSet_prod_eq">IsCompact.nhdsSet_prod_eq</a></code>.</p></div></div><div class="decl" id="IsCompact.nhdsSetWithin_prod_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L714-L721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.nhdsSetWithin_prod_eq"><span class="name">IsCompact</span>.<span class="name">nhdsSetWithin_prod_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">s'</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t </span><span class="fn">t'</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> (<span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span>) (<span class="fn">s'</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t'</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> <span class="fn">s</span> <span class="fn">s'</span></span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> <span class="fn">t</span> <span class="fn">t'</span></span></div></div><p>A relative version of <code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.nhdsSet_prod_eq">IsCompact.nhdsSet_prod_eq</a></code>: if <code>s</code> and <code>t</code> are compact sets,
then the neighborhoods filter of <code>s √óÀ¢ t</code> within <code>s' √óÀ¢ t'</code> is the product of the neighborhoods
filters of <code>s</code> and <code>t</code> within <code>s'</code> and <code>t'</code>.</p><p>For general sets, only the <code>‚â§</code> inequality holds, see <code><a href="../../.././Mathlib/Topology/NhdsWithin.html#nhdsSetWithin_prod_le">nhdsSetWithin_prod_le</a></code>.</p></div></div><div class="decl" id="generalized_tube_lemma'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L724-L728">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#generalized_tube_lemma'"><span class="name">generalized_tube_lemma'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">s'</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t </span><span class="fn">t'</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hn</span> : <span class="fn">n</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> (<span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span>) (<span class="fn">s'</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t'</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">u</span> ‚àà <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> <span class="fn">s</span> <span class="fn">s'</span></span>, <span class="fn">‚àÉ <span class="fn">v</span> ‚àà <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> <span class="fn">t</span> <span class="fn">t'</span></span>, <span class="fn">u</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">v</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">n</span></span></span></div></div><p>A variant of <code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#generalized_tube_lemma">generalized_tube_lemma</a></code> in terms of <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a></code>.</p></div></div><div class="decl" id="generalized_tube_lemma_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L731-L735">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#generalized_tube_lemma_left"><span class="name">generalized_tube_lemma_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">s'</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hn</span> : <span class="fn">n</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> (<span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span>) (<span class="fn">s'</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">u</span> ‚àà <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> <span class="fn">s</span> <span class="fn">s'</span></span>, <span class="fn">u</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">n</span></span></div></div><p>A variant of <code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#generalized_tube_lemma">generalized_tube_lemma</a></code> that only replaces the set in one direction.</p></div></div><div class="decl" id="generalized_tube_lemma_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L738-L743">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#generalized_tube_lemma_right"><span class="name">generalized_tube_lemma_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t </span><span class="fn">t'</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hn</span> : <span class="fn">n</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> (<span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span>) (<span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t'</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">u</span> ‚àà <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsSetWithin">nhdsSetWithin</a> <span class="fn">t</span> <span class="fn">t'</span></span>, <span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">u</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">n</span></span></div></div><p>A variant of <code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#generalized_tube_lemma">generalized_tube_lemma</a></code> that only replaces the set in one direction.</p></div></div><div class="decl" id="Subsingleton.compactSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L746-L747">source</a></div><div class="attributes">@[instance 10]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Subsingleton.compactSpace"><span class="name">Subsingleton</span>.<span class="name">compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="isCompact_univ_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L749-L750">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_univ_iff"><span class="name">isCompact_univ_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="isCompact_univ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L752-L753">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_univ"><span class="name">isCompact_univ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></div></div></div></div><div class="decl" id="exists_clusterPt_of_compactSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L755-L757">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#exists_clusterPt_of_compactSpace"><span class="name">exists_clusterPt_of_compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><span class="fn">f</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> <span class="fn">x</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="Ultrafilter.le_nhds_lim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L759-L761">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Ultrafilter.le_nhds_lim"><span class="name">Ultrafilter</span>.<span class="name">le_nhds_lim</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">F</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Ultrafilter/Defs.html#Ultrafilter">Ultrafilter</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚Üë<span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn"><span class="fn">F</span>.<a href="../../.././Mathlib/Topology/Defs/Ultrafilter.html#Ultrafilter.lim">lim</a></span></span></div></div></div></div><div class="decl" id="CompactSpace.elim_nhds_subcover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L763-L766">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#CompactSpace.elim_nhds_subcover"><span class="name">CompactSpace</span>.<span class="name">elim_nhds_subcover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">X</span></span>), <span class="fn">‚ãÉ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Notation.html#Top.top">‚ä§</a></span></div></div></div></div><div class="decl" id="compactSpace_of_finite_subfamily_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L768-L772">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#compactSpace_of_finite_subfamily_closed"><span class="name">compactSpace_of_finite_subfamily_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn">‚àÄ {<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u} (<span class="fn">t</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>), <span class="fn"><span class="fn">(‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span>)</span> ‚Üí <span class="fn"><span class="fn">‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a> ‚Üí <span class="fn">‚àÉ (<span class="fn">u</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>), <span class="fn">‚ãÇ <span class="fn">i</span> ‚àà <span class="fn">u</span>, <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="CompactSpace.iInter_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L774-L782">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#CompactSpace.iInter_nonempty"><span class="name">CompactSpace</span>.<span class="name">iInter_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">htc</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hst</span> : <span class="fn">‚àÄ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">Œπ</span></span>), <span class="fn"><span class="fn">(‚ãÇ <span class="fn">i</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span>)</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span>)</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span></div></div><p>Given a family of closed sets <code>t i</code> in a compact space, if they satisfy the Finite Intersection
Property, then the intersection of all <code>t i</code> is nonempty.</p></div></div><div class="decl" id="compactSpace_generateFrom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L785-L794">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#compactSpace_generateFrom"><span class="name">compactSpace_generateFrom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">T</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hTS</span> : <span class="fn">T</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Order.html#TopologicalSpace.generateFrom">TopologicalSpace.generateFrom</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ <span class="fn">P</span> ‚äÜ <span class="fn">S</span>, <span class="fn"><a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">‚ãÉ‚ÇÄ</a> <span class="fn">P</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> ‚Üí <span class="fn">‚àÉ <span class="fn">Q</span> ‚äÜ <span class="fn">P</span>, <span class="fn"><span class="fn">Q</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <a href="../../.././Mathlib/Order/SetNotation.html#Set.sUnion">‚ãÉ‚ÇÄ</a> <span class="fn">Q</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span></div></div><p>The <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a></code> version of <strong>Alexander's subbasis theorem</strong>. If <code>X</code> is a topological space with a
subbasis <code>S</code>, then <code>X</code> is compact if for any open cover of <code>X</code> all of whose elements belong to <code>S</code>,
there is a finite subcover.</p></div></div><div class="decl" id="compactSpace_generateFrom'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L797-L803">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#compactSpace_generateFrom'"><span class="name">compactSpace_generateFrom'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">T</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hTS</span> : <span class="fn">T</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Order.html#TopologicalSpace.generateFrom">TopologicalSpace.generateFrom</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u) (<span class="fn">U</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn">‚Üë<span class="fn">S</span></span></span>), <span class="fn"><span class="fn">‚ãÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn">‚Üë<span class="fn">(<span class="fn">U</span> <span class="fn">i</span>)</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a> ‚Üí <span class="fn">‚àÉ (<span class="fn">J</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œπ</span></span>), <span class="fn"><span class="fn">J</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">‚ãÉ <span class="fn">i</span> ‚àà <span class="fn">J</span>, <span class="fn">‚Üë<span class="fn">(<span class="fn">U</span> <span class="fn">i</span>)</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="IsClosed.isCompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L805-L806">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsClosed.isCompact"><span class="name">IsClosed</span>.<span class="name">isCompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="le_nhds_of_unique_clusterPt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L808-L812">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#le_nhds_of_unique_clusterPt"><span class="name">le_nhds_of_unique_clusterPt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#ClusterPt">ClusterPt</a> <span class="fn">x</span> <span class="fn">l</span></span> ‚Üí <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l</span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span></span></div></div><p>If a filter has a unique cluster point <code>y</code> in a compact topological space,
then the filter is less than or equal to <code>ùìù y</code>.</p></div></div><div class="decl" id="tendsto_nhds_of_unique_mapClusterPt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L814-L820">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#tendsto_nhds_of_unique_mapClusterPt"><span class="name">tendsto_nhds_of_unique_mapClusterPt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">Y</span> ‚Üí <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#MapClusterPt">MapClusterPt</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">f</span></span> ‚Üí <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">f</span> <span class="fn">l</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">y</span>)</span></span></div></div><p>If <code>y</code> is a unique <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#MapClusterPt">MapClusterPt</a></code> for <code>f</code> along <code>l</code>
and the codomain of <code>f</code> is a compact space,
then <code>f</code> tends to <code>ùìù y</code> along <code>l</code>.</p></div></div><div class="decl" id="noncompact_univ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L822-L824">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#noncompact_univ"><span class="name">noncompact_univ</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Not">¬¨</a><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></div></div></div></div><div class="decl" id="IsCompact.ne_univ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L826-L827">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.ne_univ"><span class="name">IsCompact</span>.<span class="name">ne_univ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">s</span> <a href="../../.././Init/Core.html#Ne">‚â†</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></div></div></div></div><div class="decl" id="instNeBotCocompactOfNoncompactSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L829-L832">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#instNeBotCocompactOfNoncompactSpace"><span class="name">instNeBotCocompactOfNoncompactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">X</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span></div></div></div></div><div class="decl" id="Filter.cocompact_eq_bot"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L834-L836">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.cocompact_eq_bot"><span class="name">Filter</span>.<span class="name">cocompact_eq_bot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Order/Notation.html#Bot.bot">‚ä•</a></div></div></div></div><div class="decl" id="instNeBotCoclosedCompactOfNoncompactSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L838-L839">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#instNeBotCoclosedCompactOfNoncompactSpace"><span class="name">instNeBotCoclosedCompactOfNoncompactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.coclosedCompact">Filter.coclosedCompact</a> <span class="fn">X</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span></div></div></div></div><div class="decl" id="noncompactSpace_of_neBot"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L841-L842">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#noncompactSpace_of_neBot"><span class="name">noncompactSpace_of_neBot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">X</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span></span></div></div></div></div><div class="decl" id="Filter.cocompact_neBot_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L844-L845">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.cocompact_neBot_iff"><span class="name">Filter</span>.<span class="name">cocompact_neBot_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="not_compactSpace_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L847-L848">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#not_compactSpace_iff"><span class="name">not_compactSpace_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Not">¬¨</a><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="instNoncompactSpaceInt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L850-L851">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#instNoncompactSpaceInt"><span class="name">instNoncompactSpaceInt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <a href="../../.././Init/Data/Int/Basic.html#Int">‚Ñ§</a></span></div></div></div></div><div class="decl" id="finite_of_compact_of_discrete"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L854-L856">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#finite_of_compact_of_discrete"><span class="name">finite_of_compact_of_discrete</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Order.html#DiscreteTopology">DiscreteTopology</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">X</span></span></div></div><p>A compact discrete space is finite.</p></div></div><div class="decl" id="Set.Infinite.exists_accPt_cofinite_inf_principal_of_subset_isCompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L858-L863">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.Infinite.exists_accPt_cofinite_inf_principal_of_subset_isCompact"><span class="name">Set</span>.<span class="name">Infinite</span>.<span class="name">exists_accPt_cofinite_inf_principal_of_subset_isCompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Infinite">Infinite</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hsub</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">K</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">x</span> ‚àà <span class="fn">K</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#AccPt">AccPt</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Cofinite.html#Filter.cofinite">Filter.cofinite</a> ‚äì <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span>)</span></span></span></div></div></div></div><div class="decl" id="Set.Infinite.exists_accPt_of_subset_isCompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L865-L868">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.Infinite.exists_accPt_of_subset_isCompact"><span class="name">Set</span>.<span class="name">Infinite</span>.<span class="name">exists_accPt_of_subset_isCompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s </span><span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Infinite">Infinite</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hsub</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">K</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">x</span> ‚àà <span class="fn">K</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#AccPt">AccPt</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span>)</span></span></span></div></div></div></div><div class="decl" id="Set.Infinite.exists_accPt_cofinite_inf_principal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L870-L873">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.Infinite.exists_accPt_cofinite_inf_principal"><span class="name">Set</span>.<span class="name">Infinite</span>.<span class="name">exists_accPt_cofinite_inf_principal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Infinite">Infinite</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#AccPt">AccPt</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Cofinite.html#Filter.cofinite">Filter.cofinite</a> ‚äì <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span>)</span></span></span></div></div></div></div><div class="decl" id="Set.Infinite.exists_accPt_principal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L875-L876">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.Infinite.exists_accPt_principal"><span class="name">Set</span>.<span class="name">Infinite</span>.<span class="name">exists_accPt_principal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Infinite">Infinite</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#AccPt">AccPt</a> <span class="fn">x</span> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span>)</span></span></span></div></div></div></div><div class="decl" id="exists_nhds_ne_neBot"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L878-L880">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#exists_nhds_ne_neBot"><span class="name">exists_nhds_ne_neBot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Finite/Defs.html#Infinite">Infinite</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">z</span> : <span class="fn">X</span>), <span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> <span class="fn">z</span> <a href="../../.././Init/Core.html#Singleton.singleton">{</a><span class="fn">z</span><a href="../../.././Init/Core.html#Singleton.singleton">}</a><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span></span></div></div></div></div><div class="decl" id="finite_cover_nhds_interior"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L882-L886">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#finite_cover_nhds_interior"><span class="name">finite_cover_nhds_interior</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">X</span></span>), <span class="fn">‚ãÉ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#interior">interior</a> <span class="fn">(<span class="fn">U</span> <span class="fn">x</span>)</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></div></div></div></div><div class="decl" id="finite_cover_nhds"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L888-L891">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#finite_cover_nhds"><span class="name">finite_cover_nhds</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">X</span></span>), <span class="fn">‚ãÉ <span class="fn">x</span> ‚àà <span class="fn">t</span>, <span class="fn"><span class="fn">U</span> <span class="fn">x</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></div></div></div></div><div class="decl" id="Filter.comap_cocompact_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L893-L901">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.comap_cocompact_le"><span class="name">Filter</span>.<span class="name">comap_cocompact_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.comap">comap</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">Y</span>)</span></span> <a href="../../.././Init/Prelude.html#LE.le">‚â§</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span></span></div></div><p>The comap of the cocompact filter on <code>Y</code> by a continuous function <code>f : X ‚Üí Y</code> is less than or
equal to the cocompact filter on <code>X</code>.
This is a reformulation of the fact that images of compact sets are compact.</p></div></div><div class="decl" id="disjoint_map_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L903-L911">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#disjoint_map_cocompact"><span class="name">disjoint_map_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter">Filter</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">X</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> <span class="fn">(<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.map">Filter.map</a> <span class="fn">g</span> <span class="fn">f</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">Y</span>)</span></span></div></div><p>If a filter is disjoint from the cocompact filter, so is its image under any continuous
function.</p></div></div><div class="decl" id="isCompact_range"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L913-L914">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_range"><span class="name">isCompact_range</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#Continuous">Continuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="isCompact_diagonal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L916-L917">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_diagonal"><span class="name">isCompact_diagonal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.diagonal">Set.diagonal</a> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="exists_subset_nhds_of_compactSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L919-L922">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#exists_subset_nhds_of_compactSpace"><span class="name">exists_subset_nhds_of_compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">V</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hV</span> : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Core.html#Superset">‚äá</a> <span class="fn">x2</span>)</span> <span class="fn">V</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hV_closed</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<span class="fn">V</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">U</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hU</span> : <span class="fn">‚àÄ <span class="fn">x</span> ‚àà <span class="fn">‚ãÇ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">V</span> <span class="fn">i</span></span></span>, <span class="fn">U</span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhds">nhds</a> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">V</span> <span class="fn">i</span></span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">U</span></span></div></div></div></div><div class="decl" id="Topology.IsInducing.isCompact_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L924-L931">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsInducing.isCompact_iff"><span class="name">Topology</span>.<span class="name">IsInducing</span>.<span class="name">isCompact_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsInducing">IsInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></div></div><p>If <code>f : X ‚Üí Y</code> is an inducing map, the image <code>f '' s</code> of a set <code>s</code> is compact
if and only if <code>s</code> is compact.</p></div></div><div class="decl" id="Topology.IsEmbedding.isCompact_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L933-L936">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsEmbedding.isCompact_iff"><span class="name">Topology</span>.<span class="name">IsEmbedding</span>.<span class="name">isCompact_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsEmbedding">IsEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></div></div><p>If <code>f : X ‚Üí Y</code> is an embedding, the image <code>f '' s</code> of a set <code>s</code> is compact
if and only if <code>s</code> is compact.</p></div></div><div class="decl" id="Topology.IsInducing.isCompact_preimage"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L938-L942">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsInducing.isCompact_preimage"><span class="name">Topology</span>.<span class="name">IsInducing</span>.<span class="name">isCompact_preimage</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsInducing">IsInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf'</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">(<a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">‚Åª¬π'</a> <span class="fn">K</span>)</span></div></div><p>The preimage of a compact set under an inducing map is a compact set.</p></div></div><div class="decl" id="Topology.IsInducing.isCompact_preimage_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L944-L946">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsInducing.isCompact_preimage_iff"><span class="name">Topology</span>.<span class="name">IsInducing</span>.<span class="name">isCompact_preimage_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsInducing">IsInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">Kf</span> : <span class="fn">K</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">‚Åª¬π'</a> <span class="fn">K</span>)</span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span></div></div></div></div><div class="decl" id="Topology.IsInducing.isCompact_preimage'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L948-L951">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsInducing.isCompact_preimage'"><span class="name">Topology</span>.<span class="name">IsInducing</span>.<span class="name">isCompact_preimage'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsInducing">IsInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">Kf</span> : <span class="fn">K</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn"><a href="../../.././Mathlib/Data/Set/Operations.html#Set.range">Set.range</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">‚Åª¬π'</a> <span class="fn">K</span>)</span></div></div><p>The preimage of a compact set in the image of an inducing map is compact.</p></div></div><div class="decl" id="Topology.IsClosedEmbedding.isCompact_preimage"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L953-L956">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsClosedEmbedding.isCompact_preimage"><span class="name">Topology</span>.<span class="name">IsClosedEmbedding</span>.<span class="name">isCompact_preimage</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsClosedEmbedding">IsClosedEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hK</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">f</span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">‚Åª¬π'</a> <span class="fn">K</span>)</span></div></div><p>The preimage of a compact set under a closed embedding is a compact set.</p></div></div><div class="decl" id="Topology.IsClosedEmbedding.tendsto_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L958-L963">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsClosedEmbedding.tendsto_cocompact"><span class="name">Topology</span>.<span class="name">IsClosedEmbedding</span>.<span class="name">tendsto_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsClosedEmbedding">IsClosedEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">X</span>)</span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a> <span class="fn">Y</span>)</span></span></div></div><p>A closed embedding is proper, i.e., inverse images of compact sets are contained in compacts.
Moreover, the preimage of a compact set is compact, see <code><a href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsClosedEmbedding.isCompact_preimage">IsClosedEmbedding.isCompact_preimage</a></code>.</p></div></div><div class="decl" id="Subtype.isCompact_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L965-L968">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Subtype.isCompact_iff"><span class="name">Subtype</span>.<span class="name">isCompact_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">X</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <a href="../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">X</span> <a href="../../.././Init/Prelude.html#Subtype">//</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Subtype">}</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<a href="../../.././Init/Prelude.html#Subtype.val">val</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></div></div><p>Sets of subtype are compact iff the image under a coercion is.</p></div></div><div class="decl" id="isCompact_iff_isCompact_univ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L970-L971">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iff_isCompact_univ"><span class="name">isCompact_iff_isCompact_univ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a></span></div></div></div></div><div class="decl" id="IsCompact.elim_finite_subfamily_isClosed_subtype"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L974-L987">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.elim_finite_subfamily_isClosed_subtype"><span class="name">IsCompact</span>.<span class="name">elim_finite_subfamily_isClosed_subtype</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ks</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">I</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œπ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">htc</span> : <span class="fn">‚àÄ <span class="fn">i</span> ‚àà <span class="fn">I</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> (<a href="../../.././Init/Prelude.html#Subtype.val">Subtype.val</a> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">‚Åª¬π'</a> <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hst</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ <span class="fn">i</span> ‚àà <span class="fn">I</span>, <span class="fn"><span class="fn">t</span> <span class="fn">i</span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">u</span> : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Defs.html#Finset">Finset</a> <span class="fn">‚Üë<span class="fn">I</span></span></span>), <span class="fn">s</span> <a href="../../.././Init/Core.html#Inter.inter">‚à©</a> <span class="fn">‚ãÇ <span class="fn">i</span> ‚àà <span class="fn">u</span>, <span class="fn"><span class="fn">t</span> <span class="fn">‚Üë<span class="fn">i</span></span></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Core.html#EmptyCollection.emptyCollection">‚àÖ</a></span></div></div><p>An elimination theorem for empty intersections of a family of sets
in a compact subset which are closed in the compact subset
but not necessarily in the ambient space.</p></div></div><div class="decl" id="isCompact_iff_compactSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L989-L990">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_iff_compactSpace"><span class="name">isCompact_iff_compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">‚Üë<span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="IsCompact.finite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L992-L994">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.finite"><span class="name">IsCompact</span>.<span class="name">finite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs'</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Constructions.html#IsDiscrete">IsDiscrete</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span></div></div></div></div><div class="decl" id="exists_nhds_ne_inf_principal_neBot"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L996-L998">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#exists_nhds_ne_inf_principal_neBot"><span class="name">exists_nhds_ne_inf_principal_neBot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs'</span> : <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Infinite">Infinite</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">z</span> ‚àà <span class="fn">s</span>, <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#nhdsWithin">nhdsWithin</a> <span class="fn">z</span> <a href="../../.././Init/Core.html#Singleton.singleton">{</a><span class="fn">z</span><a href="../../.././Init/Core.html#Singleton.singleton">}</a><a href="../../.././Mathlib/Order/Notation.html#HasCompl.compl">·∂ú</a></span> ‚äì <span class="fn"><a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.principal">Filter.principal</a> <span class="fn">s</span></span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.NeBot">NeBot</a></span></span></div></div></div></div><div class="decl" id="Topology.IsClosedEmbedding.noncompactSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1000-L1002">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsClosedEmbedding.noncompactSpace"><span class="name">Topology</span>.<span class="name">IsClosedEmbedding</span>.<span class="name">noncompactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsClosedEmbedding">IsClosedEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="Topology.IsClosedEmbedding.compactSpace"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1004-L1006">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Topology.IsClosedEmbedding.compactSpace"><span class="name">Topology</span>.<span class="name">IsClosedEmbedding</span>.<span class="name">compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Induced.html#Topology.IsClosedEmbedding">IsClosedEmbedding</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="IsCompact.prod"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1008-L1018">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.prod"><span class="name">IsCompact</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">t</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn">s</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">√óÀ¢</a> <span class="fn">t</span>)</span></div></div></div></div><div class="decl" id="Finite.compactSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1020-L1022">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Finite.compactSpace"><span class="name">Finite</span>.<span class="name">compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span></div></div><p>Finite topological spaces are compact.</p></div></div><div class="decl" id="ULift.compactSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1024-L1025">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#ULift.compactSpace"><span class="name">ULift</span>.<span class="name">compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">(<a href="../../.././Init/Prelude.html#ULift">ULift.{v, u}</a> <span class="fn">X</span>)</span></span></div></div></div></div><div class="decl" id="instCompactSpaceProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1027-L1029">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#instCompactSpaceProd"><span class="name">instCompactSpaceProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span></div></div><p>The product of two compact spaces is compact.</p></div></div><div class="decl" id="instCompactSpaceSum"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1031-L1035">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#instCompactSpaceSum"><span class="name">instCompactSpaceSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> (<span class="fn">X</span> <a href="../../.././Init/Core.html#Sum">‚äï</a> <span class="fn">Y</span>)</span></div></div><p>The disjoint union of two compact spaces is compact.</p></div></div><div class="decl" id="instCompactSpaceSigmaOfFinite"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1037-L1041">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#instCompactSpaceSigmaOfFinite"><span class="name">instCompactSpaceSigmaOfFinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Finite/Defs.html#Finite">Finite</a> <span class="fn">Œπ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œπ</span>) √ó <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="Set.isCompact_sigma"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1043-L1047">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Set.isCompact_sigma"><span class="name">Set</span>.<span class="name">isCompact_sigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œπ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">t</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn">‚àÄ <span class="fn">i</span> ‚àà <span class="fn">s</span>, <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Sigma.html#Set.sigma">sigma</a></span> <span class="fn">t</span>)</span></span></div></div></div></div><div class="decl" id="IsCompact.sigma_exists_finite_sigma_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1049-L1061">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsCompact.sigma_exists_finite_sigma_eq"><span class="name">IsCompact</span>.<span class="name">sigma_exists_finite_sigma_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">u</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œπ</span>) √ó <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hu</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">u</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">Œπ</span></span>) (<span class="fn">t</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>), <span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Finite/Defs.html#Set.Finite">Finite</a></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">(‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">t</span> <span class="fn">i</span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn"><span class="fn"><span class="fn">s</span>.<a href="../../.././Mathlib/Data/Set/Sigma.html#Set.sigma">sigma</a></span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">u</span></span></div></div></div></div><div class="decl" id="Filter.coprod_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1063-L1071">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.coprod_cocompact"><span class="name">Filter</span>.<span class="name">coprod_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">X</span>)</span>.<a href="../../.././Mathlib/Order/Filter/Defs.html#Filter.coprod">coprod</a></span> <span class="fn">(<a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">Y</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span></div></div><p>The coproduct of the cocompact filters on two topological spaces is the cocompact filter on
their product.</p></div></div><div class="decl" id="Prod.noncompactSpace_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1073-L1075">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Prod.noncompactSpace_iff"><span class="name">Prod</span>.<span class="name">noncompactSpace_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">Y</span></span> <a href="../../.././Init/Prelude.html#Or">‚à®</a> <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">X</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="Prod.noncompactSpace_left"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1078-L1080">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Prod.noncompactSpace_left"><span class="name">Prod</span>.<span class="name">noncompactSpace_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span></div></div></div></div><div class="decl" id="Prod.noncompactSpace_right"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1083-L1085">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Prod.noncompactSpace_right"><span class="name">Prod</span>.<span class="name">noncompactSpace_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#NoncompactSpace">NoncompactSpace</a> (<span class="fn">X</span> <a href="../../.././Init/Prelude.html#Prod">√ó</a> <span class="fn">Y</span>)</span></div></div></div></div><div class="decl" id="isCompact_pi_infinite"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1091-L1100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_pi_infinite"><span class="name">isCompact_pi_infinite</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">s</span> <span class="fn">i</span>)</span></span>)</span> ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">{</a><span class="fn">x</span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">:</a> <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#setOf">|</a> <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><span class="fn">x</span> <span class="fn">i</span></span> <a href="../../.././Init/Prelude.html#Membership.mem">‚àà</a> <span class="fn"><span class="fn">s</span> <span class="fn">i</span></span></span><a href="../../.././Mathlib/Data/Set/Defs.html#setOf">}</a></span></span></div></div><p><strong>Tychonoff's theorem</strong>: product of compact sets is compact.</p></div></div><div class="decl" id="isCompact_univ_pi"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1102-L1106">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#isCompact_univ_pi"><span class="name">isCompact_univ_pi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn">s</span> <span class="fn">i</span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set.univ">Set.univ</a>.<a href="../../.././Mathlib/Data/Set/Operations.html#Set.pi">pi</a></span> <span class="fn">s</span>)</span></span></div></div><p><strong>Tychonoff's theorem</strong> formulated using <code><a href="../../.././Mathlib/Data/Set/Operations.html#Set.pi">Set.pi</a></code>: product of compact sets is compact.</p></div></div><div class="decl" id="Pi.compactSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1108-L1109">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Pi.compactSpace"><span class="name">Pi</span>.<span class="name">compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span></div></div></div></div><div class="decl" id="Function.compactSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1111-L1112">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Function.compactSpace"><span class="name">Function</span>.<span class="name">compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Y</span> : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">Y</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">(<span class="fn">Œπ</span> ‚Üí <span class="fn">Y</span>)</span></span></div></div></div></div><div class="decl" id="Pi.isCompact_iff_of_isClosed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1114-L1118">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Pi.isCompact_iff_of_isClosed"><span class="name">Pi</span>.<span class="name">isCompact_iff_of_isClosed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">s</span></span> <a href="../../.././Init/Core.html#Iff">‚Üî</a> <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> (<span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> <span class="fn">i</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.image">''</a> <span class="fn">s</span>)</span></span></div></div></div></div><div class="decl" id="Pi.exists_compact_superset_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1120-L1127">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Pi.exists_compact_superset_iff"><span class="name">Pi</span>.<span class="name">exists_compact_superset_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(‚àÉ (<span class="fn">K</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">((<span class="fn">i</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">X</span> <span class="fn">i</span></span>)</span></span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">K</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn">K</span>)</span> <a href="../../.././Init/Core.html#Iff">‚Üî</a>   <span class="fn">‚àÄ (<span class="fn">i</span> : <span class="fn">Œπ</span>), <span class="fn">‚àÉ (<span class="fn">Ki</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">(<span class="fn">X</span> <span class="fn">i</span>)</span></span>), <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#IsCompact">IsCompact</a> <span class="fn">Ki</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">s</span> <a href="../../.././Init/Core.html#HasSubset.Subset">‚äÜ</a> <span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> <span class="fn">i</span></span> <a href="../../.././Mathlib/Data/Set/Operations.html#Set.preimage">‚Åª¬π'</a> <span class="fn">Ki</span></span></span></div></div></div></div><div class="decl" id="Filter.coprod·µ¢_cocompact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1129-L1137">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Filter.coprod·µ¢_cocompact"><span class="name">Filter</span>.<span class="name">coprod·µ¢_cocompact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">Œπ</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <span class="fn"><span class="fn">Œπ</span> ‚Üí <a href="../../.././foundational_types.html">Type</a> u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">d</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn">X</span> <span class="fn">d</span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../.././Mathlib/Order/Filter/Pi.html#Filter.coprod·µ¢">Filter.coprod·µ¢</a> <span class="fn">fun (<span class="fn">d</span> : <span class="fn">Œπ</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">(<span class="fn">X</span> <span class="fn">d</span>)</span></span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">cocompact</a> <span class="fn">((<span class="fn">d</span> : <span class="fn">Œπ</span>) ‚Üí <span class="fn"><span class="fn">X</span> <span class="fn">d</span></span>)</span></span></div></div><p><strong>Tychonoff's theorem</strong> formulated in terms of filters: <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a></code> on an indexed product
type <code>Œ† d, X d</code> the <code><a href="../../.././Mathlib/Order/Filter/Pi.html#Filter.coprod·µ¢">Filter.coprod·µ¢</a></code> of filters <code><a href="../../.././Mathlib/Topology/Defs/Filter.html#Filter.cocompact">Filter.cocompact</a></code> on <code>X d</code>.</p></div></div><div class="decl" id="Quot.compactSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1141-L1144">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Quot.compactSpace"><span class="name">Quot</span>.<span class="name">compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">X</span> ‚Üí <span class="fn">X</span> ‚Üí <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Quotient.compactSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1146-L1147">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#Quotient.compactSpace"><span class="name">Quotient</span>.<span class="name">compactSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <span class="fn"><a href="../../.././Init/Core.html#Setoid">Setoid</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">(<a href="../../.././Init/Core.html#Quotient">Quotient</a> <span class="fn">s</span>)</span></span></div></div></div></div><div class="decl" id="IsClosed.exists_minimal_nonempty_closed_subset"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Topology/Compactness/Compact.lean#L1149-L1186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/Compactness/Compact.html#IsClosed.exists_minimal_nonempty_closed_subset"><span class="name">IsClosed</span>.<span class="name">exists_minimal_nonempty_closed_subset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">X</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Defs/Filter.html#CompactSpace">CompactSpace</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set">Set</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hS</span> : <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">S</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">‚àÉ <span class="fn">V</span> ‚äÜ <span class="fn">S</span>, <span class="fn"><span class="fn">V</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">V</span></span> <a href="../../.././Init/Prelude.html#And">‚àß</a> <span class="fn">‚àÄ <span class="fn">V'</span> ‚äÜ <span class="fn">V</span>, <span class="fn"><span class="fn"><span class="fn">V'</span>.<a href="../../.././Mathlib/Data/Set/Defs.html#Set.Nonempty">Nonempty</a></span> ‚Üí <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/Defs/Basic.html#IsClosed">IsClosed</a> <span class="fn">V'</span></span> ‚Üí <span class="fn">V'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">V</span></span></span></span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>