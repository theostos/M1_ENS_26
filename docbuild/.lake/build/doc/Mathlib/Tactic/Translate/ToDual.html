<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Translate.ToDual</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Translate.ToDual";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Translate</span>.<span class="name">ToDual</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Tactic/Translate/Core.html">Mathlib.Tactic.Translate.Core</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Translate.ToDual" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.to_dual_ignore_args"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">to_dual_ignore_args</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.to_dual_do_translate"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">to_dual_do_translate</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.to_dual_dont_translate"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">to_dual_dont_translate</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.to_dual"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">to_dual</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.attrTo_dual?_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">attrTo_dual?_</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.ignoreArgsAttr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">ignoreArgsAttr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.argInfoAttr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">argInfoAttr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.doTranslateAttr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">doTranslateAttr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.translations"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">translations</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.nameDict"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">nameDict</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.abbreviationDict"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">abbreviationDict</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.ToDual.data"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">data</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-to-dual-attribute">The <code>@[to_dual]</code> attribute. <a class="hover-link" href="#The-to-dual-attribute">#</a></h1><p>The <code>@[to_dual]</code> attribute is used to translate declarations to their dual equivalent.
See the docstrings of <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a></code> and <code>to_additive</code> for more information.</p><p>Known limitations:</p><ul>
<li>Reordering arguments of arguments is not yet supported.
This usually comes up in constructors of structures. e.g. <code><a href="../../.././Init/Prelude.html#Pow.mk">Pow.mk</a></code> or <code>OrderTop.mk</code></li>
<li>When combining <code>to_additive</code> and <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a></code>, we need to make sure that all translations are added.
For example <code>attribute [to_dual (attr := to_additive) le_mul] mul_le</code> should generate
<code>le_mul</code>, <code>le_add</code> and <code>add_le</code>, and in particular should realize that <code>le_add</code> and <code>add_le</code>
are dual to each other. Currently, this requires writing
<code>attribute [to_dual existing le_add] add_le</code>.</li>
</ul></div><div class="decl" id="Mathlib.Tactic.ToDual.to_dual_ignore_args"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L31-L32">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_ignore_args"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">to_dual_ignore_args</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>An attribute that tells that certain arguments of this definition are not
involved when translating.
This helps the translation heuristic by also transforming definitions if <code>ℕ</code> or another
fixed type occurs as one of these arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.ToDual.to_dual_ignore_args" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.ToDual.to_dual_do_translate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L34-L35">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_do_translate"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">to_dual_do_translate</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The global <code>do_translate</code>/<code>dont_translate</code> attributes specify whether operations on
a given type should be translated. <code>dont_translate</code> can be used for types that are translated,
such as <code>MonoidAlgebra</code> -&gt; <code>AddMonoidAlgebra</code>, or for fixed types, such as <code><a href="../../.././Init/Prelude.html#Fin">Fin</a> n</code>/<code>ZMod n</code>.
<code>do_translate</code> is for types without arguments, like <code><a href="../../.././Init/Prelude.html#Unit">Unit</a></code> and <code><a href="../../.././Init/Prelude.html#Empty">Empty</a></code>, where the structure on it
can be translated.</p><p>Note: The name generation is not aware of <code>dont_translate</code>, so if some part of a lemma is not
translated thanks to this, you generally have to specify the translated name manually.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_do_translate">Mathlib.Tactic.ToDual.to_dual_do_translate</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.ToDual.to_dual_do_translate</span> <span class="fn">1024</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;to_dual_do_translate&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.ToDual.to_dual_do_translate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.ToDual.to_dual_dont_translate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L37-L38">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_dont_translate"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">to_dual_dont_translate</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The global <code>do_translate</code>/<code>dont_translate</code> attributes specify whether operations on
a given type should be translated. <code>dont_translate</code> can be used for types that are translated,
such as <code>MonoidAlgebra</code> -&gt; <code>AddMonoidAlgebra</code>, or for fixed types, such as <code><a href="../../.././Init/Prelude.html#Fin">Fin</a> n</code>/<code>ZMod n</code>.
<code>do_translate</code> is for types without arguments, like <code><a href="../../.././Init/Prelude.html#Unit">Unit</a></code> and <code><a href="../../.././Init/Prelude.html#Empty">Empty</a></code>, where the structure on it
can be translated.</p><p>Note: The name generation is not aware of <code>dont_translate</code>, so if some part of a lemma is not
translated thanks to this, you generally have to specify the translated name manually.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual_dont_translate">Mathlib.Tactic.ToDual.to_dual_dont_translate</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.ToDual.to_dual_dont_translate</span> <span class="fn">1024</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;to_dual_dont_translate&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.ToDual.to_dual_dont_translate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.ToDual.to_dual"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L40-L86">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">to_dual</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The attribute <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a></code> can be used to automatically transport theorems
and definitions (but not inductive types and structures) to their dual version.
It uses the same implementation as <code>to_additive</code>.</p><p>To use this attribute, just write:</p><pre><code>@[to_dual]
theorem max_comm' {α} [LinearOrder α] (x y : α) : max x y = max y x := max_comm x y
</code></pre><p>This code will generate a theorem named <code>min_comm'</code>. It is also
possible to manually specify the name of the new declaration:</p><pre><code>@[to_dual le_max_left]
<a href="../../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> min_le_left (a b : α) : min a b ≤ a := sorry
</code></pre><p>An existing documentation string will <em>not</em> be automatically used, so if the theorem or definition
has a doc string, a doc string for the dual version should be passed explicitly to <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a></code>.</p><pre><code>/-- The maximum is commutative. -/
@[to_dual /-- The minimum is commutative. -/]
theorem max_comm' {α} [LinearOrder α] (x y : α) : max x y = max y x := max_comm x y
</code></pre><p>Use the <code>(reorder := ...)</code> syntax to reorder the arguments compared to the dual declaration.
This is specified using cycle notation. For example <code>(reorder := α β, 5 6)</code> swaps the arguments
<code>α</code> and <code>β</code> with each other and the fifth and the sixth argument and <code>(reorder := 3 4 5)</code> will move
the fifth argument before the third argument. For example, this is used when tagging <code><a href="../../.././Init/Prelude.html#LE.le">LE.le</a></code>
with <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> self (reorder := 3 4)</code>, so that <code>a ≤ b</code> gets transformed into <code>b ≤ a</code>.</p><p>Use the <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> self</code> syntax to mark the lemma as its own dual. This is needed if the lemma is
its own dual, up to a reordering of its arguments. <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> self</code> (and <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> existing</code>) tries to
autogenerate the <code>(reorder := ...)</code> argument, so it is usually not necessary to give it explicitly.</p><p>Use the <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> existing</code> syntax to use an existing dual declaration,
instead of automatically generating it.</p><p>Use the <code>(attr := ...)</code> syntax to apply attributes to both the original and the dual version:</p><pre><code>@[to_dual (attr := simp)] <a href="../../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> min_self (a : α) : min a a = a := sorry
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.ToDual.to_dual" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.ToDual.attrTo_dual?_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L89-L89">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.attrTo_dual?_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">attrTo_dual?_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The attribute <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a></code> can be used to automatically transport theorems
and definitions (but not inductive types and structures) to their dual version.
It uses the same implementation as <code>to_additive</code>.</p><p>To use this attribute, just write:</p><pre><code>@[to_dual]
theorem max_comm' {α} [LinearOrder α] (x y : α) : max x y = max y x := max_comm x y
</code></pre><p>This code will generate a theorem named <code>min_comm'</code>. It is also
possible to manually specify the name of the new declaration:</p><pre><code>@[to_dual le_max_left]
<a href="../../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> min_le_left (a b : α) : min a b ≤ a := sorry
</code></pre><p>An existing documentation string will <em>not</em> be automatically used, so if the theorem or definition
has a doc string, a doc string for the dual version should be passed explicitly to <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a></code>.</p><pre><code>/-- The maximum is commutative. -/
@[to_dual /-- The minimum is commutative. -/]
theorem max_comm' {α} [LinearOrder α] (x y : α) : max x y = max y x := max_comm x y
</code></pre><p>Use the <code>(reorder := ...)</code> syntax to reorder the arguments compared to the dual declaration.
This is specified using cycle notation. For example <code>(reorder := α β, 5 6)</code> swaps the arguments
<code>α</code> and <code>β</code> with each other and the fifth and the sixth argument and <code>(reorder := 3 4 5)</code> will move
the fifth argument before the third argument. For example, this is used when tagging <code><a href="../../.././Init/Prelude.html#LE.le">LE.le</a></code>
with <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> self (reorder := 3 4)</code>, so that <code>a ≤ b</code> gets transformed into <code>b ≤ a</code>.</p><p>Use the <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> self</code> syntax to mark the lemma as its own dual. This is needed if the lemma is
its own dual, up to a reordering of its arguments. <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> self</code> (and <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> existing</code>) tries to
autogenerate the <code>(reorder := ...)</code> argument, so it is usually not necessary to give it explicitly.</p><p>Use the <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a> existing</code> syntax to use an existing dual declaration,
instead of automatically generating it.</p><p>Use the <code>(attr := ...)</code> syntax to apply attributes to both the original and the dual version:</p><pre><code>@[to_dual (attr := simp)] <a href="../../.././Mathlib/Tactic/Lemma.html#lemma">lemma</a> min_self (a : α) : min a a = a := sorry
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.ToDual.attrTo_dual?_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.ToDual.ignoreArgsAttr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L91-L101">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.ignoreArgsAttr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">ignoreArgsAttr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span></div></div><p>An attribute that tells that certain arguments of this definition are not
involved when translating.
This helps the translation heuristic by also transforming definitions if <code>ℕ</code> or another
fixed type occurs as one of these arguments.</p></div></div><div class="decl" id="Mathlib.Tactic.ToDual.argInfoAttr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L103-L104">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.argInfoAttr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">argInfoAttr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <a href="../../.././Mathlib/Tactic/Translate/Core.html#Mathlib.Tactic.Translate.ArgInfo">Translate.ArgInfo</a></span></div></div><p><code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.argInfoAttr">argInfoAttr</a></code> stores the declarations that need some extra information to be translated.</p></div></div><div class="decl" id="Mathlib.Tactic.ToDual.doTranslateAttr"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L106-L107">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.doTranslateAttr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">doTranslateAttr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>The global <code>do_translate</code>/<code>dont_translate</code> attributes specify whether operations on
a given type should be translated. <code>dont_translate</code> can be used for types that are translated,
such as <code>MonoidAlgebra</code> -&gt; <code>AddMonoidAlgebra</code>, or for fixed types, such as <code><a href="../../.././Init/Prelude.html#Fin">Fin</a> n</code>/<code>ZMod n</code>.
<code>do_translate</code> is for types without arguments, like <code><a href="../../.././Init/Prelude.html#Unit">Unit</a></code> and <code><a href="../../.././Init/Prelude.html#Empty">Empty</a></code>, where the structure on it
can be translated.</p><p>Note: The name generation is not aware of <code>dont_translate</code>, so if some part of a lemma is not
translated thanks to this, you generally have to specify the translated name manually.</p></div></div><div class="decl" id="Mathlib.Tactic.ToDual.translations"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L121-L122">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.translations"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">translations</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Batteries/Lean/NameMapAttribute.html#Lean.NameMapExtension">Lean.NameMapExtension</a> <a href="../../.././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Maps names to their dual counterparts.</p></div></div><div class="decl" id="Mathlib.Tactic.ToDual.nameDict"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L124-L177">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.nameDict"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">nameDict</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> <a href="../../.././Init/Prelude.html#String">String</a> <span class="fn">(<a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Init/Prelude.html#String">String</a>)</span></span></div></div><p>Dictionary used by <code>guessName</code> to autogenerate names.
This only transforms single name components, unlike <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.abbreviationDict">abbreviationDict</a></code>.</p><p>Note: <code>guessName</code> capitalizes the output according to the capitalization of the input.
In order for this to work, the input should always start with a lower case letter, and the output
should always start with an upper case letter.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.ToDual.nameDict" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.ToDual.abbreviationDict"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L179-L183">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.abbreviationDict"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">abbreviationDict</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> <a href="../../.././Init/Prelude.html#String">String</a> <a href="../../.././Init/Prelude.html#String">String</a></span></div></div><p>We need to fix a few abbreviations after applying <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.nameDict">nameDict</a></code>, i.e. replacing <code>ZeroLE</code> by <code>Nonneg</code>.
This dictionary contains these fixes.
The input should contain entries that is in <code>lowerCamelCase</code> (e.g. <code>ltzero</code>; the initial sequence
of capital letters should be lower-cased) and the output should be in <code>UpperCamelCase</code>
(e.g. <code>LTZero</code>).
When applying the dictionary, we lower-case the output if the input was also given in lower-case.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.abbreviationDict">Mathlib.Tactic.ToDual.abbreviationDict</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Data/HashMap/Basic.html#Std.HashMap.ofList">Std.HashMap.ofList</a> <a href="../../.././Init/Prelude.html#List.cons">[</a><a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">&quot;wellFoundedLT&quot;</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">&quot;WellFoundedGT&quot;</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a><a href="../../.././Init/Prelude.html#List.cons">,</a> <a href="../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">&quot;wellFoundedGT&quot;</span><a href="../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">&quot;WellFoundedLT&quot;</span><a href="../../.././Init/Prelude.html#Prod.mk">)</a><a href="../../.././Init/Prelude.html#List.cons">]</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.ToDual.abbreviationDict" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.ToDual.data"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Translate/ToDual.lean#L185-L191">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.data"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">ToDual</span>.<span class="name">data</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Mathlib/Tactic/Translate/Core.html#Mathlib.Tactic.Translate.TranslateData">Translate.TranslateData</a></div></div><p>The bundle of environment extensions for <code><a href="../../.././Mathlib/Tactic/Translate/ToDual.html#Mathlib.Tactic.ToDual.to_dual">to_dual</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.ToDual.data" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>