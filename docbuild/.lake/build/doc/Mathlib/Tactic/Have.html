<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Have</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Have";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Have</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Have.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Init.html">Mathlib.Init</a></li><li><a href="../.././Lean/Elab/Binders.html">Lean.Elab.Binders</a></li><li><a href="../.././Lean/Elab/SyntheticMVars.html">Lean.Elab.SyntheticMVars</a></li><li><a href="../.././Lean/Meta/Tactic/Assert.html">Lean.Meta.Tactic.Assert</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Have" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.optBinderIdent"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">optBinderIdent</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.optBinderIdent.name"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">optBinderIdent</span>.<span class="name">name</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.haveIdLhs'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">haveIdLhs'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.tacticHave_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">tacticHave_</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.tacticLet_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">tacticLet_</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.tacticSuffices_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">tacticSuffices_</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.haveLetCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">haveLetCore</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Extending-have-let-and-suffices">Extending <code>have</code>, <code>let</code> and <code>suffices</code> <a class="hover-link" href="#Extending-have-let-and-suffices">#</a></h1><p>This file extends the <code>have</code>, <code>let</code> and <code>suffices</code> tactics to allow the addition of hypotheses to
the context without requiring their proofs to be provided immediately.</p><p>As a style choice, this should not be used in mathlib; but is provided for downstream users who
preferred the old style.</p></div><div class="decl" id="Mathlib.Tactic.optBinderIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Have.lean#L28-L32">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Have.html#Mathlib.Tactic.optBinderIdent"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">optBinderIdent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>A parser for optional binder identifiers</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.optBinderIdent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.optBinderIdent.name"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Have.lean#L34-L36">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Have.html#Mathlib.Tactic.optBinderIdent.name"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">optBinderIdent</span>.<span class="name">name</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">id</span> : <a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Mathlib.Tactic.optBinderIdent</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Retrieves the name of the optional identifier, if provided. Returns <code>this</code> otherwise</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Tactic/Have.html#Mathlib.Tactic.optBinderIdent.name">Mathlib.Tactic.optBinderIdent.name</a> <span class="fn">id</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <a href="../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn"><span class="fn">id</span>.<a href="../.././Init/Prelude.html#Lean.TSyntax.raw">raw</a></span><a href="../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">0</span><a href="../.././Init/GetElem.html#GetElem.getElem">]</a>.<a href="../.././Init/Prelude.html#Lean.Syntax.isIdent">isIdent</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a> <a href="../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">id</span>.<a href="../.././Init/Prelude.html#Lean.TSyntax.raw">raw</a></span><a href="../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">0</span><a href="../.././Init/GetElem.html#GetElem.getElem">]</a>.<a href="../.././Init/Prelude.html#Lean.Syntax.getId">getId</a></span>
  <a href="../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../.././Init/Meta/Defs.html#Lean.TSyntax.getId">Lean.TSyntax.getId</a> <span class="fn">(<a href="../.././Init/Meta/Defs.html#Lean.HygieneInfo.mkIdent">Lean.HygieneInfo.mkIdent</a> <a href="../.././Init/Prelude.html#Lean.TSyntax.mk">{</a> <span class="fn">raw</span> := <span class="fn"><span class="fn">id</span>.<a href="../.././Init/Prelude.html#Lean.TSyntax.raw">raw</a></span><a href="../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">0</span><a href="../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../.././Init/Prelude.html#Lean.TSyntax.mk">}</a> <span class="fn">`this</span>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.optBinderIdent.name" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.haveIdLhs'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Have.lean#L38-L54">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Have.html#Mathlib.Tactic.haveIdLhs'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">haveIdLhs'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Lean/Parser/Types.html#Lean.Parser.Parser">Lean.Parser.Parser</a></div></div><p>Uses <code>checkColGt</code> to prevent</p><pre><code class="language-lean">have h
exact <a href="../.././Init/Prelude.html#Nat">Nat</a>
</code></pre><p>From being interpreted as</p><pre><code class="language-lean">have h
  exact <a href="../.././Init/Prelude.html#Nat">Nat</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.haveIdLhs'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.tacticHave_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Have.lean#L56-L57">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Have.html#Mathlib.Tactic.tacticHave_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">tacticHave_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>have</code> tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the <code>let</code> tactic.</p><ul>
<li><code>have h : t := e</code> adds the hypothesis <code>h : t</code> if <code>e</code> is a term of type <code>t</code>.</li>
<li><code>have h := e</code> uses the type of <code>e</code> for <code>t</code>.</li>
<li><code>have : t := e</code> and <code>have := e</code> use <code>this</code> for the name of the hypothesis.</li>
<li><code>have pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,
where <code>_</code> stands for the tactics that follow this one.
It is convenient for types that have only one applicable constructor.
For example, given <code>h : p ∧ q ∧ r</code>, <code>have ⟨h₁, h₂, h₃⟩ := h</code> produces the
hypotheses <code>h₁ : p</code>, <code>h₂ : q</code>, and <code>h₃ : r</code>.</li>
<li>The syntax <code>have (eq := h) pat := e</code> is equivalent to <code>match h : e with | pat =&gt; _</code>,
which adds the equation <code>h : e = pat</code> to the local context.</li>
</ul><p>The tactic supports all the same syntax variants and options as the <code>have</code> term.</p><h2 class="markdown-heading" id="Properties-and-relations">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><ul>
<li>It is not possible to unfold a variable introduced using <code>have</code>, since the definition's value is forgotten.
The <code>let</code> tactic introduces definitions that can be unfolded.</li>
<li>The <code>have h : t := e</code> is like doing <code>let h : t := e; clear_value h</code>.</li>
<li>The <code>have</code> tactic is preferred for propositions, and <code>let</code> is preferred for non-propositions.</li>
<li>Sometimes <code>have</code> is used for non-propositions to ensure that the variable is never unfolded,
which may be important for performance reasons.
Consider using the equivalent <code>let +nondep</code> to indicate the intent.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.tacticHave_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.tacticLet_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Have.lean#L58-L59">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Have.html#Mathlib.Tactic.tacticLet_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">tacticLet_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>let</code> tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by <code>have</code>.</p><ul>
<li><code>let x : t := e</code> adds the definition <code>x : t := e</code> if <code>e</code> is a term of type <code>t</code>.</li>
<li><code>let x := e</code> uses the type of <code>e</code> for <code>t</code>.</li>
<li><code>let : t := e</code> and <code>let := e</code> use <code>this</code> for the name of the hypothesis.</li>
<li><code>let pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,
where <code>_</code> stands for the tactics that follow this one.
It is convenient for types that let only one applicable constructor.
For example, given <code>p : α × β × γ</code>, <code>let ⟨x, y, z⟩ := p</code> produces the
local variables <code>x : α</code>, <code>y : β</code>, and <code>z : γ</code>.</li>
<li>The syntax <code>let (eq := h) pat := e</code> is equivalent to <code>match h : e with | pat =&gt; _</code>,
which adds the equation <code>h : e = pat</code> to the local context.</li>
</ul><p>The tactic supports all the same syntax variants and options as the <code>let</code> term.</p><h2 class="markdown-heading" id="Properties-and-relations">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><ul>
<li>Unlike <code>have</code>, it is possible to unfold definitions introduced using <code>let</code>, using tactics
such as <code>simp</code>, <code>dsimp</code>, <code>unfold</code>, and <code>subst</code>.</li>
<li>The <code>clear_value</code> tactic turns a <code>let</code> definition into a <code>have</code> definition after the fact.
The tactic might fail if the local context depends on the value of the variable.</li>
<li>The <code>let</code> tactic is preferred for data (non-propositions).</li>
<li>Sometimes <code>have</code> is used for non-propositions to ensure that the variable is never unfolded,
which may be important for performance reasons.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.tacticLet_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.tacticSuffices_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Have.lean#L60-L61">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Have.html#Mathlib.Tactic.tacticSuffices_"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">tacticSuffices_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Given a main goal <code>ctx ⊢ t</code>, <code>suffices h : t' from e</code> replaces the main goal with <code>ctx ⊢ t'</code>,
<code>e</code> must have type <code>t</code> in the context <code>ctx, h : t'</code>.</p><p>The variant <code>suffices h : t' by tac</code> is a shorthand for <code>suffices h : t' from by tac</code>.
If <code>h :</code> is omitted, the name <code>this</code> is used.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.tacticSuffices_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.haveLetCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Have.lean#L64-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Tactic/Have.html#Mathlib.Tactic.haveLetCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">haveLetCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Mathlib.Tactic.optBinderIdent</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">bis</span> : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> (<a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Lean.Parser.Term.letIdBinder</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <a href="../.././Init/Meta/Defs.html#Lean.Syntax.Term">Lean.Term</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">keepTerm</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> (<a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></div></div><p>Adds hypotheses to the context, turning them into goals to be proved later if their proof terms
aren't provided (<code>t: <a href="../.././Init/Prelude.html#Option">Option</a> Term := none</code>).</p><p>If the bound term is intended to be kept in the context, pass <code>keepTerm : <a href="../.././Init/Prelude.html#Bool">Bool</a> := true</code>. This is
useful when extending the <code>let</code> tactic, which is expected to show the proof term in the infoview.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.haveLetCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>