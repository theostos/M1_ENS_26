<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Algebra.HierarchyDesign</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Algebra.HierarchyDesign";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Algebra</span>.<span class="name">HierarchyDesign</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Init.html">Mathlib.Init</a></li><li><a href="../.././Mathlib/Tactic/Basic.html">Mathlib.Tactic.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Algebra.HierarchyDesign" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#LibraryNote.«the algebraic hierarchy»"><span class="name">LibraryNote</span>.<span class="name">«the algebraic hierarchy»</span></a></div><div class="nav_link"><a class="break_within" href="#LibraryNote.«reducible non-instances»"><span class="name">LibraryNote</span>.<span class="name">«reducible non-instances»</span></a></div><div class="nav_link"><a class="break_within" href="#LibraryNote.«implicit instance arguments»"><span class="name">LibraryNote</span>.<span class="name">«implicit instance arguments»</span></a></div><div class="nav_link"><a class="break_within" href="#LibraryNote.«lower instance priority»"><span class="name">LibraryNote</span>.<span class="name">«lower instance priority»</span></a></div><div class="nav_link"><a class="break_within" href="#LibraryNote.«instance argument order»"><span class="name">LibraryNote</span>.<span class="name">«instance argument order»</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Documentation-of-the-algebraic-hierarchy">Documentation of the algebraic hierarchy <a class="hover-link" href="#Documentation-of-the-algebraic-hierarchy">#</a></h1><p>A library note giving advice on modifying the algebraic hierarchy.
(It is not intended as a &quot;tour&quot;.) This is ported directly from the Lean3 version, so may
refer to files/types that currently only exist in mathlib3.</p><p>TODO: Add sections about interactions with topological typeclasses, and order typeclasses.</p></div><div class="decl" id="LibraryNote.«the algebraic hierarchy»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L25-L189">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«the algebraic hierarchy»"><span class="name">LibraryNote</span>.<span class="name">«the algebraic hierarchy»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote">Batteries.Util.LibraryNote</a></div></div><h1 class="markdown-heading" id="The-algebraic-hierarchy">The algebraic hierarchy <a class="hover-link" href="#The-algebraic-hierarchy">#</a></h1><p>In any theorem proving environment,
there are difficult decisions surrounding the design of the &quot;algebraic hierarchy&quot;.</p><p>There is a danger of exponential explosion in the number of gadgets,
especially once interactions between algebraic and order/topological/etc. structures are considered.</p><p>In mathlib, we try to avoid this by only introducing new algebraic typeclasses either</p><ol>
<li>when there is &quot;real mathematics&quot; to be done with them, or</li>
<li>when there is a meaningful gain in simplicity by factoring out a common substructure.</li>
</ol><p>(As examples, at this point we don't have <code>Loop</code>, or <code>UnitalMagma</code>,
but we do have <code>LieSubmodule</code> and <code>TopologicalField</code>!
We also have <code>GroupWithZero</code>, as an exemplar of point 2.)</p><p>Generally in mathlib we use the extension mechanism (so <code>CommRing</code> extends <code>Ring</code>)
rather than mixins (e.g. with separate <code>Ring</code> and <code>CommMul</code> classes),
in part because of the potential blow-up in term sizes described at
<a href="https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html">https://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html</a>
However there is tension here, as it results in considerable duplication in the API,
particularly in the interaction with order structures.</p><p>This library note is not intended as a design document
justifying and explaining the history of mathlib's algebraic hierarchy!
Instead it is intended as a developer's guide, for contributors wanting to extend
(either new leaves, or new intermediate classes) the algebraic hierarchy as it exists.</p><p>(Ideally we would have both a tour guide to the existing hierarchy,
and an account of the design choices.
See <a href="https://arxiv.org/abs/1910.09336">https://arxiv.org/abs/1910.09336</a> for an overview of mathlib as a whole,
with some attention to the algebraic hierarchy and
<a href="https://leanprover-community.github.io/mathlib-overview.html">https://leanprover-community.github.io/mathlib-overview.html</a>
for a summary of what is in mathlib today.)</p><h2 class="markdown-heading" id="Instances">Instances <a class="hover-link" href="#Instances">#</a></h2><p>When adding a new typeclass <code>Z</code> to the algebraic hierarchy
one should attempt to add the following constructions and results,
when applicable:</p><ul>
<li>Instances transferred elementwise to products, like <code>Prod.Monoid</code>.
See <code><a href="../.././Mathlib/Algebra/Group/Prod.html">Mathlib/Algebra/Group/Prod.lean</a></code> for more examples.<pre><code>instance Prod.Z [Z M] [Z N] : Z (M × N) := ...
</code></pre>
</li>
<li>Instances transferred elementwise to pi types, like <code>Pi.Monoid</code>.
See <code><a href="../.././Mathlib/Algebra/Group/Pi.html">Mathlib/Algebra/Group/Pi.lean</a></code> for more examples.<pre><code>instance Pi.Z [∀ i, Z &lt;| f i] : Z (Π i : I, f i) := ...
</code></pre>
</li>
<li>Instances transferred to <code>MulOpposite M</code>, like <code>MulOpposite.Monoid</code>.
See <code><a href="../.././Mathlib/Algebra/Opposites.html">Mathlib/Algebra/Opposites.lean</a></code> for more examples.<pre><code>instance MulOpposite.Z [Z M] : Z (MulOpposite M) := ...
</code></pre>
</li>
<li>Instances transferred to <code><a href="../.././Init/Prelude.html#ULift">ULift</a> M</code>, like <code>ULift.Monoid</code>.
See <code><a href="../.././Mathlib/Algebra/Group/ULift.html">Mathlib/Algebra/Group/ULift.lean</a></code> for more examples.<pre><code>instance ULift.Z [Z M] : Z (ULift M) := ...
</code></pre>
</li>
<li>Definitions for transferring the proof fields of instances along
injective or surjective functions that agree on the data fields,
like <code>Function.Injective.monoid</code> and <code>Function.Surjective.monoid</code>.
We make these definitions <code>abbrev</code>, see note [reducible non-instances].
See <code><a href="../.././Mathlib/Algebra/Group/InjSurj.html">Mathlib/Algebra/Group/InjSurj.lean</a></code> for more examples.<pre><code>abbrev Function.Injective.Z [Z M₂] (f : M₁ → M₂) (hf : f.Injective)
  (one : f 1 = 1) (mul : ∀ x y, f (x * y) = f x * f y) : Z M₁ := ...

abbrev Function.Surjective.Z [Z M₁] (f : M₁ → M₂) (hf : f.Surjective)
  (one : f 1 = 1) (mul : ∀ x y, f (x * y) = f x * f y) : Z M₂ := ...
</code></pre>
</li>
<li>Instances transferred elementwise to <code>Finsupp</code>s, like <code>Finsupp.semigroup</code>.
See <code><a href="../.././Mathlib/Data/Finsupp/Pointwise.html">Mathlib/Data/Finsupp/Pointwise.lean</a></code> for more examples.<pre><code>instance Finsupp.Z [Z β] : Z (α →₀ β) := ...
</code></pre>
</li>
<li>Instances transferred elementwise to <code>Set</code>s, like <code>Set.monoid</code>.
See <code><a href="../.././Mathlib/Algebra/Pointwise.html">Mathlib/Algebra/Pointwise.lean</a></code> for more examples.<pre><code>instance Set.Z [Z α] : Z (Set α) := ...
</code></pre>
</li>
<li>Definitions for transferring the entire structure across an equivalence, like <code>Equiv.monoid</code>.
See <code><a href="../.././Mathlib/Data/Equiv/TransferInstance.html">Mathlib/Data/Equiv/TransferInstance.lean</a></code> for more examples. See also the <code>transport</code> tactic.<pre><code>def Equiv.Z (e : α ≃ β) [Z β] : Z α := ...
/-- When there is a new notion of `Z`-equiv: -/
def Equiv.ZEquiv (e : α ≃ β) [Z β] : by { letI := Equiv.Z e, exact α ≃Z β } := ...
</code></pre>
</li>
</ul><h2 class="markdown-heading" id="Subobjects">Subobjects <a class="hover-link" href="#Subobjects">#</a></h2><p>When a new typeclass <code>Z</code> adds new data fields,
you should also create a new <code>SubZ</code> <code>structure</code> with a <code>carrier</code> field.</p><p>This can be a lot of work; for now try to closely follow the existing examples
(e.g. <code>Submonoid</code>, <code>Subring</code>, <code>Subalgebra</code>).
We would very much like to provide some automation here, but a prerequisite will be making
all the existing APIs more uniform.</p><p>If <code>Z</code> extends <code>Y</code>, then <code>SubZ</code> should usually extend <code>SubY</code>.</p><p>When <code>Z</code> adds only new proof fields to an existing structure <code>Y</code>,
you should provide instances transferring
<code>Z α</code> to <code>Z (SubY α)</code>, like <code>Submonoid.toCommMonoid</code>.
Typically this is done using the <code>Function.Injective.Z</code> definition mentioned above.</p><pre><code>instance SubY.toZ [Z α] : Z (SubY α) :=
  coe_injective.Z coe ...
</code></pre><h2 class="markdown-heading" id="Morphisms-and-equivalences">Morphisms and equivalences <a class="hover-link" href="#Morphisms-and-equivalences">#</a></h2><h2 class="markdown-heading" id="Category-theory">Category theory <a class="hover-link" href="#Category-theory">#</a></h2><p>For many algebraic structures, particularly ones used in representation theory, algebraic geometry,
etc., we also define &quot;bundled&quot; versions, which carry <code>category</code> instances.</p><p>These bundled versions are usually named by appending <code>Cat</code>,
so for example we have <code>AddCommGrpCat</code> as a bundled <code>AddCommGroup</code>, and <code>TopCommRingCat</code>
(which bundles together <code>CommRing</code>, <code>TopologicalSpace</code>, and <code>IsTopologicalRing</code>).</p><p>These bundled versions have many appealing features:</p><ul>
<li>a uniform notation for morphisms <code>X ⟶ Y</code></li>
<li>a uniform notation (and definition) for isomorphisms <code>X ≅ Y</code></li>
<li>a uniform API for subobjects, via the partial order <code>Subobject X</code></li>
<li>interoperability with unbundled structures, via coercions to <code>Type</code>
(so if <code>G : AddCommGrpCat</code>, you can treat <code>G</code> as a type,
and it automatically has an <code>AddCommGroup</code> instance)
and lifting maps <code>AddCommGrpCat.of G</code>, when <code>G</code> is a type with an <code>AddCommGroup</code> instance.</li>
</ul><p>If, for example you do the work of proving that a typeclass <code>Z</code> has a good notion of tensor product,
you are strongly encouraged to provide the corresponding <code>MonoidalCategory</code> instance
on a bundled version.
This ensures that the API for tensor products is complete, and enables use of general machinery.
Similarly if you prove universal properties, or adjunctions, you are encouraged to state these
using categorical language!</p><p>One disadvantage of the bundled approach is that we can only speak of morphisms between
objects living in the same type-theoretic universe.
In practice this is rarely a problem.</p><h1 class="markdown-heading" id="Making-a-pull-request">Making a pull request <a class="hover-link" href="#Making-a-pull-request">#</a></h1><p>With so many moving parts, how do you actually go about changing the algebraic hierarchy?</p><p>We're still evolving how to handle this, but the current suggestion is:</p><ul>
<li>If you're adding a new &quot;leaf&quot; class, the requirements are lower,
and an initial PR can just add whatever is immediately needed.</li>
<li>A new &quot;intermediate&quot; class, especially low down in the hierarchy,
needs to be careful about leaving gaps.</li>
</ul><p>In a perfect world, there would be a group of simultaneous PRs that basically cover everything!
(Or at least an expectation that PRs may not be merged immediately while waiting on other
PRs that fill out the API.)</p><p>However &quot;perfect is the enemy of good&quot;, and it would also be completely reasonable
to add a TODO list in the main module doc-string for the new class,
briefly listing the parts of the API which still need to be provided.
Hopefully this document makes it easy to assemble this list.</p><p>Another alternative to a TODO list in the doc-strings is adding Github issues.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«the algebraic hierarchy»">LibraryNote.«the algebraic hierarchy»</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Inhabited.default">default</a></li></ul></details><details id="instances-for-list-LibraryNote.«the algebraic hierarchy»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="LibraryNote.«reducible non-instances»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L191-L206">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«reducible non-instances»"><span class="name">LibraryNote</span>.<span class="name">«reducible non-instances»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote">Batteries.Util.LibraryNote</a></div></div><p>Some definitions that define objects of a class cannot be instances, because they have an
explicit argument that does not occur in the conclusion. An example is <code>Preorder.lift</code> that has a
function <code>f : α → β</code> as an explicit argument to lift a preorder on <code>β</code> to a preorder on <code>α</code>.</p><p>If these definitions are used to define instances of this class <em>and</em> this class is an argument to
some other type-class so that type-class inference will have to unfold these instances to check
for definitional equality, then these definitions should be marked <code>@[reducible]</code>.</p><p>For example, <code>Preorder.lift</code> is used to define <code>Units.Preorder</code> and <code>PartialOrder.lift</code> is used
to define <code>Units.PartialOrder</code>. In some cases it is important that type-class inference can
recognize that <code>Units.Preorder</code> and <code>Units.PartialOrder</code> give rise to the same <code><a href="../.././Init/Prelude.html#LE">LE</a></code> instance.
For example, you might have another class that takes <code>[LE α]</code> as an argument, and this argument
sometimes comes from <code>Units.Preorder</code> and sometimes from <code>Units.PartialOrder</code>.
Therefore, <code>Preorder.lift</code> and <code>PartialOrder.lift</code> are marked <code>@[reducible]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«reducible non-instances»">LibraryNote.«reducible non-instances»</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Inhabited.default">default</a></li></ul></details><details id="instances-for-list-LibraryNote.«reducible non-instances»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="LibraryNote.«implicit instance arguments»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L208-L217">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«implicit instance arguments»"><span class="name">LibraryNote</span>.<span class="name">«implicit instance arguments»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote">Batteries.Util.LibraryNote</a></div></div><p>There are places where typeclass arguments are specified with implicit <code>{}</code> brackets instead of
the usual <code>[]</code> brackets. This is done when the instances can be inferred because they are implicit
arguments to the type of one of the other arguments. When they can be inferred from these other
arguments, it is faster to use this method than to use type class inference.</p><p>For example, when writing lemmas about <code>(f : α →+* β)</code>, it is faster to specify the fact that <code>α</code>
and <code>β</code> are <code>Semiring</code>s as <code>{rα : Semiring α} {rβ : Semiring β}</code> rather than the usual
<code>[Semiring α] [Semiring β]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«implicit instance arguments»">LibraryNote.«implicit instance arguments»</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Inhabited.default">default</a></li></ul></details><details id="instances-for-list-LibraryNote.«implicit instance arguments»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="LibraryNote.«lower instance priority»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L219-L234">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«lower instance priority»"><span class="name">LibraryNote</span>.<span class="name">«lower instance priority»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote">Batteries.Util.LibraryNote</a></div></div><p>Certain instances always apply during type-class resolution. For example, the instance
<code>AddCommGroup.toAddGroup {α} [AddCommGroup α] : AddGroup α</code> applies to all type-class
resolution problems of the form <code>AddGroup _</code>, and type-class inference will then do an
exhaustive search to find a commutative group. These instances take a long time to fail.
Other instances will only apply if the goal has a certain shape. For example
<code>Int.instAddGroupInt : AddGroup ℤ</code> or
<code>Prod.instAddGroup {α β} [AddGroup α] [AddGroup β] : AddGroup (α × β)</code>. Usually these instances
will fail quickly, and when they apply, they are almost always the desired instance.
For this reason, we want the instances of the second type (that only apply in specific cases) to
always have higher priority than the instances of the first type (that always apply).
See also <a href="https://github.com/leanprover-community/mathlib/issues/1561">mathlib#1561</a>.</p><p>Therefore, if we create an instance that always applies, we set the priority of these instances to
100 (or something similar, which is below the default value of 1000).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«lower instance priority»">LibraryNote.«lower instance priority»</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Inhabited.default">default</a></li></ul></details><details id="instances-for-list-LibraryNote.«lower instance priority»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="LibraryNote.«instance argument order»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L236-L254">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«instance argument order»"><span class="name">LibraryNote</span>.<span class="name">«instance argument order»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote">Batteries.Util.LibraryNote</a></div></div><p>When type class inference applies an instance, it attempts to solve the sub-goals from left to
right (it used to be from right to left in lean 3). For example in</p><pre><code>instance {p : α → Sort*} [∀ x, IsEmpty (p x)] [Nonempty α] : IsEmpty (∀ x, p x)
</code></pre><p>we make sure to write <code>[∀ x, IsEmpty (p x)]</code> on the left of <code>[Nonempty α]</code> to avoid an expensive
search for <code><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> α</code> when there is no instance for <code>∀ x, IsEmpty (p x)</code>.</p><p>This helps to speed up failing type class searches, for example those triggered by <code>simp</code> lemmas.</p><p>In some situations, we can't reorder type class assumptions because one depends on the other,
for example in</p><pre><code>instance {G : Type*} [Group G] [IsKleinFour G] : IsAddKleinFour (Additive G)
</code></pre><p>where the <code>Group G</code> instance appears in <code>IsKleinFour G</code>. Future work may be done to improve the
type class synthesis order in this situation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«instance argument order»">LibraryNote.«instance argument order»</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Inhabited.default">default</a></li></ul></details><details id="instances-for-list-LibraryNote.«instance argument order»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>