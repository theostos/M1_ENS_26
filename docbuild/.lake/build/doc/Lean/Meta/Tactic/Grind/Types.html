<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Meta.Tactic.Grind.Types</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Lean.Meta.Tactic.Grind.Types";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Tactic</span>.<span class="name">Grind</span>.<span class="name">Types</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Lean/HeadIndex.html">Lean.HeadIndex</a></li><li><a href="../../../.././Lean/PrettyPrinter.html">Lean.PrettyPrinter</a></li><li><a href="../../../.././Init/Data/Queue.html">Init.Data.Queue</a></li><li><a href="../../../.././Lean/Meta/AbstractNestedProofs.html">Lean.Meta.AbstractNestedProofs</a></li><li><a href="../../../.././Lean/Parser/Do.html">Lean.Parser.Do</a></li><li><a href="../../../.././Lean/Meta/Match/MatchEqsExt.html">Lean.Meta.Match.MatchEqsExt</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/AlphaShareCommon.html">Lean.Meta.Tactic.Grind.AlphaShareCommon</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/Attr.html">Lean.Meta.Tactic.Grind.Attr</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/CheckResult.html">Lean.Meta.Tactic.Grind.CheckResult</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html">Lean.Meta.Tactic.Grind.ExprPtr</a></li><li><a href="../../../.././Lean/Meta/Tactic/Grind/ExtAttr.html">Lean.Meta.Tactic.Grind.ExtAttr</a></li><li><a href="../../../.././Lean/Meta/Tactic/Simp/Types.html">Lean.Meta.Tactic.Simp.Types</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Meta.Tactic.Grind.Types" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.congrPlaceholderProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">congrPlaceholderProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.eqCongrSymmPlaceholderProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">eqCongrSymmPlaceholderProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isDefEqD"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isDefEqD</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isDefEqI"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isDefEqI</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isInterpreted"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInterpreted</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.grind.debug"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.grind.debug.proofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span>.<span class="name">proofs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.grind.warning"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">warning</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.AnchorRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">AnchorRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtensionStateSpec"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtensionStateSpec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtensionState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtensionState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverExtensionState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtensionState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitSource</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitSource</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSplitSource.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitSource</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitSource.toMessageData"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitSource</span>.<span class="name">toMessageData</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Context</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTheoremCacheKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrTheoremCacheKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrTheoremCacheKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Counters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Counters</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCounters.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCounters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitDiagInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitDiagInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instNonemptyState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptyState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.MethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">MethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptyMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GrindM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mapGrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mapGrindM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SavedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SavedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instNonemptySavedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptySavedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.saveState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SavedState.restore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SavedState</span>.<span class="name">restore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instMonadBacktrackSavedStateGrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instMonadBacktrackSavedStateGrindM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withoutReportingMVarIssues"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutReportingMVarIssues</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withSplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withSplitSource</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withGTransparency"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withGTransparency</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getNatZeroExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNatZeroExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getOrderingEqExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getOrderingEqExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getIntExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getIntExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getAnchorRefs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getAnchorRefs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.resetAnchors"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">resetAnchors</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.cheapCasesOnly"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">cheapCasesOnly</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withCheapCasesOnly"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withCheapCasesOnly</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.reportMVarInternalization"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportMVarInternalization</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getSymbolPriorities"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getSymbolPriorities</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isMatchEqLikeDeclName"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isMatchEqLikeDeclName</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getEMatchTheoremNumInstances"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEMatchTheoremNumInstances</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.saveCases"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveCases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.saveAppOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveAppOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.saveSplitDiagInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveSplitDiagInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getMaxGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMaxGeneration</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.abstractNestedProofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">abstractNestedProofs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.shareCommon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">shareCommon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isTrueExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isFalseExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkHCongrWithArity"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHCongrWithArity</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.reportIssue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportIssue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.doElemReportIssue!__"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">doElemReportIssue!__</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.expandReportDbgIssueMacro"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">expandReportDbgIssueMacro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.doElemReportDbgIssue!__"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">doElemReportDbgIssue!__</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverTerms.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverTerms</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instReprSolverTerms.repr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprSolverTerms</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instReprSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprSolverTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedENode.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instReprENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instReprENode.repr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENode.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENode.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isCongrRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.NewFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.NewFact.toExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewFact</span>.<span class="name">toExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENodeMap</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENodeMap</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CongrTable"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTable</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ParentSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedParentSet.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedParentSet</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedParentSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedParentSet</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ParentSet.insert"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ParentSet.isEmpty"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span>.<span class="name">isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ParentSet.elems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span>.<span class="name">elems</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ParentMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentMap</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashablePreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashablePreInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqPreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqPreInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PreInstanceSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstanceSet</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.NewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewRawFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedNewRawFact.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CanonArgKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CanonArgKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqCanonArgKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCanonArgKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqCanonArgKey.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCanonArgKey</span>.<span class="name">beq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableCanonArgKey.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCanonArgKey</span>.<span class="name">hash</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableCanonArgKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCanonArgKey</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Canon.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Canon.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Canon.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.CaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CaseTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedCaseTrace.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatch.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatch.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EMatch.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSplitInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">hash</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instHashableSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableSplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">beq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instBEqSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqSplitInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.getExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">getExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.source"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">source</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitInfo.lt"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">lt</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SplitArg"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitArg</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Split.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Split.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Split.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Clean.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Clean.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Clean.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.UnitLike.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.UnitLike.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.UnitLike.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.InjectiveInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">InjectiveInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedInjectiveInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedInjectiveInfo</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedInjectiveInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedInjectiveInfo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Injective.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Injective</span>.<span class="name">State</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Injective.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Injective</span>.<span class="name">instInhabitedState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Injective.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Injective</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.TheoremGuard"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">TheoremGuard</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedTheoremGuard.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTheoremGuard</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedTheoremGuard"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTheoremGuard</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.DelayedTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">DelayedTheoremInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedDelayedTheoremInstance.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedDelayedTheoremInstance</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedDelayedTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedDelayedTheoremInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedGoal.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.hasSameRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">hasSameRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.isCongruent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">isCongruent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.admit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">admit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM.runCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">runCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.GoalM.run'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.updateLastTag"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">updateLastTag</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.«doElemTrace_goal[_]__»"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">«doElemTrace_goal[_]__»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markTheoremInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addNewRawFact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getNumTheoremInstances"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNumTheoremInstances</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.checkMaxInstancesExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxInstancesExceeded</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.checkMaxCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxCaseSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.checkMaxEmatchExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxEmatchExceeded</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.throwNonInternalizedExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">throwNonInternalizedExpr</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getGeneration</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getGeneration</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isEqv"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqv</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRootENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getRootENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.useFunCC"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">useFunCC</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getNext?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNext</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.alreadyInternalized"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">alreadyInternalized</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getTarget?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTarget?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.hasSameType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasSameType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqHEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushHEq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolTrue</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.pushEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolFalse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.registerParent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerParent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getParents"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getParents</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.resetParentsOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">resetParentsOf</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.copyParentsTo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">copyParentsTo</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkENodeCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENodeCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.setENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">setENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.hasType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasType</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.forEachDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachDiseq</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isCongrRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getCongrRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInconsistent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHEqProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.processNewFacts"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">processNewFacts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">internalize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.preprocess"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">preprocess</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.internalizeLocalDecl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">internalizeLocalDecl</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqHEqProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqTrueProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqFalseProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqBoolTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolTrueProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.mkEqBoolFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolFalseProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markAsInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsInconsistent</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.assignFalseProof"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">assignFalseProof</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.withContext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">withContext</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.mkAuxMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">mkAuxMVar</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.closeGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">closeGoal</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExprs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.traverseEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">traverseEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.findEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">findEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.foldEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">foldEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.forEachENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachENode</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.filterENodes"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">filterENodes</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.forEachEqcRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachEqcRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Propagator"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Propagator</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EvalTactic"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EvalTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.EvalTactic.skip"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EvalTactic</span>.<span class="name">skip</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Methods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedMethods.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Methods.toMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span>.<span class="name">toMethodsRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateUp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateUp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.propagateDown"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateDown</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.evalTactic"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">evalTactic</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqcs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqcs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isKnownCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isKnownCaseSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isResolvedCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isResolvedCaseSplit</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.markCaseSplitAsResolved"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markCaseSplitAsResolved</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addSplitCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addSplitCandidate</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ActivateNextGuardResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ActivateNextGuardResult</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.activateNextGuard"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">activateNextGuard</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addTheoremInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.DelayedTheoremInstance.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">DelayedTheoremInstance</span>.<span class="name">check</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.getExtTheorems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExtTheorems</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.addLookaheadCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addLookaheadCandidate</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.withoutModifyingState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutModifyingState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.canon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">canon</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.TGrind"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">TGrind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ActionResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ActionResult</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.ActionCont"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ActionCont</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Action"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Action</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Action.notApplicable"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Action</span>.<span class="name">notApplicable</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedAction"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedAction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverExtension.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtension</span>.<span class="name">default</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedSolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtension</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.registerSolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerSolverExtension</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.setMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">setMethods</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.mkInitialStates"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mkInitialStates</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instInhabitedGoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoalM</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.modifyState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">modifyState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.getStateCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getStateCore</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.getState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getState</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">internalize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.checkInvariants"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">checkInvariants</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.check?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">check?</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">check</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.mbtc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mbtc</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Action.andAlso"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Action</span>.<span class="name">andAlso</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.mkAction"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mkAction</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.propagateDiseqs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">propagateDiseqs</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.isSameSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isSameSolverTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.markTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">markTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.getTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getTerm</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.SolverExtension.hasTermAtRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">hasTermAtRoot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PendingSolverPropagations"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PendingSolverPropagations</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Solvers.mergeTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mergeTerms</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.PendingSolverPropagations.propagate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PendingSolverPropagations</span>.<span class="name">propagate</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.anchorPrefixToString"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">anchorPrefixToString</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.anchorToString"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">anchorToString</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.AnchorRef.toString"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">AnchorRef</span>.<span class="name">toString</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.instToStringAnchorRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instToStringAnchorRef</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.Grind.Goal.getActiveMatchEqTheorems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getActiveMatchEqTheorems</span></a></div></nav><main>
<div class="decl" id="Lean.Meta.Grind.congrPlaceholderProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L23-L24">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.congrPlaceholderProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">congrPlaceholderProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></div><p>We use this auxiliary constant to mark delayed congruence proofs.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.congrPlaceholderProof">Lean.Meta.Grind.congrPlaceholderProof</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Lean.Name.mkSimple">Lean.Name.mkSimple</a> <span class="fn">&quot;[congruence]&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.congrPlaceholderProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.eqCongrSymmPlaceholderProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L26-L56">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.eqCongrSymmPlaceholderProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">eqCongrSymmPlaceholderProof</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></div><p>We use this auxiliary constant to mark delayed symmetric congruence proofs.
<strong>Example:</strong> <code>a = b</code> is symmetrically congruent to <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a> = d</code> if <code>a = d</code> and <code>b = <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a></code>.</p><p><strong>Note:</strong> We previously used <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.congrPlaceholderProof">congrPlaceholderProof</a></code> for this case, but it
caused non-termination during proof term construction when <code>a = b = <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a> = d</code>.
The issue was that we did not have enough information to determine how
<code>a = b</code> and <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a> = d</code> became congruent. The new marker resolves this issue.</p><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.congrPlaceholderProof">congrPlaceholderProof</a></code> is used, then <code>a = b</code> became congruent to <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a> = d</code>
because <code>a = <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a></code> and <code>b = d</code>.
If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.eqCongrSymmPlaceholderProof">eqCongrSymmPlaceholderProof</a></code> is used, then it was because <code>a = d</code> and <code>b = <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a></code>.</p><p><strong>Example:</strong> suppose we have the following equivalence class:</p><pre><code>{p, q, p = q, q = p, True}
</code></pre><p>Recall that <code><a href="../../../.././Init/Prelude.html#True">True</a></code> is always the root of its equivalence class.
Assume we also have the following two paths in the class:</p><pre><code>1. p -&gt; p = q -&gt; q = p -&gt; <a href="../../../.././Init/Prelude.html#True">True</a>
2. q -&gt; <a href="../../../.././Init/Prelude.html#True">True</a>
</code></pre><p>Now suppose we try to build a proof for <code>p = <a href="../../../.././Init/Prelude.html#True">True</a></code>.
We must construct a proof for <code>(p = q) = (q = p)</code>.
These equalities are congruent, but if we try to prove <code>p = q</code> and <code>q = p</code>
using the facts <code>p = <a href="../../../.././Init/Prelude.html#True">True</a></code> and <code>q = <a href="../../../.././Init/Prelude.html#True">True</a></code>, we end up trying to prove <code>p = <a href="../../../.././Init/Prelude.html#True">True</a></code> again.
In other words, we are missing the information that <code>p = q</code> became congruent to <code>q = p</code>
because of the symmetric case. By using <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.eqCongrSymmPlaceholderProof">eqCongrSymmPlaceholderProof</a></code>, we retain this information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.eqCongrSymmPlaceholderProof">Lean.Meta.Grind.eqCongrSymmPlaceholderProof</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.mkConst">Lean.mkConst</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Lean.Name.mkSimple">Lean.Name.mkSimple</a> <span class="fn">&quot;[eq_congr_symm]&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.eqCongrSymmPlaceholderProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isDefEqD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L58-L60">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqD"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isDefEqD</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">s</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Similar to <code>isDefEq</code>, but ensures default transparency is used.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqD">Lean.Meta.Grind.isDefEqD</a> <span class="fn">t</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.withDefault">Lean.Meta.withDefault</a> <span class="fn">(<a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.isDefEq">Lean.Meta.isDefEq</a> <span class="fn">t</span> <span class="fn">s</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isDefEqD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isDefEqI"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L62-L64">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqI"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isDefEqI</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">s</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Similar to <code>isDefEq</code>, but ensures that only reducible definitions and instances can be reduced.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqI">Lean.Meta.Grind.isDefEqI</a> <span class="fn">t</span> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.withReducibleAndInstances">Lean.Meta.withReducibleAndInstances</a> <span class="fn">(<a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.isDefEq">Lean.Meta.isDefEq</a> <span class="fn">t</span> <span class="fn">s</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isDefEqI" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isInterpreted"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L66-L72">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInterpreted"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInterpreted</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is <code><a href="../../../.././Init/Prelude.html#True">True</a></code>, <code><a href="../../../.././Init/Prelude.html#False">False</a></code>, or a literal value.
See <code><a href="../../../.././Lean/Meta/LitValues.html">Lean.Meta.LitValues</a></code> for supported literals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInterpreted">Lean.Meta.Grind.isInterpreted</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.isTrue">isTrue</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.isFalse">isFalse</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">do
    let <span class="fn">y</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span>
    <span class="fn"><span class="fn">(fun (<span class="fn">y</span> : <a href="../../../.././Init/Prelude.html#PUnit">PUnit</a>) =&gt; <span class="fn"><a href="../../../.././Lean/Meta/LitValues.html#Lean.Meta.isLitValue">Lean.Meta.isLitValue</a> <span class="fn">e</span></span>)</span> <span class="fn">y</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isInterpreted" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.grind.debug"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L74-L77">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.debug"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.grind.debug.proofs"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L79-L82">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.debug.proofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">debug</span>.<span class="name">proofs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.grind.warning"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L84-L87">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.warning"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">grind</span>.<span class="name">warning</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Data/Options.html#Lean.Option">Lean.Option</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.AnchorRef"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L89-L96">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">AnchorRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Anchors are used to reference terms, local theorems, and case-splits in the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> state.
We also use anchors to prune the search space when they are provided as <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> parameters
and the <code>finish</code> tactic.</p><ul class="structure_fields" id="Lean.Meta.Grind.AnchorRef.mk"><li id="Lean.Meta.Grind.AnchorRef.numDigits" class="structure_field"><div class="structure_field_info">numDigits : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.AnchorRef.anchorPrefix" class="structure_field"><div class="structure_field_info">anchorPrefix : <a href="../../../.././Init/Prelude.html#UInt64">UInt64</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.AnchorRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtensionStateSpec"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L98-L99">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionStateSpec"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtensionStateSpec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>) × <span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span></span></div></div><p>Opaque solver extension state.</p></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtensionState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L100-L100">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtensionState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState">Lean.Meta.Grind.SolverExtensionState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionStateSpec">Lean.Meta.Grind.SolverExtensionStateSpec</a>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtensionState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverExtensionState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L101-L101">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtensionState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtensionState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState">SolverExtensionState</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtensionState">Lean.Meta.Grind.instInhabitedSolverExtensionState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionStateSpec">Lean.Meta.Grind.SolverExtensionStateSpec</a>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitSource"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L103-L126">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitSource</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case-split source. That is, where it came from.
We store the current source in the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> context.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.SplitSource.ematch">ematch<span class="decl_args">
<span class="fn">(<span class="fn">origin</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin">Origin</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Generated while instantiating a theorem using E-matching.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.ext">ext<span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Generated while instantiating an extensionality theorem with name <code>declName</code></p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.mbtc">mbtc<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Model-based theory combination equality coming from the i-th argument of applications <code>a</code> and <code>b</code></p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.beta">beta<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Beta-reduction.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.forallProp">forallProp<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Forall-propagator.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.existsProp">existsProp<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Exists-propagator.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.input">input : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Input goal</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.inj">inj<span class="decl_args">
<span class="fn">(<span class="fn">origin</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin">Origin</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p>Injectivity theorem.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitSource.guard">guard<span class="decl_args">
<span class="fn">(<span class="fn">origin</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin">Origin</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a><div class="inductive_ctor_doc"><p><code>grind_pattern</code> guard</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitSource" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSplitSource"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L126-L126">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitSource</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource">Lean.Meta.Grind.instInhabitedSplitSource</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource.default">Lean.Meta.Grind.instInhabitedSplitSource.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSplitSource.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L126-L126">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitSource</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitSource.default">Lean.Meta.Grind.instInhabitedSplitSource.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ematch">Lean.Meta.Grind.SplitSource.ematch</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedSplitSource.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitSource.toMessageData"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L128-L137">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitSource</span>.<span class="name">toMessageData</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a> → <a href="../../../.././Lean/Message.html#Lean.MessageData">MessageData</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ematch">Lean.Meta.Grind.SplitSource.ematch</a> <span class="fn">origin</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;E-matching `&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn"><span class="fn">origin</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin.pp">pp</a></span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;`&quot;</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.guard">Lean.Meta.Grind.SplitSource.guard</a> <span class="fn">origin</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Theorem instantiation guard for `&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn"><span class="fn">origin</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin.pp">pp</a></span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;`&quot;</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ext">Lean.Meta.Grind.SplitSource.ext</a> <span class="fn">declName</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Extensionality `&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">declName</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;`&quot;</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.beta">Lean.Meta.Grind.SplitSource.beta</a> <span class="fn">e</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Beta-reduction of&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.indentExpr">Lean.indentExpr</a> <span class="fn">e</span>)</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.forallProp">Lean.Meta.Grind.SplitSource.forallProp</a> <span class="fn">e</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Forall propagation at&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.indentExpr">Lean.indentExpr</a> <span class="fn">e</span>)</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.existsProp">Lean.Meta.Grind.SplitSource.existsProp</a> <span class="fn">e</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Exists propagation at&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.indentExpr">Lean.indentExpr</a> <span class="fn">e</span>)</span></span></li><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.input">Lean.Meta.Grind.SplitSource.input</a>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.MessageData.ofFormat">Lean.MessageData.ofFormat</a> <a href="../../../.././Init/Prelude.html#Function.comp">∘</a> <a href="../../../.././Init/Data/Format/Basic.html#Std.ToFormat.format">Std.format</a>) <span class="fn">&quot;Initial goal&quot;</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.inj">Lean.Meta.Grind.SplitSource.inj</a> <span class="fn">origin</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.toMessageData">toMessageData</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;Injectivity `&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn"><span class="fn">origin</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin.pp">pp</a></span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;`&quot;</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitSource.toMessageData" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L139-L177">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Context</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Context for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a></code> monad.</p><ul class="structure_fields" id="Lean.Meta.Grind.Context.mk"><li id="Lean.Meta.Grind.Context.simp" class="structure_field"><div class="structure_field_info">simp : <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context">Simp.Context</a></div></li><li id="Lean.Meta.Grind.Context.simpMethods" class="structure_field"><div class="structure_field_info">simpMethods : <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Methods">Simp.Methods</a></div></li><li id="Lean.Meta.Grind.Context.config" class="structure_field"><div class="structure_field_info">config : <a href="../../../.././Init/Grind/Config.html#Lean.Grind.Config">Grind.Config</a></div></li><li id="Lean.Meta.Grind.Context.anchorRefs?" class="structure_field"><div class="structure_field_info">anchorRefs? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef">AnchorRef</a>)</span></span></div><div class="structure_field_doc"><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.anchorRefs?">anchorRefs?</a> := some anchorRefs</code>, then only local instances and case-splits in <code>anchorRefs</code>
are considered.</p></div></li><li id="Lean.Meta.Grind.Context.cheapCases" class="structure_field"><div class="structure_field_info">cheapCases : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.cheapCases">cheapCases</a></code> is <code>true</code>, <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> only applies <code>cases</code> to types that contain
at most one minor premise.
Recall that <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> applies <code>cases</code> when introducing types tagged with <code>[grind cases eager]</code>,
and at <code>Split.lean</code>
Remark: We add this option to implement the <code>lookahead</code> feature, we don't want to create several subgoals
when performing lookahead.</p></div></li><li id="Lean.Meta.Grind.Context.reportMVarIssue" class="structure_field"><div class="structure_field_info">reportMVarIssue : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Lean.Meta.Grind.Context.splitSource" class="structure_field"><div class="structure_field_info">splitSource : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div><div class="structure_field_doc"><p>Current source of case-splits.</p></div></li><li id="Lean.Meta.Grind.Context.symPrios" class="structure_field"><div class="structure_field_info">symPrios : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities">SymbolPriorities</a></div><div class="structure_field_doc"><p>Symbol priorities for inferring E-matching patterns</p></div></li><li id="Lean.Meta.Grind.Context.funCCs" class="structure_field"><div class="structure_field_info">funCCs : <a href="../../../.././Lean/Data/NameMap/Basic.html#Lean.NameSet">NameSet</a></div><div class="structure_field_doc"><p>Global declarations marked with <code>@[grind funCC]</code></p></div></li><li id="Lean.Meta.Grind.Context.trueExpr" class="structure_field"><div class="structure_field_info">trueExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.falseExpr" class="structure_field"><div class="structure_field_info">falseExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.natZExpr" class="structure_field"><div class="structure_field_info">natZExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.btrueExpr" class="structure_field"><div class="structure_field_info">btrueExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.bfalseExpr" class="structure_field"><div class="structure_field_info">bfalseExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.ordEqExpr" class="structure_field"><div class="structure_field_info">ordEqExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.Context.intExpr" class="structure_field"><div class="structure_field_info">intExpr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Context" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CongrTheoremCacheKey"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L179-L182">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTheoremCacheKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Key for the congruence theorem cache.</p><ul class="structure_fields" id="Lean.Meta.Grind.CongrTheoremCacheKey.mk"><li id="Lean.Meta.Grind.CongrTheoremCacheKey.f" class="structure_field"><div class="structure_field_info">f : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.CongrTheoremCacheKey.numArgs" class="structure_field"><div class="structure_field_info">numArgs : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CongrTheoremCacheKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqCongrTheoremCacheKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L185-L186">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrTheoremCacheKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">CongrTheoremCacheKey</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrTheoremCacheKey">Lean.Meta.Grind.instBEqCongrTheoremCacheKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#BEq.mk">{</a>     <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">a</span> <span class="fn">b</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">Lean.Meta.Grind.CongrTheoremCacheKey</a>) =&gt;
      <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></span></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></span></span> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableCongrTheoremCacheKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L189-L190">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrTheoremCacheKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrTheoremCacheKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">CongrTheoremCacheKey</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrTheoremCacheKey">Lean.Meta.Grind.instHashableCongrTheoremCacheKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a>     <span class="fn">hash</span> := <span class="fn">fun (<span class="fn">a</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">Lean.Meta.Grind.CongrTheoremCacheKey</a>) =&gt;
      <span class="fn"><a href="../../../.././Init/Prelude.html#mixHash">mixHash</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.hashPtrExpr">Lean.Meta.Grind.hashPtrExpr</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></span>)</span></span></span> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Counters"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L192-L199">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Counters</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.Counters.mk"><li id="Lean.Meta.Grind.Counters.thm" class="structure_field"><div class="structure_field_info">thm : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Theorems.html#Lean.Meta.Grind.Origin">Origin</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>Number of times E-match theorem has been instantiated.</p></div></li><li id="Lean.Meta.Grind.Counters.case" class="structure_field"><div class="structure_field_info">case : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>Number of times a <code>cases</code> has been performed on an inductive type/predicate</p></div></li><li id="Lean.Meta.Grind.Counters.apps" class="structure_field"><div class="structure_field_info">apps : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div><div class="structure_field_doc"><p>Number of applications per function symbol. This information is only collected if <code>set_option diagnostics true</code></p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Counters" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCounters.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L199-L199">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters">Counters</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters.default">Lean.Meta.Grind.instInhabitedCounters.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.mk">{</a> <span class="fn">thm</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">case</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">apps</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedCounters.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCounters"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L199-L199">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCounters</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters">Counters</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters">Lean.Meta.Grind.instInhabitedCounters</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCounters.default">Lean.Meta.Grind.instInhabitedCounters.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitDiagInfo"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L203-L209">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitDiagInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case-split diagnostic information</p><ul class="structure_fields" id="Lean.Meta.Grind.SplitDiagInfo.mk"><li id="Lean.Meta.Grind.SplitDiagInfo.lctx" class="structure_field"><div class="structure_field_info">lctx : <a href="../../../.././Lean/LocalContext.html#Lean.LocalContext">LocalContext</a></div></li><li id="Lean.Meta.Grind.SplitDiagInfo.c" class="structure_field"><div class="structure_field_info">c : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.SplitDiagInfo.gen" class="structure_field"><div class="structure_field_info">gen : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.SplitDiagInfo.numCases" class="structure_field"><div class="structure_field_info">numCases : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.SplitDiagInfo.splitSource" class="structure_field"><div class="structure_field_info">splitSource : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitDiagInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L211-L249">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>State for the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a></code> monad.</p><ul class="structure_fields" id="Lean.Meta.Grind.State.mk"><li id="Lean.Meta.Grind.State.scState" class="structure_field"><div class="structure_field_info">scState : <a href="../../../.././Lean/Meta/Tactic/Grind/AlphaShareCommon.html#Lean.Meta.Grind.AlphaShareCommon.State">AlphaShareCommon.State</a></div><div class="structure_field_doc"><p><code>ShareCommon</code> (aka <code>Hash-consing</code>) state.</p></div></li><li id="Lean.Meta.Grind.State.congrThms" class="structure_field"><div class="structure_field_info">congrThms : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey">CongrTheoremCacheKey</a> <a href="../../../.././Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem">CongrTheorem</a></span></div><div class="structure_field_doc"><p>Congruence theorems generated so far. Recall that for constant symbols
we rely on the reserved name feature (i.e., <code>mkHCongrWithArityForConst?</code>).
Remark: we currently do not reuse congruence theorems</p></div></li><li id="Lean.Meta.Grind.State.simp" class="structure_field"><div class="structure_field_info">simp : <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.State">Simp.State</a></div></li><li id="Lean.Meta.Grind.State.lastTag" class="structure_field"><div class="structure_field_info">lastTag : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></div><div class="structure_field_doc"><p>Used to generate trace messages of the for <code>[grind] working on &lt;tag&gt;</code>,
and implement the macro <code>trace_goal</code>.</p></div></li><li id="Lean.Meta.Grind.State.issues" class="structure_field"><div class="structure_field_info">issues : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Message.html#Lean.MessageData">MessageData</a></span></div><div class="structure_field_doc"><p>Issues found during the proof search. These issues are reported to
users when <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> fails.</p></div></li><li id="Lean.Meta.Grind.State.counters" class="structure_field"><div class="structure_field_info">counters : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters">Counters</a></div><div class="structure_field_doc"><p>Performance counters</p></div></li><li id="Lean.Meta.Grind.State.splitDiags" class="structure_field"><div class="structure_field_info">splitDiags : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo">SplitDiagInfo</a></span></div><div class="structure_field_doc"><p>Split diagnostic information. This information is only collected when <code>set_option diagnostics true</code></p></div></li><li id="Lean.Meta.Grind.State.lawfulEqCmpMap" class="structure_field"><div class="structure_field_info">lawfulEqCmpMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from binary functions <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> to a theorem <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.thm">thm</a> : ∀ a b, <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a> a b = .<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.eq">eq</a> → a = b</code>
if it implements the <code>LawfulEqCmp</code> type class.</p></div></li><li id="Lean.Meta.Grind.State.reflCmpMap" class="structure_field"><div class="structure_field_info">reflCmpMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from binary functions <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> to a theorem <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.thm">thm</a> : ∀ a, <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a> a a = .<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.eq">eq</a></code>
if it implements the <code>ReflCmp</code> type class.</p></div></li><li id="Lean.Meta.Grind.State.anchors" class="structure_field"><div class="structure_field_info">anchors : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <a href="../../../.././Init/Prelude.html#UInt64">UInt64</a></span></div><div class="structure_field_doc"><p>Cached anchors (aka stable hash codes) for terms in the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> state.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instNonemptyState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L251-L252">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instNonemptyState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptyState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Nonempty">Nonempty</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State">State</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.MethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L255-L255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">MethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">Lean.Meta.Grind.MethodsRef</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.MethodsRefPointed">Lean.Meta.Grind.MethodsRefPointed✝</a>.<a href="../../../.././Init/Prelude.html#NonemptyType.type">type</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.MethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instNonemptyMethodsRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L256-L256">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instNonemptyMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptyMethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Nonempty">Nonempty</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">MethodsRef</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.GrindM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L258-L258">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GrindM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">Lean.Meta.Grind.MethodsRef</a>
    <span class="fn">(<a href="../../../.././Init/Prelude.html#ReaderT">ReaderT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a> <span class="fn">(<a href="../../../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../../../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State">Lean.Meta.Grind.State</a> <a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GrindM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mapGrindM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L260-L261">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mapGrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mapGrindM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>} → <span class="fn"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">α</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mapGrindM">Lean.Meta.Grind.mapGrindM</a> <span class="fn">f</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Control/Basic.html#controlAt">controlAt</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a>
    <span class="fn">fun (<span class="fn">runInBase</span> : <span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <span class="fn">(<a href="../../../.././Init/Control/Basic.html#MonadControlT.stM">stM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <span class="fn">m</span> <span class="fn">β</span>)</span></span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn">runInBase</span> <span class="fn">x</span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mapGrindM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SavedState"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L263-L269">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SavedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Backtrackable state for the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a></code> monad.</p><ul class="structure_fields" id="Lean.Meta.Grind.SavedState.mk"><li id="Lean.Meta.Grind.SavedState.meta" class="structure_field"><div class="structure_field_info">meta : <a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.SavedState">Meta.SavedState</a></div></li><li id="Lean.Meta.Grind.SavedState.grind" class="structure_field"><div class="structure_field_info">grind : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State">State</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SavedState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instNonemptySavedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L269-L269">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instNonemptySavedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instNonemptySavedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Nonempty">Nonempty</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState">SavedState</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.saveState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L271-L272">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState">SavedState</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveState">Lean.Meta.Grind.saveState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.saveState">Lean.Meta.saveState</a></span>
  let <span class="fn">__do_lift_1</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.mk">{</a> <span class="fn">«meta»</span> := <span class="fn">__do_lift</span>, <span class="fn">grind</span> := <span class="fn">__do_lift_1</span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.mk">}</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.saveState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SavedState.restore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L274-L277">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.restore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SavedState</span>.<span class="name">restore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState">SavedState</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Restore backtrackable parts of the state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">b</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.restore">restore</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn"><span class="fn"><span class="fn">b</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.meta">meta</a></span>.<a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.SavedState.restore">restore</a></span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#MonadStateOf.set">set</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SavedState.restore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instMonadBacktrackSavedStateGrindM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L279-L281">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instMonadBacktrackSavedStateGrindM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instMonadBacktrackSavedStateGrindM</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Util/MonadBacktrack.html#Lean.MonadBacktrack">MonadBacktrack</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState">SavedState</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instMonadBacktrackSavedStateGrindM">Lean.Meta.Grind.instMonadBacktrackSavedStateGrindM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Lean/Util/MonadBacktrack.html#Lean.MonadBacktrack.mk">{</a> <span class="fn">saveState</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveState">Lean.Meta.Grind.saveState</a>, <span class="fn">restoreState</span> := <span class="fn">fun (<span class="fn">s</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState">Lean.Meta.Grind.SavedState</a>) =&gt; <span class="fn"><span class="fn">s</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.restore">restore</a></span></span> <a href="../../../.././Lean/Util/MonadBacktrack.html#Lean.MonadBacktrack.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withoutReportingMVarIssues"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L283-L288">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withoutReportingMVarIssues"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutReportingMVarIssues</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withoutReportingMVarIssues">withoutReportingMVarIssues</a> x</code> executes <code>x</code> without reporting metavariables found during internalization.
See comment at <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.reportMVarIssue">Grind.Context.reportMVarIssue</a></code> for additional details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withoutReportingMVarIssues" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withSplitSource"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L290-L295">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withSplitSource"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withSplitSource</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">splitSource</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withSplitSource">withSplitSource</a> s x</code> executes <code>x</code> and uses <code>s</code> as the split source for any case-split
registered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withSplitSource" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L297-L299">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Grind/Config.html#Lean.Grind.Config">Grind.Config</a></span></div></div><p>Returns the user-defined configuration options</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.config">config</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withGTransparency"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L301-L307">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withGTransparency"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withGTransparency</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></div></div><p>Runs <code>k</code> with the transparency setting specified by <code>Config.reducible</code>.
Uses reducible transparency if <code>reducible</code> is <code>true</code>, otherwise default transparency.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withGTransparency" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L309-L311">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTrueExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#True">True</a></code> constant.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.trueExpr">trueExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L313-L315">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getFalseExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#False">False</a></code> constant.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.falseExpr">falseExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getBoolTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L317-L319">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolTrueExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr">Lean.Meta.Grind.getBoolTrueExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.btrueExpr">btrueExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getBoolTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getBoolFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L321-L323">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getBoolFalseExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr">Lean.Meta.Grind.getBoolFalseExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.bfalseExpr">bfalseExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getBoolFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getNatZeroExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L325-L327">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNatZeroExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNatZeroExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code>0 : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></code> numeral.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNatZeroExpr">Lean.Meta.Grind.getNatZeroExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.natZExpr">natZExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getNatZeroExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getOrderingEqExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L329-L331">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getOrderingEqExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getOrderingEqExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Data/Ord/Basic.html#Ordering.eq">Ordering.eq</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getOrderingEqExpr">Lean.Meta.Grind.getOrderingEqExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.ordEqExpr">ordEqExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getOrderingEqExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getIntExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L333-L335">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getIntExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getIntExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the internalized <code><a href="../../../.././Init/Data/Int/Basic.html#Int">Int</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getIntExpr">Lean.Meta.Grind.getIntExpr</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.intExpr">intExpr</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getIntExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getAnchorRefs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L337-L339">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getAnchorRefs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getAnchorRefs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef">AnchorRef</a>)</span>)</span></span></div></div><p>Returns the anchor references (if any) being used to restrict the search.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getAnchorRefs">Lean.Meta.Grind.getAnchorRefs</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.anchorRefs?">anchorRefs?</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getAnchorRefs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.resetAnchors"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L341-L342">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.resetAnchors"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">resetAnchors</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.resetAnchors" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.cheapCasesOnly"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L344-L345">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.cheapCasesOnly"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">cheapCasesOnly</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.cheapCasesOnly">Lean.Meta.Grind.cheapCasesOnly</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.cheapCases">cheapCases</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.cheapCasesOnly" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withCheapCasesOnly"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L347-L348">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withCheapCasesOnly"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withCheapCasesOnly</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withCheapCasesOnly" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.reportMVarInternalization"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L350-L351">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.reportMVarInternalization"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportMVarInternalization</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.reportMVarInternalization">Lean.Meta.Grind.reportMVarInternalization</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.reportMVarIssue">reportMVarIssue</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.reportMVarInternalization" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getSymbolPriorities"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L353-L355">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getSymbolPriorities"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getSymbolPriorities</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.SymbolPriorities">SymbolPriorities</a></span></div></div><p>Returns symbol priorities for inferring E-matching patterns.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getSymbolPriorities">Lean.Meta.Grind.getSymbolPriorities</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#readThe">readThe</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context">Lean.Meta.Grind.Context</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.symPrios">symPrios</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getSymbolPriorities" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isMatchEqLikeDeclName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L357-L361">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isMatchEqLikeDeclName"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isMatchEqLikeDeclName</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>declName</code> is the name of a <code>match</code> equation or a <code>match</code> congruence equation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isMatchEqLikeDeclName" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getEMatchTheoremNumInstances"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L372-L373">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEMatchTheoremNumInstances"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEMatchTheoremNumInstances</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">thm</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEMatchTheoremNumInstances">Lean.Meta.Grind.getEMatchTheoremNumInstances</a> <span class="fn">thm</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.State.counters">counters</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Counters.thm">thm</a></span> <span class="fn"><span class="fn">thm</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem.origin">origin</a></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">0</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getEMatchTheoremNumInstances" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.saveCases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L375-L376">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveCases"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveCases</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">declName</span> : <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.saveCases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.saveAppOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L378-L381">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveAppOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveAppOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../../.././Lean/HeadIndex.html#Lean.HeadIndex">HeadIndex</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveAppOf">Lean.Meta.Grind.saveAppOf</a> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/CoreM.html#Lean.isDiagnosticsEnabled">Lean.isDiagnosticsEnabled</a></span>
  <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn">__do_lift</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.saveAppOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.saveSplitDiagInfo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L383-L386">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.saveSplitDiagInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">saveSplitDiagInfo</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">gen </span><span class="fn">numCases</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">splitSource</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.saveSplitDiagInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getMethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L388-L389">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethodsRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">MethodsRef</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethodsRef">Lean.Meta.Grind.getMethodsRef</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#MonadReader.read">read</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getMethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getMaxGeneration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L391-L393">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMaxGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMaxGeneration</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Returns maximum term generation that is considered during ematching.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMaxGeneration">Lean.Meta.Grind.getMaxGeneration</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Init/Grind/Config.html#Lean.Grind.Config.gen">gen</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getMaxGeneration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.abstractNestedProofs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L395-L399">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.abstractNestedProofs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">abstractNestedProofs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Abstracts nested proofs in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. This is a preprocessing step performed before internalization.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.abstractNestedProofs">Lean.Meta.Grind.abstractNestedProofs</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<a href="../../../.././Lean/Meta/AbstractNestedProofs.html#Lean.Meta.abstractNestedProofs">Lean.Meta.abstractNestedProofs</a> <span class="fn">e</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.abstractNestedProofs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.shareCommon"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L401-L409">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.shareCommon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">shareCommon</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Applies hash-consing to <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. Recall that all expressions in a <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> goal have
been hash-consed. We perform this step before we internalize expressions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.shareCommon" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isTrueExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L411-L413">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isTrueExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isTrueExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the internalized <code><a href="../../../.././Init/Prelude.html#True">True</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isTrueExpr">Lean.Meta.Grind.isTrueExpr</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isTrueExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isFalseExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L415-L417">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isFalseExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isFalseExpr</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the internalized <code><a href="../../../.././Init/Prelude.html#False">False</a></code> expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isFalseExpr">Lean.Meta.Grind.isFalseExpr</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn">e</span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isFalseExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkHCongrWithArity"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L419-L432">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkHCongrWithArity"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHCongrWithArity</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">numArgs</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem">CongrTheorem</a></span></div></div><p>Creates a congruence theorem for a <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code>-applications with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.numArgs">numArgs</a></code> arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkHCongrWithArity" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.reportIssue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L434-L441">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.reportIssue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">reportIssue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">msg</span> : <a href="../../../.././Lean/Message.html#Lean.MessageData">MessageData</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.reportIssue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.doElemReportIssue!__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L449-L450">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.doElemReportIssue!__"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">doElemReportIssue!__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.doElemReportIssue!__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.expandReportDbgIssueMacro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L452-L458">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.expandReportDbgIssueMacro"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">expandReportDbgIssueMacro</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href="../../../.././Init/Prelude.html#Lean.Syntax">Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Lean.MacroM">MacroM</a> (<a href="../../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`doElem</span>)</span></div></div><p>Similar to <code>expandReportIssueMacro</code>, but only reports issue if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.debug">grind.debug</a></code> is set to <code>true</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.expandReportDbgIssueMacro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.doElemReportDbgIssue!__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L461-L462">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.doElemReportDbgIssue!__"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">doElemReportDbgIssue!__</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Similar to <code>reportIssue!</code>, but only reports issue if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.grind.debug">grind.debug</a></code> is set to <code>true</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.doElemReportDbgIssue!__" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverTerms"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L464-L479">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverTerms</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Each E-node may have &quot;solver terms&quot; attached to them.
Each term is an element of the equivalence class that the
solver cares about. Each solver is responsible for marking the terms they care about.
The <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> core propagates equalities and disequalities to the theory solvers
using these &quot;marked&quot; terms. The root of the equivalence class
contains a list of representatives sorted by solver id. Note that many E-nodes
do not have any solver terms attached to them.</p><p>&quot;Solver terms&quot; are referenced as &quot;theory variables&quot; in the SMT literature.
The SMT solver Z3 uses a similar representation.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.SolverTerms.nil">nil : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></li><li class="constructor" id="Lean.Meta.Grind.SolverTerms.next">next<span class="decl_args">
<span class="fn">(<span class="fn">solverId</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rest</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.SolverTerms" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverTerms"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L479-L479">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverTerms</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms">Lean.Meta.Grind.instInhabitedSolverTerms</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms.default">Lean.Meta.Grind.instInhabitedSolverTerms.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverTerms.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L479-L479">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverTerms</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverTerms.default">Lean.Meta.Grind.instInhabitedSolverTerms.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms.nil">Lean.Meta.Grind.SolverTerms.nil</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedSolverTerms.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instReprSolverTerms.repr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L479-L479">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprSolverTerms.repr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprSolverTerms</span>.<span class="name">repr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a> → <span class="fn"><a href="../../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../../.././Init/Data/Format/Basic.html#Std.Format">Format</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instReprSolverTerms.repr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instReprSolverTerms"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L479-L479">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprSolverTerms</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprSolverTerms">Lean.Meta.Grind.instReprSolverTerms</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprSolverTerms.repr">Lean.Meta.Grind.instReprSolverTerms.repr</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENode"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L481-L533">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Stores information for a node in the E-graph.
Each internalized expression <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has an <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></code> associated with it.</p><ul class="structure_fields" id="Lean.Meta.Grind.ENode.mk"><li id="Lean.Meta.Grind.ENode.self" class="structure_field"><div class="structure_field_info">self : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p>Node represented by this ENode.</p></div></li><li id="Lean.Meta.Grind.ENode.next" class="structure_field"><div class="structure_field_info">next : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p>Next element in the equivalence class.</p></div></li><li id="Lean.Meta.Grind.ENode.root" class="structure_field"><div class="structure_field_info">root : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p>Root (aka canonical representative) of the equivalence class</p></div></li><li id="Lean.Meta.Grind.ENode.congr" class="structure_field"><div class="structure_field_info">congr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Init/Prelude.html#congr">congr</a></code> is the term <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code> is congruent to.
We say <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code> is the congruence class root if <code>isSameExpr <a href="../../../.././Init/Prelude.html#congr">congr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code>.
This field is initialized to <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></code> even if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is not an application.</p></div></li><li id="Lean.Meta.Grind.ENode.target?" class="structure_field"><div class="structure_field_info">target? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>When <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> was added to this equivalence class because of an equality <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.InjectiveInfo.h">h</a> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a> = target</code>,
then we store <code>target</code> here, and <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.InjectiveInfo.h">h</a></code> at <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.proof?">proof?</a></code>.</p></div></li><li id="Lean.Meta.Grind.ENode.proof?" class="structure_field"><div class="structure_field_info">proof? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.ENode.flipped" class="structure_field"><div class="structure_field_info">flipped : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Proof has been flipped.</p></div></li><li id="Lean.Meta.Grind.ENode.size" class="structure_field"><div class="structure_field_info">size : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of elements in the equivalence class, this field is meaningless if node is not the root.</p></div></li><li id="Lean.Meta.Grind.ENode.interpreted" class="structure_field"><div class="structure_field_info">interpreted : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.interpreted">interpreted</a> := true</code> if node should be viewed as an abstract value.</p></div></li><li id="Lean.Meta.Grind.ENode.ctor" class="structure_field"><div class="structure_field_info">ctor : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.ctor">ctor</a> := true</code> if the head symbol is a constructor application.</p></div></li><li id="Lean.Meta.Grind.ENode.hasLambdas" class="structure_field"><div class="structure_field_info">hasLambdas : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.hasLambdas">hasLambdas</a> := true</code> if the equivalence class contains lambda expressions.</p></div></li><li id="Lean.Meta.Grind.ENode.heqProofs" class="structure_field"><div class="structure_field_info">heqProofs : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.heqProofs">heqProofs</a> := true</code>, then some proofs in the equivalence class are based
on heterogeneous equality.</p></div></li><li id="Lean.Meta.Grind.ENode.idx" class="structure_field"><div class="structure_field_info">idx : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Unique index used for pretty printing and debugging purposes.</p></div></li><li id="Lean.Meta.Grind.ENode.generation" class="structure_field"><div class="structure_field_info">generation : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>The generation in which this enode was created.</p></div></li><li id="Lean.Meta.Grind.ENode.mt" class="structure_field"><div class="structure_field_info">mt : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Modification time</p></div></li><li id="Lean.Meta.Grind.ENode.sTerms" class="structure_field"><div class="structure_field_info">sTerms : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a></div><div class="structure_field_doc"><p>Solver terms attached to this E-node.</p></div></li><li id="Lean.Meta.Grind.ENode.funCC" class="structure_field"><div class="structure_field_info">funCC : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.funCC">funCC</a> := true</code>, then the expression associated with this entry is an application, and
function congruence closure is enabled for it.
See <code>Grind.Config.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.funCC">funCC</a></code> for additional details.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.ENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedENode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L533-L533">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENode">Lean.Meta.Grind.instInhabitedENode</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENode.default">Lean.Meta.Grind.instInhabitedENode.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedENode.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L533-L533">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENode.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENode</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedENode.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instReprENode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L533-L533">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode">Lean.Meta.Grind.instReprENode</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode.repr">Lean.Meta.Grind.instReprENode.repr</a> <a href="../../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instReprENode.repr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L533-L533">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instReprENode.repr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instReprENode</span>.<span class="name">repr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Init/Prelude.html#Nat">Nat</a> → <a href="../../../.././Init/Data/Format/Basic.html#Std.Format">Format</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instReprENode.repr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENode.isRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L535-L536">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isRoot">isRoot</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></span> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ENode.isRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENode.isCongrRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L538-L539">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENode</span>.<span class="name">isCongrRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isCongrRoot">isCongrRoot</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.self">self</a></span> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.congr">congr</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ENode.isCongrRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.NewFact"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L541-L544">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewFact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>New equalities and facts to be processed.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.NewFact.eq">eq<span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">isHEq</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a></li><li class="constructor" id="Lean.Meta.Grind.NewFact.fact">fact<span class="decl_args">
<span class="fn">(<span class="fn">prop </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.NewFact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.NewFact.toExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L546-L548">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.toExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewFact</span>.<span class="name">toExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a> → <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.eq">Lean.Meta.Grind.NewFact.eq</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span> <span class="fn">isHEq</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.toExpr">toExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/AppBuilder.html#Lean.Meta.mkEq">Lean.Meta.mkEq</a> <span class="fn">lhs</span> <span class="fn">rhs</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.fact">Lean.Meta.Grind.NewFact.fact</a> <span class="fn">p</span> <span class="fn">proof</span> <span class="fn">generation</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.toExpr">toExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">p</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.NewFact.toExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ENodeMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L551-L552">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ENodeMap</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">Lean.Meta.Grind.ENodeMap</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">Lean.PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">Lean.Meta.Grind.ExprPtr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">Lean.Meta.Grind.ENode</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ENodeMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedENodeMap"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L553-L554">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENodeMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedENodeMap</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENodeMap">Lean.Meta.Grind.instInhabitedENodeMap</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedENodeMap._private_1">Lean.Meta.Grind.instInhabitedENodeMap._private_1</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CongrKey"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L556-L561">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrKey</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">enodes</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Key for the congruence table.
We need access to the <code>enodes</code> to be able to retrieve the equivalence class roots.</p><ul class="structure_fields" id="Lean.Meta.Grind.CongrKey.mk"><li id="Lean.Meta.Grind.CongrKey.e" class="structure_field"><div class="structure_field_info">e : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CongrKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableCongrKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L649-L650">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCongrKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">enodeMap</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">CongrKey</a> <span class="fn">enodeMap</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrKey">Lean.Meta.Grind.instHashableCongrKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <span class="fn">fun (<span class="fn">k</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">Lean.Meta.Grind.CongrKey</a> <span class="fn">enodeMap</span></span>) =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCongrKey._private_1">Lean.Meta.Grind.instHashableCongrKey._private_1</a> <span class="fn">k</span></span></span> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqCongrKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L652-L653">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCongrKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">enodeMap</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">CongrKey</a> <span class="fn">enodeMap</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrKey">Lean.Meta.Grind.instBEqCongrKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <span class="fn">fun (<span class="fn">k1</span> <span class="fn">k2</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">Lean.Meta.Grind.CongrKey</a> <span class="fn">enodeMap</span></span>) =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCongrKey._private_1">Lean.Meta.Grind.instBEqCongrKey._private_1</a> <span class="fn">k1</span> <span class="fn">k2</span></span></span> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CongrTable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L655-L655">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTable"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CongrTable</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">enodeMap</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTable">Lean.Meta.Grind.CongrTable</a> <span class="fn">enodeMap</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">Lean.PHashSet</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey">Lean.Meta.Grind.CongrKey</a> <span class="fn">enodeMap</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.CongrTable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ParentSet"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L678-L680">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.ParentSet.mk"><li id="Lean.Meta.Grind.ParentSet.parents" class="structure_field"><div class="structure_field_info">parents : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.ParentSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedParentSet.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L680-L680">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedParentSet.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedParentSet</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedParentSet.default">Lean.Meta.Grind.instInhabitedParentSet.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.mk">{</a> <span class="fn">parents</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedParentSet.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedParentSet"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L680-L680">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedParentSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedParentSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedParentSet">Lean.Meta.Grind.instInhabitedParentSet</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedParentSet.default">Lean.Meta.Grind.instInhabitedParentSet.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ParentSet.insert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L682-L683">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.insert"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span>.<span class="name">insert</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ps</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">ps</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.insert">insert</a></span> <span class="fn">p</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.mk">{</a> <span class="fn">parents</span> := <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.insert">List.insert</a> <span class="fn">p</span> <span class="fn"><span class="fn">ps</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.parents">parents</a></span></span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ParentSet.insert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ParentSet.isEmpty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L685-L686">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.isEmpty"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span>.<span class="name">isEmpty</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ps</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">ps</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">ps</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.parents">parents</a></span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ParentSet.isEmpty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ParentSet.elems"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L688-L689">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.elems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentSet</span>.<span class="name">elems</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">ps</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">ps</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.elems">elems</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">ps</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.parents">parents</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ParentSet.elems" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ParentMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L691-L691">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentMap"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ParentMap</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentMap">Lean.Meta.Grind.ParentMap</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">Lean.PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">Lean.Meta.Grind.ExprPtr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">Lean.Meta.Grind.ParentSet</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ParentMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PreInstance"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L693-L713">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>The E-matching module instantiates theorems using the <code>EMatchTheorem <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> and a (partial) assignment.
We want to avoid instantiating the same theorem with the same assignment more than once.
Therefore, we store the (pre-)instance information in set.
Recall that the proofs of activated theorems have been hash-consed.
The assignment contains internalized expressions, which have also been hash-consed.</p><p><strong>Note</strong>: We used to use pointer equality to implement <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet">PreInstanceSet</a></code>. However,
this low-level trick was incorrect in interactive mode because we add new
<code>EMatchTheorem</code> objects using <code>instantiate [...]</code>. For example, suppose we write</p><pre><code>instantiate [thm_1]; instantiate [thm_1]
</code></pre><p>The <code>EMatchTheorem</code> object <code>thm_1</code> is created twice. Using pointer equality will
miss instances created using the two different objects. Recall we do not use
hash-consing on proof objects. If we hash-cons the proof objects, it would be ok
to use pointer equality.</p><ul class="structure_fields" id="Lean.Meta.Grind.PreInstance.mk"><li id="Lean.Meta.Grind.PreInstance.proof" class="structure_field"><div class="structure_field_info">proof : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.PreInstance.assignment" class="structure_field"><div class="structure_field_info">assignment : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.PreInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashablePreInstance"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L715-L720">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashablePreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashablePreInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance">PreInstance</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqPreInstance"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L722-L728">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqPreInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqPreInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance">PreInstance</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PreInstanceSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L730-L730">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PreInstanceSet</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet">Lean.Meta.Grind.PreInstanceSet</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">Lean.PHashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance">Lean.Meta.Grind.PreInstance</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.PreInstanceSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.NewRawFact"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L732-L739">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">NewRawFact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>New raw fact to be preprocessed, and then asserted.</p><ul class="structure_fields" id="Lean.Meta.Grind.NewRawFact.mk"><li id="Lean.Meta.Grind.NewRawFact.proof" class="structure_field"><div class="structure_field_info">proof : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.NewRawFact.prop" class="structure_field"><div class="structure_field_info">prop : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.NewRawFact.generation" class="structure_field"><div class="structure_field_info">generation : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.NewRawFact.splitSource" class="structure_field"><div class="structure_field_info">splitSource : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Context.splitSource">splitSource</a></code> to use when internalizing this fact.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.NewRawFact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedNewRawFact.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L739-L739">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact">NewRawFact</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact.default">Lean.Meta.Grind.instInhabitedNewRawFact.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact.mk">{</a> <span class="fn">proof</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">prop</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">generation</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">splitSource</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedNewRawFact.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedNewRawFact"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L739-L739">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedNewRawFact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact">NewRawFact</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact">Lean.Meta.Grind.instInhabitedNewRawFact</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedNewRawFact.default">Lean.Meta.Grind.instInhabitedNewRawFact.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CanonArgKey"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L741-L745">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CanonArgKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.CanonArgKey.mk"><li id="Lean.Meta.Grind.CanonArgKey.f" class="structure_field"><div class="structure_field_info">f : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.CanonArgKey.i" class="structure_field"><div class="structure_field_info">i : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.CanonArgKey.arg" class="structure_field"><div class="structure_field_info">arg : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CanonArgKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqCanonArgKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L745-L745">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCanonArgKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCanonArgKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey">CanonArgKey</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCanonArgKey">Lean.Meta.Grind.instBEqCanonArgKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCanonArgKey.beq">Lean.Meta.Grind.instBEqCanonArgKey.beq</a> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqCanonArgKey.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L745-L745">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCanonArgKey.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqCanonArgKey</span>.<span class="name">beq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey">CanonArgKey</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey">CanonArgKey</a> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCanonArgKey.beq">Lean.Meta.Grind.instBEqCanonArgKey.beq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.mk">{</a> <span class="fn">f</span> := <span class="fn">a</span>, <span class="fn">i</span> := <span class="fn">a_1</span>, <span class="fn">arg</span> := <span class="fn">a_2</span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.mk">}</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.mk">{</a> <span class="fn">f</span> := <span class="fn">b</span>, <span class="fn">i</span> := <span class="fn">b_1</span>, <span class="fn">arg</span> := <span class="fn">b_2</span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.mk">}</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> (<span class="fn">a_1</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b_1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">a_2</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b_2</span>))</li><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqCanonArgKey.beq">Lean.Meta.Grind.instBEqCanonArgKey.beq</a> <span class="fn">x✝¹</span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instBEqCanonArgKey.beq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableCanonArgKey.hash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L745-L745">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCanonArgKey.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCanonArgKey</span>.<span class="name">hash</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey">CanonArgKey</a> → <a href="../../../.././Init/Prelude.html#UInt64">UInt64</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCanonArgKey.hash">Lean.Meta.Grind.instHashableCanonArgKey.hash</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.mk">{</a> <span class="fn">f</span> := <span class="fn">a</span>, <span class="fn">i</span> := <span class="fn">a_1</span>, <span class="fn">arg</span> := <span class="fn">a_2</span> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.mk">}</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#mixHash">mixHash</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#mixHash">mixHash</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#mixHash">mixHash</a> <span class="fn">0</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">a</span>)</span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">a_1</span>)</span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">a_2</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instHashableCanonArgKey.hash" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableCanonArgKey"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L745-L745">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCanonArgKey"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableCanonArgKey</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey">CanonArgKey</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCanonArgKey">Lean.Meta.Grind.instHashableCanonArgKey</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableCanonArgKey.hash">Lean.Meta.Grind.instHashableCanonArgKey.hash</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Canon.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L747-L753">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Canonicalizer state. See <code>Canon.lean</code> for additional details.</p><ul class="structure_fields" id="Lean.Meta.Grind.Canon.State.mk"><li id="Lean.Meta.Grind.Canon.State.argMap" class="structure_field"><div class="structure_field_info">argMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>) <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>))</span></span></div></li><li id="Lean.Meta.Grind.Canon.State.canon" class="structure_field"><div class="structure_field_info">canon : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.Canon.State.proofCanon" class="structure_field"><div class="structure_field_info">proofCanon : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.Canon.State.canonArg" class="structure_field"><div class="structure_field_info">canonArg : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey">CanonArgKey</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Canon.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Canon.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L753-L753">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState.default">Lean.Meta.Grind.Canon.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State.mk">{</a> <span class="fn">argMap</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">canon</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">proofCanon</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">canonArg</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Canon.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Canon.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L753-L753">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Canon</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState">Lean.Meta.Grind.Canon.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.instInhabitedState.default">Lean.Meta.Grind.Canon.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.CaseTrace"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L755-L761">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">CaseTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Trace information for a case split.</p><ul class="structure_fields" id="Lean.Meta.Grind.CaseTrace.mk"><li id="Lean.Meta.Grind.CaseTrace.expr" class="structure_field"><div class="structure_field_info">expr : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.CaseTrace.i" class="structure_field"><div class="structure_field_info">i : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.CaseTrace.num" class="structure_field"><div class="structure_field_info">num : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.CaseTrace.source" class="structure_field"><div class="structure_field_info">source : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.CaseTrace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCaseTrace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L761-L761">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace">CaseTrace</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace">Lean.Meta.Grind.instInhabitedCaseTrace</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace.default">Lean.Meta.Grind.instInhabitedCaseTrace.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedCaseTrace.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L761-L761">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedCaseTrace</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace">CaseTrace</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedCaseTrace.default">Lean.Meta.Grind.instInhabitedCaseTrace.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.mk">{</a> <span class="fn">expr</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">i</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">num</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">source</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedCaseTrace.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatch.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L763-L788">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>E-matching related fields for the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> goal.</p><ul class="structure_fields" id="Lean.Meta.Grind.EMatch.State.mk"><li id="Lean.Meta.Grind.EMatch.State.thmMap" class="structure_field"><div class="structure_field_info">thmMap : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorems">EMatchTheorems</a></div><div class="structure_field_doc"><p>Inactive global theorems. As we internalize terms, we activate theorems as we find their symbols.
Local theorem provided by users are added directly into <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.newThms">newThms</a></code>.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.gmt" class="structure_field"><div class="structure_field_info">gmt : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Goal modification time.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.thms" class="structure_field"><div class="structure_field_info">thms : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a></span></div><div class="structure_field_doc"><p>Active theorems that we have performed ematching at least once.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.newThms" class="structure_field"><div class="structure_field_info">newThms : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a></span></div><div class="structure_field_doc"><p>Active theorems that we have not performed any round of ematching yet.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.numInstances" class="structure_field"><div class="structure_field_info">numInstances : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of theorem instances generated so far.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.numDelayedInstances" class="structure_field"><div class="structure_field_info">numDelayedInstances : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of delayed theorem instances generated so far. We track them to decide whether E-match made progress or not.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.num" class="structure_field"><div class="structure_field_info">num : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of E-matching rounds performed in this goal since the last case-split.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.preInstances" class="structure_field"><div class="structure_field_info">preInstances : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstanceSet">PreInstanceSet</a></div><div class="structure_field_doc"><p>(pre-)instances found so far. It includes instances that failed to be instantiated.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.nextThmIdx" class="structure_field"><div class="structure_field_info">nextThmIdx : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Next local E-match theorem idx.</p></div></li><li id="Lean.Meta.Grind.EMatch.State.matchEqNames" class="structure_field"><div class="structure_field_info">matchEqNames : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div><div class="structure_field_doc"><p><code>match</code> auxiliary functions whose equations have already been created and activated.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.EMatch.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatch.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L788-L788">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.EMatch.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EMatch.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L788-L788">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EMatch</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.instInhabitedState">Lean.Meta.Grind.EMatch.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.instInhabitedState.default">Lean.Meta.Grind.EMatch.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L790-L804">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case-split information.</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.SplitInfo.default">default<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">source</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a><div class="inductive_ctor_doc"><p>Term <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> may be an inductive predicate, <code>match</code>-expression, <code>if</code>-expression, implication, etc.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitInfo.imp">imp<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.isForall">isForall</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">source</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a><div class="inductive_ctor_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is an implication and we want to split on its antecedent.</p></div></li><li class="constructor" id="Lean.Meta.Grind.SplitInfo.arg">arg<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">i</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">eq</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">source</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a><div class="inductive_ctor_doc"><p>Given applications <code>a</code> and <code>b</code>, case-split on whether the corresponding
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.i">i</a></code>-th arguments are equal or not. The split is only performed if all other
arguments are already known to be equal or are also tagged as split candidates.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSplitInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L804-L804">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo">Lean.Meta.Grind.instInhabitedSplitInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo.default">Lean.Meta.Grind.instInhabitedSplitInfo.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSplitInfo.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L804-L804">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSplitInfo</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSplitInfo.default">Lean.Meta.Grind.instInhabitedSplitInfo.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedSplitInfo.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.hash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L806-L809">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">hash</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Init/Prelude.html#UInt64">UInt64</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash">hash</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">e</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash">hash</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">e</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">i</span> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash">hash</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn">e</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.hash" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instHashableSplitInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L811-L812">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instHashableSplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Hashable">Hashable</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instHashableSplitInfo">Lean.Meta.Grind.instHashableSplitInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">{</a> <span class="fn">hash</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.hash">Lean.Meta.Grind.SplitInfo.hash</a> <a href="../../../.././Init/Prelude.html#Hashable.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L814-L818">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">beq</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₁</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₂</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">e₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">e₂</span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₁</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₂</span> <span class="fn">h_1</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">e₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">e₂</span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a₁</span> <span class="fn">b₁</span> <span class="fn">i₁</span> <span class="fn">eq₁</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a₂</span> <span class="fn">b₂</span> <span class="fn">i₂</span> <span class="fn">eq₂</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   (<span class="fn">a₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a₂</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">b₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b₂</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">i₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">i₂</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn">eq₁</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">eq₂</span>)</li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">beq</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.beq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instBEqSplitInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L820-L821">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqSplitInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instBEqSplitInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instBEqSplitInfo">Lean.Meta.Grind.instBEqSplitInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.beq">Lean.Meta.Grind.SplitInfo.beq</a> <a href="../../../.././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.getExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L823-L826">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">getExpr</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr">getExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr">getExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.forallDomain">forallDomain</a></span> <span class="fn">h</span></span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">i</span> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.getExpr">getExpr</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.getExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.source"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L828-L831">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.source"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">source</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.source">source</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">source</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.source">source</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">source</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">i</span> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.source">source</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">source</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.source" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitInfo.lt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L833-L839">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitInfo</span>.<span class="name">lt</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₁</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e₂</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.lt">lt</a></span> <span class="fn">e₂</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₁</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e₂</span> <span class="fn">h_1</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.lt">lt</a></span> <span class="fn">e₂</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">i</span> <span class="fn">e₁</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">Lean.Meta.Grind.SplitInfo.arg</a> <span class="fn">a_1</span> <span class="fn">b_1</span> <span class="fn">i_1</span> <span class="fn">e₂</span> <span class="fn">source_1</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Lean/Expr.html#Lean.Expr.lt">lt</a></span> <span class="fn">e₂</span></span></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.default">Lean.Meta.Grind.SplitInfo.default</a> <span class="fn">e</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.imp">Lean.Meta.Grind.SplitInfo.imp</a> <span class="fn">e</span> <span class="fn">h</span> <span class="fn">source</span>)</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></li><li class="equation"><span class="fn"><span class="fn"><span class="fn">x✝¹</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.lt">lt</a></span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SplitInfo.lt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SplitArg"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L841-L845">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SplitArg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Argument <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.arg">arg</a> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg.type">type</a></code> of an application <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg.app">app</a></code> in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></code>.</p><ul class="structure_fields" id="Lean.Meta.Grind.SplitArg.mk"><li id="Lean.Meta.Grind.SplitArg.arg" class="structure_field"><div class="structure_field_info">arg : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.SplitArg.type" class="structure_field"><div class="structure_field_info">type : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.SplitArg.app" class="structure_field"><div class="structure_field_info">app : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SplitArg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Split.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L847-L882">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Case splitting related fields for the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> goal.</p><ul class="structure_fields" id="Lean.Meta.Grind.Split.State.mk"><li id="Lean.Meta.Grind.Split.State.num" class="structure_field"><div class="structure_field_info">num : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Number of splits performed to get to this goal.</p></div></li><li id="Lean.Meta.Grind.Split.State.casesTypes" class="structure_field"><div class="structure_field_info">casesTypes : <a href="../../../.././Lean/Meta/Tactic/Grind/Cases.html#Lean.Meta.Grind.CasesTypes">CasesTypes</a></div><div class="structure_field_doc"><p>Inductive datatypes marked for case-splitting</p></div></li><li id="Lean.Meta.Grind.Split.State.candidates" class="structure_field"><div class="structure_field_info">candidates : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div><div class="structure_field_doc"><p>Case-split candidates.</p></div></li><li id="Lean.Meta.Grind.Split.State.added" class="structure_field"><div class="structure_field_info">added : <span class="fn"><a href="../../../.././Std/Data/HashSet/Basic.html#Std.HashSet">Std.HashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div><div class="structure_field_doc"><p>Case-splits that have been inserted at <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.candidates">candidates</a></code> at some point.</p></div></li><li id="Lean.Meta.Grind.Split.State.resolved" class="structure_field"><div class="structure_field_info">resolved : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a></span></div><div class="structure_field_doc"><p>Case-splits that have already been performed, or that do not have to be performed anymore.</p></div></li><li id="Lean.Meta.Grind.Split.State.trace" class="structure_field"><div class="structure_field_info">trace : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CaseTrace">CaseTrace</a></span></div><div class="structure_field_doc"><p>Sequence of cases steps that generated this goal. We only use this information for diagnostics.
Remark: <code>casesTrace.length ≥ numSplits</code> because we don't increase the counter for <code>cases</code>
applications that generated only 1 subgoal.</p></div></li><li id="Lean.Meta.Grind.Split.State.lookaheads" class="structure_field"><div class="structure_field_info">lookaheads : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a></span></div><div class="structure_field_doc"><p>Lookahead &quot;case-splits&quot;.</p></div></li><li id="Lean.Meta.Grind.Split.State.argPosMap" class="structure_field"><div class="structure_field_info">argPosMap : <span class="fn"><a href="../../../.././Std/Data/HashMap/Basic.html#Std.HashMap">Std.HashMap</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>) <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span></div><div class="structure_field_doc"><p>A mapping <code>(a, b) ↦ is</code> s.t. for each <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo.arg">SplitInfo.arg</a> a b <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.i">i</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact.eq">eq</a></code>
in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.candidates">candidates</a></code> or <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.lookaheads">lookaheads</a></code> we have <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.i">i</a> ∈ is</code>.
We use this information to decide whether the split/lookahead is &quot;ready&quot;
to be tried or not.</p></div></li><li id="Lean.Meta.Grind.Split.State.argsAt" class="structure_field"><div class="structure_field_info">argsAt : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>) <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitArg">SplitArg</a>)</span></span></div><div class="structure_field_doc"><p>Mapping from pairs <code>(f, i)</code> to a list of arguments.
Each argument occurs as the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CanonArgKey.i">i</a></code>-th of an <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code>-application.
We use this information to add splits/lookaheads for
triggering extensionality theorems and model-based theory combination.
See <code>addSplitCandidatesForExt</code>.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Split.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Split.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L882-L882">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.instInhabitedState">Lean.Meta.Grind.Split.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.instInhabitedState.default">Lean.Meta.Grind.Split.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Split.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L882-L882">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Split</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Split.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Clean.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L884-L888">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Clean name generator.</p><ul class="structure_fields" id="Lean.Meta.Grind.Clean.State.mk"><li id="Lean.Meta.Grind.Clean.State.used" class="structure_field"><div class="structure_field_info">used : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a></span></div></li><li id="Lean.Meta.Grind.Clean.State.next" class="structure_field"><div class="structure_field_info">next : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Init/Prelude.html#Lean.Name">Name</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Clean.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Clean.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L888-L888">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState">Lean.Meta.Grind.Clean.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState.default">Lean.Meta.Grind.Clean.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Clean.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L888-L888">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Clean</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.instInhabitedState.default">Lean.Meta.Grind.Clean.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State.mk">{</a> <span class="fn">used</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">next</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Clean.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.UnitLike.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L890-L896">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Cache for <code><a href="../../../.././Init/Prelude.html#Unit">Unit</a></code>-like types. It maps the type to its element.
We say a type is <code><a href="../../../.././Init/Prelude.html#Unit">Unit</a></code>-like if it is a subsingleton and is inhabited.</p><ul class="structure_fields" id="Lean.Meta.Grind.UnitLike.State.mk"><li id="Lean.Meta.Grind.UnitLike.State.map" class="structure_field"><div class="structure_field_info">map : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.UnitLike.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.UnitLike.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L896-L896">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState.default">Lean.Meta.Grind.UnitLike.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State.mk">{</a> <span class="fn">map</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.UnitLike.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.UnitLike.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L896-L896">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">UnitLike</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState">Lean.Meta.Grind.UnitLike.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.UnitLike.instInhabitedState.default">Lean.Meta.Grind.UnitLike.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.InjectiveInfo"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L898-L908">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.InjectiveInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">InjectiveInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.InjectiveInfo.mk"><li id="Lean.Meta.Grind.InjectiveInfo.us" class="structure_field"><div class="structure_field_info">us : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Level.html#Lean.Level">Level</a></span></div></li><li id="Lean.Meta.Grind.InjectiveInfo.α" class="structure_field"><div class="structure_field_info">α : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.InjectiveInfo.β" class="structure_field"><div class="structure_field_info">β : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.InjectiveInfo.h" class="structure_field"><div class="structure_field_info">h : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.InjectiveInfo.inv?" class="structure_field"><div class="structure_field_info">inv? : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> (<a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></div><div class="structure_field_doc"><p>Inverse function and a proof that <code>∀ a, inv (f a) = a</code>
<strong>Note</strong>: The following two fields are <code>none</code> if no <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code>-application has been found yet.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.InjectiveInfo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedInjectiveInfo.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L908-L908">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedInjectiveInfo.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedInjectiveInfo</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.InjectiveInfo">InjectiveInfo</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedInjectiveInfo.default">Lean.Meta.Grind.instInhabitedInjectiveInfo.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.InjectiveInfo.mk">{</a> <span class="fn">us</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">α</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">β</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">h</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">inv?</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.InjectiveInfo.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedInjectiveInfo.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedInjectiveInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L908-L908">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedInjectiveInfo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedInjectiveInfo</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.InjectiveInfo">InjectiveInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedInjectiveInfo">Lean.Meta.Grind.instInhabitedInjectiveInfo</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedInjectiveInfo.default">Lean.Meta.Grind.instInhabitedInjectiveInfo.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Injective.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L910-L914">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.State"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Injective</span>.<span class="name">State</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>State for injective theorem support.</p><ul class="structure_fields" id="Lean.Meta.Grind.Injective.State.mk"><li id="Lean.Meta.Grind.Injective.State.thms" class="structure_field"><div class="structure_field_info">thms : <a href="../../../.././Lean/Meta/Tactic/Grind/Injective.html#Lean.Meta.Grind.InjectiveTheorems">InjectiveTheorems</a></div></li><li id="Lean.Meta.Grind.Injective.State.fns" class="structure_field"><div class="structure_field_info">fns : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.InjectiveInfo">InjectiveInfo</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Injective.State" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Injective.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L914-L914">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.instInhabitedState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Injective</span>.<span class="name">instInhabitedState</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.State">State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.instInhabitedState">Lean.Meta.Grind.Injective.instInhabitedState</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.instInhabitedState.default">Lean.Meta.Grind.Injective.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Injective.instInhabitedState.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L914-L914">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.instInhabitedState.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Injective</span>.<span class="name">instInhabitedState</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.State">State</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.instInhabitedState.default">Lean.Meta.Grind.Injective.instInhabitedState.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.State.mk">{</a> <span class="fn">thms</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">fns</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.State.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Injective.instInhabitedState.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.TheoremGuard"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L916-L926">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">TheoremGuard</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Users can attach guards to <code>grind_pattern</code>s. A guard ensures that a theorem is instantiated
only when the guard expression becomes provably true.</p><p>If <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard.check">check</a></code> is <code>true</code>, then <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> attempts to prove <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> by asserting its negation and
checking whether this leads to a contradiction.</p><ul class="structure_fields" id="Lean.Meta.Grind.TheoremGuard.mk"><li id="Lean.Meta.Grind.TheoremGuard.e" class="structure_field"><div class="structure_field_info">e : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.TheoremGuard.check" class="structure_field"><div class="structure_field_info">check : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.TheoremGuard" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedTheoremGuard.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L926-L926">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTheoremGuard.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTheoremGuard</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard">TheoremGuard</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTheoremGuard.default">Lean.Meta.Grind.instInhabitedTheoremGuard.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard.mk">{</a> <span class="fn">e</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">check</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedTheoremGuard.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedTheoremGuard"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L926-L926">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTheoremGuard"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedTheoremGuard</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard">TheoremGuard</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTheoremGuard">Lean.Meta.Grind.instInhabitedTheoremGuard</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedTheoremGuard.default">Lean.Meta.Grind.instInhabitedTheoremGuard.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.DelayedTheoremInstance"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L928-L938">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">DelayedTheoremInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>A delayed theorem instantiation is an instantiation that includes one or more guards.
See <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard">TheoremGuard</a></code>.</p><ul class="structure_fields" id="Lean.Meta.Grind.DelayedTheoremInstance.mk"><li id="Lean.Meta.Grind.DelayedTheoremInstance.thm" class="structure_field"><div class="structure_field_info">thm : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a></div></li><li id="Lean.Meta.Grind.DelayedTheoremInstance.proof" class="structure_field"><div class="structure_field_info">proof : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.DelayedTheoremInstance.prop" class="structure_field"><div class="structure_field_info">prop : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></div></li><li id="Lean.Meta.Grind.DelayedTheoremInstance.generation" class="structure_field"><div class="structure_field_info">generation : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.DelayedTheoremInstance.guards" class="structure_field"><div class="structure_field_info">guards : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard">TheoremGuard</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.DelayedTheoremInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedDelayedTheoremInstance.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L938-L938">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedDelayedTheoremInstance.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedDelayedTheoremInstance</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance">DelayedTheoremInstance</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedDelayedTheoremInstance.default">Lean.Meta.Grind.instInhabitedDelayedTheoremInstance.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance.mk">{</a> <span class="fn">thm</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">proof</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">prop</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">generation</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">guards</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedDelayedTheoremInstance.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedDelayedTheoremInstance"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L938-L938">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedDelayedTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedDelayedTheoremInstance</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance">DelayedTheoremInstance</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedDelayedTheoremInstance">Lean.Meta.Grind.instInhabitedDelayedTheoremInstance</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedDelayedTheoremInstance.default">Lean.Meta.Grind.instInhabitedDelayedTheoremInstance.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L940-L986">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>The <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> goal.</p><ul class="structure_fields" id="Lean.Meta.Grind.Goal.mk"><li id="Lean.Meta.Grind.Goal.mvarId" class="structure_field"><div class="structure_field_info">mvarId : <a href="../../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></div></li><li id="Lean.Meta.Grind.Goal.canon" class="structure_field"><div class="structure_field_info">canon : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Canon.State">Canon.State</a></div></li><li id="Lean.Meta.Grind.Goal.enodeMap" class="structure_field"><div class="structure_field_info">enodeMap : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENodeMap">ENodeMap</a></div></li><li id="Lean.Meta.Grind.Goal.exprs" class="structure_field"><div class="structure_field_info">exprs : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></li><li id="Lean.Meta.Grind.Goal.parents" class="structure_field"><div class="structure_field_info">parents : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentMap">ParentMap</a></div></li><li id="Lean.Meta.Grind.Goal.congrTable" class="structure_field"><div class="structure_field_info">congrTable : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTable">CongrTable</a> <span class="fn"><span class="fn">self</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span></span></div></li><li id="Lean.Meta.Grind.Goal.appMap" class="structure_field"><div class="structure_field_info">appMap : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/HeadIndex.html#Lean.HeadIndex">HeadIndex</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div><div class="structure_field_doc"><p>A mapping from each function application index (<code>HeadIndex</code>) to a list of applications with that index.
Recall that the <code>HeadIndex</code> for a constant is its constant name, and for a free variable,
it is its unique id.</p></div></li><li id="Lean.Meta.Grind.Goal.indicesFound" class="structure_field"><div class="structure_field_info">indicesFound : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PHashSet">PHashSet</a> <a href="../../../.././Lean/HeadIndex.html#Lean.HeadIndex">HeadIndex</a></span></div><div class="structure_field_doc"><p>All constants (<em>not</em> in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.appMap">appMap</a></code>) that have been internalized, <em>and</em>
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.appMap">appMap</a></code>'s domain. We use this collection during theorem activation.</p></div></li><li id="Lean.Meta.Grind.Goal.newFacts" class="structure_field"><div class="structure_field_info">newFacts : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewFact">NewFact</a></span></div><div class="structure_field_doc"><p>Equations and propositions to be processed.</p></div></li><li id="Lean.Meta.Grind.Goal.inconsistent" class="structure_field"><div class="structure_field_info">inconsistent : <a href="../../../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.inconsistent">inconsistent</a> := true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></code>s for <code><a href="../../../.././Init/Prelude.html#True">True</a></code> and <code><a href="../../../.././Init/Prelude.html#False">False</a></code> are in the same equivalence class.</p></div></li><li id="Lean.Meta.Grind.Goal.nextIdx" class="structure_field"><div class="structure_field_info">nextIdx : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div><div class="structure_field_doc"><p>Next unique index for creating ENodes</p></div></li><li id="Lean.Meta.Grind.Goal.newRawFacts" class="structure_field"><div class="structure_field_info">newRawFacts : <span class="fn"><a href="../../../.././Init/Data/Queue.html#Std.Queue">Std.Queue</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact">NewRawFact</a></span></div><div class="structure_field_doc"><p>new facts to be preprocessed and then asserted.</p></div></li><li id="Lean.Meta.Grind.Goal.facts" class="structure_field"><div class="structure_field_info">facts : <span class="fn"><a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div><div class="structure_field_doc"><p>Asserted facts</p></div></li><li id="Lean.Meta.Grind.Goal.extThms" class="structure_field"><div class="structure_field_info">extThms : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Ext.html#Lean.Meta.Ext.ExtTheorem">Ext.ExtTheorem</a>)</span></span></div><div class="structure_field_doc"><p>Cached extensionality theorems for types.</p></div></li><li id="Lean.Meta.Grind.Goal.ematch" class="structure_field"><div class="structure_field_info">ematch : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State">EMatch.State</a></div><div class="structure_field_doc"><p>State of the E-matching module.</p></div></li><li id="Lean.Meta.Grind.Goal.inj" class="structure_field"><div class="structure_field_info">inj : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Injective.State">Injective.State</a></div><div class="structure_field_doc"><p>State of the injective function procedure.</p></div></li><li id="Lean.Meta.Grind.Goal.split" class="structure_field"><div class="structure_field_info">split : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State">Split.State</a></div><div class="structure_field_doc"><p>State of the case-splitting module.</p></div></li><li id="Lean.Meta.Grind.Goal.clean" class="structure_field"><div class="structure_field_info">clean : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Clean.State">Clean.State</a></div><div class="structure_field_doc"><p>State of the clean name generator.</p></div></li><li id="Lean.Meta.Grind.Goal.sstates" class="structure_field"><div class="structure_field_info">sstates : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState">SolverExtensionState</a></span></div><div class="structure_field_doc"><p>Solver states.</p></div></li><li id="Lean.Meta.Grind.Goal.delayedThmInsts" class="structure_field"><div class="structure_field_info">delayedThmInsts : <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PHashMap">PHashMap</a> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr">ExprPtr</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance">DelayedTheoremInstance</a>)</span></span></div><div class="structure_field_doc"><p>Delayed instantiations is a mapping from guards to theorems that are waiting them
to become <code><a href="../../../.././Init/Prelude.html#True">True</a></code>.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Goal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedGoal.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L986-L986">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoal.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedGoal.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedGoal"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L986-L986">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoal</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoal">Lean.Meta.Grind.instInhabitedGoal</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoal.default">Lean.Meta.Grind.instInhabitedGoal.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.hasSameRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L988-L989">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.hasSameRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">hasSameRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.hasSameRoot">hasSameRoot</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.hasSameRoot">Lean.Meta.Grind.hasSameRoot✝</a> <span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.hasSameRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.isCongruent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L991-L992">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.isCongruent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">isCongruent</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.isCongruent">isCongruent</a></span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.isCongruent">Lean.Meta.Grind.isCongruent✝</a> <span class="fn"><span class="fn">g</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.isCongruent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.admit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L994-L995">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.admit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">admit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.admit">admit</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Tactic/Util.html#Lean.MVarId.admit">admit</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.admit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L997-L997">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Control/StateRef.html#StateRefT'">StateRefT'</a> <a href="../../../.././Init/System/IO.html#IO.RealWorld">IO.RealWorld</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Lean.Meta.Grind.Goal</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM.runCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L999-L1000">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.runCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">runCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.runCore">Lean.Meta.Grind.GoalM.runCore</a> <span class="fn">goal</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Control/StateRef.html#StateRefT'.run">StateRefT'.run</a> <span class="fn">x</span> <span class="fn">goal</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM.runCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1002-L1003">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run">Lean.Meta.Grind.GoalM.run</a> <span class="fn">goal</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Basic.html#Lean.MVarId.withContext">withContext</a></span> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.runCore">Lean.Meta.Grind.GoalM.runCore</a> <span class="fn">goal</span> <span class="fn">x</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.GoalM.run'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1005-L1006">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">GoalM</span>.<span class="name">run'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM.run'">Lean.Meta.Grind.GoalM.run'</a> <span class="fn">goal</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Basic.html#Lean.MVarId.withContext">withContext</a></span> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn">x</span> *&gt; <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>)</span>.<a href="../../../.././Init/Control/StateRef.html#StateRefT'.run'">run'</a></span> <span class="fn">goal</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.GoalM.run'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.updateLastTag"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1008-L1013">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.updateLastTag"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">updateLastTag</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.updateLastTag" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.«doElemTrace_goal[_]__»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1019-L1025">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.«doElemTrace_goal[_]__»"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">«doElemTrace_goal[_]__»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Macro similar to <code>trace[...]</code>, but it includes the trace message <code>trace[grind] &quot;working on &lt;current goal&gt;&quot;</code>
if the tag has changed since the last trace message.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.«doElemTrace_goal[_]__»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markTheoremInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1027-L1036">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markTheoremInstance</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">assignment</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>A helper function used to mark a theorem instance found by the E-matching module.
It returns <code>true</code> if it is a new instance and <code>false</code> otherwise.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markTheoremInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addNewRawFact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1038-L1045">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addNewRawFact"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addNewRawFact</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">proof </span><span class="fn">prop</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">splitSource</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource">SplitSource</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Adds a new fact <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.NewRawFact.prop">prop</a></code> with proof <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to the queue for preprocessing and the assertion.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addNewRawFact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getNumTheoremInstances"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1047-L1049">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNumTheoremInstances"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNumTheoremInstances</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Returns the number of theorem instances generated so far.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNumTheoremInstances">Lean.Meta.Grind.getNumTheoremInstances</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.ematch">ematch</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.numInstances">numInstances</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getNumTheoremInstances" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.checkMaxInstancesExceeded"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1051-L1053">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxInstancesExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxInstancesExceeded</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the maximum number of instances has been reached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxInstancesExceeded">Lean.Meta.Grind.checkMaxInstancesExceeded</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.ematch">ematch</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.numInstances">numInstances</a></span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">__do_lift_1</span>.<a href="../../../.././Init/Grind/Config.html#Lean.Grind.Config.instances">instances</a></span>))</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.checkMaxInstancesExceeded" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.checkMaxCaseSplit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1055-L1057">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxCaseSplit</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the maximum number of case-splits has been reached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxCaseSplit">Lean.Meta.Grind.checkMaxCaseSplit</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.split">split</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.num">num</a></span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">__do_lift_1</span>.<a href="../../../.././Init/Grind/Config.html#Lean.Grind.Config.splits">splits</a></span>))</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.checkMaxCaseSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.checkMaxEmatchExceeded"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1059-L1061">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxEmatchExceeded"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">checkMaxEmatchExceeded</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the maximum number of E-matching rounds has been reached.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.checkMaxEmatchExceeded">Lean.Meta.Grind.checkMaxEmatchExceeded</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getConfig">Lean.Meta.Grind.getConfig</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.ematch">ematch</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EMatch.State.num">num</a></span> <a href="../../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn"><span class="fn">__do_lift_1</span>.<a href="../../../.././Init/Grind/Config.html#Lean.Grind.Config.ematch">ematch</a></span>))</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.checkMaxEmatchExceeded" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getENode?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1063-L1068">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns <code>some n</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been &quot;internalized&quot; into the
Otherwise, returns <code>none</code>s.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getENode?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getENode?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1070-L1072">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span></div></div><p>Returns <code>some n</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been &quot;internalized&quot; into the
Otherwise, returns <code>none</code>s.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getENode?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.throwNonInternalizedExpr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1074-L1075">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.throwNonInternalizedExpr"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">throwNonInternalizedExpr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.throwNonInternalizedExpr">Lean.Meta.Grind.throwNonInternalizedExpr</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Exception.html#Lean.throwError">Lean.throwError</a>
    (<span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;internal `grind` error, term has not been internalized&quot;</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a>       <span class="fn"><a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.indentExpr">Lean.indentExpr</a> <span class="fn">e</span>)</span></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.throwNonInternalizedExpr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1077-L1081">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns node associated with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. It assumes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a></span> with
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">n</span></span>
  | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.throwNonInternalizedExpr">Lean.Meta.Grind.throwNonInternalizedExpr</a> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1083-L1085">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns node associated with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>. It assumes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getGeneration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1087-L1091">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getGeneration</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getGeneration">getGeneration</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span> with
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.generation">generation</a></span>
  | <span class="fn">x</span> =&gt; <span class="fn">0</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getGeneration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getGeneration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1093-L1095">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getGeneration"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getGeneration</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Returns the generation of the given term. Is assumes it has been internalized</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getGeneration">Lean.Meta.Grind.getGeneration</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getGeneration">getGeneration</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getGeneration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1097-L1099">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#True">True</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqTrue">Lean.Meta.Grind.isEqTrue</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span> <span class="fn">__do_lift_1</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1101-L1103">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#False">False</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqFalse">Lean.Meta.Grind.isEqFalse</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span> <span class="fn">__do_lift_1</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqBoolTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1105-L1107">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqBoolTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqBoolFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1109-L1111">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqBoolFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is in the equivalence class of <code><a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqBoolFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isEqv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1113-L1120">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isEqv"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isEqv</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>a</code> and <code>b</code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isEqv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1122-L1125">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the root of its equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isRoot">Lean.Meta.Grind.isRoot</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__discr</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span>
  <span class="fn">match <span class="fn">__discr</span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.isSameExpr">Lean.Meta.Grind.isSameExpr</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span> <span class="fn">e</span>)</span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getRoot?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1127-L1130">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> IF <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot?">getRoot?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(do
      let <span class="fn">__discr</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span>
      <span class="fn">match <span class="fn">__discr</span> with
        | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span>)</span></span>
        | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span>)</span>.<a href="../../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getRoot?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRoot?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1132-L1134">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> IF <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot?">Lean.Meta.Grind.getRoot?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot?">getRoot?</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRoot?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1136-L1138">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot">getRoot</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1140-L1142">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot">Lean.Meta.Grind.getRoot</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getRoot">getRoot</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRootENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1144-L1146">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></span></div></div><p>Returns the root enode in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode">Lean.Meta.Grind.getRootENode</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRoot">Lean.Meta.Grind.getRoot</a> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRootENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getRootENode?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1148-L1151">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getRootENode?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span></div></div><p>Returns the root enode in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> if it is in an equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode?">Lean.Meta.Grind.getRootENode?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__discr</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn">e</span></span>
  <span class="fn">match <span class="fn">__discr</span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode?">Lean.Meta.Grind.getENode?</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getRootENode?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.useFunCC"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1152-L1157">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.useFunCC"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">useFunCC</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the ENode associate with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has support for function equality
congruence closure. See <code>Grind.Config.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.funCC">funCC</a></code> for additional details.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.useFunCC">Lean.Meta.Grind.useFunCC</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.funCC">funCC</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.useFunCC" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getNext?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1159-L1165">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the next element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>
if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been internalized in the given goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext?">getNext?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(do
      let <span class="fn">__discr</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span>
      <span class="fn">match <span class="fn">__discr</span> with
        | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.next">next</a></span>)</span></span>
        | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span>)</span>.<a href="../../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getNext?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getNext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1167-L1169">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getNext</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the next element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext">getNext</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode">getENode</a></span> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.next">next</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getNext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getNext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1171-L1173">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getNext</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root element in the equivalence class of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getNext">Lean.Meta.Grind.getNext</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getNext">getNext</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getNext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.alreadyInternalized"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1175-L1177">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.alreadyInternalized"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">alreadyInternalized</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has already been internalized.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.alreadyInternalized">Lean.Meta.Grind.alreadyInternalized</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.contains">Lean.PersistentHashMap.contains</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.enodeMap">enodeMap</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.alreadyInternalized" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getTarget?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1179-L1181">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getTarget?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getTarget?">getTarget?</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(do
      let <span class="fn">__discr</span> ← <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getENode?">getENode?</a></span> <span class="fn">e</span></span>
      <span class="fn">match <span class="fn">__discr</span> with
        | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">n</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">n</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.target?">target?</a></span></span>
        | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></span>)</span>.<a href="../../../.././Init/Control/Id.html#Id.run">run</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getTarget?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getTarget?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1183-L1184">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTarget?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getTarget?</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTarget?">Lean.Meta.Grind.getTarget?</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getTarget?">getTarget?</a></span> <span class="fn">e</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getTarget?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1186-L1203">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">isHEq</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>If <code>isHEq</code> is <code>false</code>, it pushes <code>lhs = rhs</code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.
Otherwise, it pushes <code>lhs ≍ rhs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.hasSameType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1205-L1207">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasSameType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasSameType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Return <code>true</code> if <code>a</code> and <code>b</code> have the same type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasSameType">Lean.Meta.Grind.hasSameType</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.inferType">Lean.Meta.inferType</a> <span class="fn">a</span></span>
  let <span class="fn">__do_lift_1</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.inferType">Lean.Meta.inferType</a> <span class="fn">b</span></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqD">Lean.Meta.Grind.isDefEqD</a> <span class="fn">__do_lift</span> <span class="fn">__do_lift_1</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.hasSameType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqHEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1209-L1213">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqHEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqHEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1215-L1217">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>lhs = rhs</code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqCore">Lean.Meta.Grind.pushEqCore</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushHEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1219-L1221">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushHEq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushHEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>lhs ≍ rhs</code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushHEq">Lean.Meta.Grind.pushHEq</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqCore">Lean.Meta.Grind.pushEqCore</a> <span class="fn">lhs</span> <span class="fn">rhs</span> <span class="fn">proof</span> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushHEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1223-L1225">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#True">True</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqTrue">Lean.Meta.Grind.pushEqTrue</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1227-L1229">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#False">False</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqFalse">Lean.Meta.Grind.pushEqFalse</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqBoolTrue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1231-L1233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolTrue"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolTrue</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolTrue">Lean.Meta.Grind.pushEqBoolTrue</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr">Lean.Meta.Grind.getBoolTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqBoolTrue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.pushEqBoolFalse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1235-L1237">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolFalse"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">pushEqBoolFalse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">proof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Pushes <code>a = <a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code> with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PreInstance.proof">proof</a></code> to <code>newEqs</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEqBoolFalse">Lean.Meta.Grind.pushEqBoolFalse</a> <span class="fn">a</span> <span class="fn">proof</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr">Lean.Meta.Grind.getBoolFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.pushEq">Lean.Meta.Grind.pushEq</a> <span class="fn">a</span> <span class="fn">__do_lift</span> <span class="fn">proof</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.pushEqBoolFalse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.registerParent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1239-L1246">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.registerParent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerParent</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parent </span><span class="fn">child</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Records that <code>parent</code> is a parent of <code>child</code>. This function actually stores the
information in the root (aka canonical representative) of <code>child</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.registerParent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getParents"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1248-L1255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getParents"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getParents</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a></span></div></div><p>Returns the set of expressions <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a child of, or an expression in
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>s equivalence class is a child of.
The information is only up to date if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the root (aka canonical representative) of the equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getParents">Lean.Meta.Grind.getParents</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn">match <span class="fn"><a href="../../../.././Lean/Data/PersistentHashMap.html#Lean.PersistentHashMap.find?">Lean.PersistentHashMap.find?</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.parents">parents</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a></span> with
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">parents</span></span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">parents</span></span>
    | <span class="fn">x</span> =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.mk">{</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.mk">}</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getParents" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.resetParentsOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1257-L1261">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.resetParentsOf"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">resetParentsOf</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Removes the entry <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a> ↦ <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.parents">parents</a></code> from the parent map.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.resetParentsOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.copyParentsTo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1263-L1271">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.copyParentsTo"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">copyParentsTo</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parents</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">root</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Copy <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.parents">parents</a></code> to the parents of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></code>.
<code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.root">root</a></code> must be the root of its equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.copyParentsTo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkENodeCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1273-L1288">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkENodeCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENodeCore</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">interpreted </span><span class="fn">ctor</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">funCC</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkENodeCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1290-L1298">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">funCC</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Creates an <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a></code> for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> if one does not already exist.
This method assumes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> has been hash-consed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.setENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1300-L1304">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.setENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">setENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.setENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.hasType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1306-L1310">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasType"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">hasType</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">t </span><span class="fn">α</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if type of <code>t</code> is definitionally equal to <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.InjectiveInfo.α">α</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasType">Lean.Meta.Grind.hasType</a> <span class="fn">t</span> <span class="fn">α</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.inferType">Lean.Meta.inferType</a> <span class="fn">t</span></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isDefEqD">Lean.Meta.Grind.isDefEqD</a> <span class="fn">__do_lift</span> <span class="fn">α</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.hasType" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.forEachDiseq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1312-L1328">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachDiseq"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachDiseq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">parents</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet">ParentSet</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>For each equality <code>b = <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a></code> in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ParentSet.parents">parents</a></code>, executes <code>k b <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a></code> IF</p><ul>
<li><code>b = <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitDiagInfo.c">c</a></code> is equal to <code><a href="../../../.././Init/Prelude.html#False">False</a></code>, and</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.forEachDiseq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isCongrRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1330-L1332">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isCongrRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> is <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is the root of its congruence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isCongrRoot">Lean.Meta.Grind.isCongrRoot</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getENode">Lean.Meta.Grind.getENode</a> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.isCongrRoot">isCongrRoot</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isCongrRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getCongrRoot"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1334-L1338">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getCongrRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getCongrRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns the root of the congruence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p></div></div><div class="decl" id="Lean.Meta.Grind.isInconsistent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1340-L1342">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isInconsistent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Return <code>true</code> if the goal is inconsistent.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isInconsistent">Lean.Meta.Grind.isInconsistent</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.inconsistent">inconsistent</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isInconsistent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqProof"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1344-L1350">source</a></div><div class="attributes">@[extern lean_grind_mk_eq_proof]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = b</code>.
It assumes <code>a</code> and <code>b</code> are in the same equivalence class, and have the same type.</p></div></div><div class="decl" id="Lean.Meta.Grind.mkHEqProof"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1352-L1358">source</a></div><div class="attributes">@[extern lean_grind_mk_heq_proof]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkHEqProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a ≍ b</code>.
It assumes <code>a</code> and <code>b</code> are in the same equivalence class.</p></div></div><div class="decl" id="Lean.Meta.Grind.processNewFacts"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1361-L1362">source</a></div><div class="attributes">@[extern lean_grind_process_new_facts]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.processNewFacts"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">processNewFacts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.internalize"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1365-L1366">source</a></div><div class="attributes">@[extern lean_grind_internalize]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">internalize</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">parent?</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> := <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.preprocess"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1369-L1370">source</a></div><div class="attributes">@[extern lean_grind_preprocess]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.preprocess"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">preprocess</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result">Simp.Result</a></span></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.internalizeLocalDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1372-L1387">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.internalizeLocalDecl"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">internalizeLocalDecl</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">localDecl</span> : <a href="../../../.././Lean/LocalContext.html#Lean.LocalDecl">LocalDecl</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Internalizes a local declaration which is not a proposition.
<strong>Note</strong>: We must internalize local variables because their types may be empty, and may not be
referenced anywhere else. Example:</p><pre><code>example (a : { x : <a href="../../../.././Init/Data/Int/Basic.html#Int">Int</a> // x &lt; 0 ∧ x &gt; 0 }) : <a href="../../../.././Init/Prelude.html#False">False</a> := by <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a>
</code></pre><p><code>etaStruct</code> may also be applicable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.internalizeLocalDecl">Lean.Meta.Grind.internalizeLocalDecl</a> <span class="fn">localDecl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">e</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.shareCommon">Lean.Meta.Grind.shareCommon</a> <span class="fn"><span class="fn">localDecl</span>.<a href="../../../.././Lean/LocalContext.html#Lean.LocalDecl.toExpr">toExpr</a></span>)</span></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.internalize">Lean.Meta.Grind.internalize</a> <span class="fn">e</span> <span class="fn">0</span></span>
  <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.processNewFacts">Lean.Meta.Grind.processNewFacts</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.internalizeLocalDecl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqHEqProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1389-L1397">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqHEqProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqHEqProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = b</code> if they have the same type. Otherwise, returns a proof of <code>a ≍ b</code>.
It assumes <code>a</code> and <code>b</code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqHEqProof">Lean.Meta.Grind.mkEqHEqProof</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.hasSameType">Lean.Meta.Grind.hasSameType</a> <span class="fn">a</span> <span class="fn">b</span>)</span></span>
  <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn">__do_lift</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkHEqProof">Lean.Meta.Grind.mkHEqProof</a> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqHEqProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqTrueProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1399-L1404">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqTrueProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#True">True</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#True">True</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqTrueProof">Lean.Meta.Grind.mkEqTrueProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getTrueExpr">Lean.Meta.Grind.getTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqTrueProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqFalseProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1406-L1411">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqFalseProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#False">False</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#False">False</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqFalseProof">Lean.Meta.Grind.mkEqFalseProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getFalseExpr">Lean.Meta.Grind.getFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqFalseProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqBoolTrueProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1413-L1418">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolTrueProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolTrueProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#Bool.true">Bool.true</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolTrueProof">Lean.Meta.Grind.mkEqBoolTrueProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolTrueExpr">Lean.Meta.Grind.getBoolTrueExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqBoolTrueProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.mkEqBoolFalseProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1420-L1425">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolFalseProof"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">mkEqBoolFalseProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns a proof that <code>a = <a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code>.
It assumes <code>a</code> and <code><a href="../../../.././Init/Prelude.html#Bool.false">Bool.false</a></code> are in the same equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqBoolFalseProof">Lean.Meta.Grind.mkEqBoolFalseProof</a> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getBoolFalseExpr">Lean.Meta.Grind.getBoolFalseExpr</a></span>
  <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.mkEqProof">Lean.Meta.Grind.mkEqProof</a> <span class="fn">a</span> <span class="fn">__do_lift</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.mkEqBoolFalseProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markAsInconsistent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1427-L1431">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markAsInconsistent"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markAsInconsistent</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Marks current goal as inconsistent without assigning <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markAsInconsistent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.assignFalseProof"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1433-L1445">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.MVarId.assignFalseProof"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">assignFalseProof</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">mvarId</span> : <a href="../../../.././Lean/Expr.html#Lean.MVarId">MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">falseProof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Assign the <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code> using the given proof of <code><a href="../../../.././Init/Prelude.html#False">False</a></code>.
If type of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code> is not <code><a href="../../../.././Init/Prelude.html#False">False</a></code>, then use <code><a href="../../../.././Init/Prelude.html#False.elim">False.elim</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.MVarId.assignFalseProof" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.withContext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1447-L1452">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.withContext"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">withContext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> → <a href="../../../.././foundational_types.html">Type</a> u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Basic.html#MonadControlT">MonadControlT</a> <a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p><code>goal.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.withContext">withContext</a> x</code> executes <code>x</code> using the given metavariable <code>LocalContext</code> and <code>LocalInstances</code>.
The type class resolution cache is flushed when executing <code>x</code> if its <code>LocalInstances</code> are
different from the current ones.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.withContext">withContext</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">goal</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></span>.<a href="../../../.././Lean/Meta/Basic.html#Lean.MVarId.withContext">withContext</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.withContext" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.mkAuxMVar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1454-L1463">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mkAuxMVar"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">mkAuxMVar</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <a href="../../../.././Lean/Expr.html#Lean.MVarId">MVarId</a></span></div></div><p>Creates an auxiliary metavariable with the same type and context of <code>goal.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.mvarId">mvarId</a></code>.
We use this function to perform <code>cases</code> on the current goal without eagerly assigning it.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.mkAuxMVar" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.closeGoal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1465-L1473">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.closeGoal"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">closeGoal</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">falseProof</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Closes the current goal using the given proof of <code><a href="../../../.././Init/Prelude.html#False">False</a></code> and
marks it as inconsistent if it is not already marked so.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.closeGoal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getExprs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1475-L1477">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getExprs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExprs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Lean/Data/PersistentArray.html#Lean.PArray">PArray</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns all enodes in the goal</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getExprs">Lean.Meta.Grind.getExprs</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.exprs">exprs</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getExprs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.traverseEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1479-L1486">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.traverseEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">traverseEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Executes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> to each term in the equivalence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.traverseEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.findEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1488-L1498">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.findEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">findEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Executes <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> to each term in the equivalence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>, and stops as soon as <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> returns <code>true</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.findEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.foldEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1500-L1510">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.foldEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">foldEqc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">init</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span></div></div><p>Folds using <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrTheoremCacheKey.f">f</a></code> and <code>init</code> over the equivalence class containing <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.foldEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.forEachENode"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1512-L1515">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachENode"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachENode</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.forEachENode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.filterENodes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1517-L1522">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.filterENodes"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">filterENodes</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.filterENodes" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.forEachEqcRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1524-L1528">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.forEachEqcRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">forEachEqcRoot</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.forEachEqcRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Propagator"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1530-L1530">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Propagator</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator">Lean.Meta.Grind.Propagator</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">Lean.Meta.Grind.GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Propagator" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EvalTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1531-L1531">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EvalTactic"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EvalTactic</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EvalTactic">Lean.Meta.Grind.EvalTactic</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Lean.Meta.Grind.Goal</a> → <span class="fn"><a href="../../../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`grind</span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Lean.Meta.Grind.Goal</a>)</span></span></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.EvalTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.EvalTactic.skip"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1532-L1532">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EvalTactic.skip"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">EvalTactic</span>.<span class="name">skip</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EvalTactic">EvalTactic</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EvalTactic.skip">Lean.Meta.Grind.EvalTactic.skip</a> <span class="fn">goal</span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#List.cons">[</a><span class="fn">goal</span><a href="../../../.././Init/Prelude.html#List.cons">]</a></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.EvalTactic.skip" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Methods"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1534-L1538">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="Lean.Meta.Grind.Methods.mk"><li id="Lean.Meta.Grind.Methods.propagateUp" class="structure_field"><div class="structure_field_info">propagateUp : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator">Propagator</a></div></li><li id="Lean.Meta.Grind.Methods.propagateDown" class="structure_field"><div class="structure_field_info">propagateDown : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Propagator">Propagator</a></div></li><li id="Lean.Meta.Grind.Methods.evalTactic" class="structure_field"><div class="structure_field_info">evalTactic : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.EvalTactic">EvalTactic</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.Methods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedMethods"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1538-L1538">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods">Lean.Meta.Grind.instInhabitedMethods</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods.default">Lean.Meta.Grind.instInhabitedMethods.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedMethods.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1538-L1538">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedMethods</span>.<span class="name">default</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedMethods.default">Lean.Meta.Grind.instInhabitedMethods.default</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.mk">{</a> <span class="fn">propagateUp</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">propagateDown</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn">evalTactic</span> := <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedMethods.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Methods.toMethodsRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1540-L1541">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.toMethodsRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Methods</span>.<span class="name">toMethodsRef</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">m</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.MethodsRef">MethodsRef</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">m</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.toMethodsRef">toMethodsRef</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.Methods.toMethodsRef.unsafe_impl_3">Lean.Meta.Grind.Methods.toMethodsRef.unsafe_impl_3✝</a> <span class="fn">m</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Methods.toMethodsRef" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getMethods"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1546-L1547">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getMethods</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods">Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethodsRef">Lean.Meta.Grind.getMethodsRef</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.MethodsRef.toMethods">Lean.Meta.Grind.MethodsRef.toMethods✝</a> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getMethods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateUp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1549-L1550">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateUp"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateUp</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateUp">Lean.Meta.Grind.propagateUp</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a></span>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.propagateUp">propagateUp</a></span> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateUp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.propagateDown"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1552-L1553">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateDown"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">propagateDown</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.propagateDown">Lean.Meta.Grind.propagateDown</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a></span>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.propagateDown">propagateDown</a></span> <span class="fn">e</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.propagateDown" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.evalTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1555-L1556">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.evalTactic"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">evalTactic</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">stx</span> : <a href="../../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`grind</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">GrindM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.evalTactic">Lean.Meta.Grind.evalTactic</a> <span class="fn">goal</span> <span class="fn">stx</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getMethods">Lean.Meta.Grind.getMethods</a>
  <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Methods.evalTactic">evalTactic</a></span> <span class="fn">goal</span> <span class="fn">stx</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.evalTactic" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1558-L1575">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sort</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns expressions in the given expression equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getEqc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1577-L1579">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqc</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sort</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns expressions in the given expression equivalence class.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqc">Lean.Meta.Grind.getEqc</a> <span class="fn">e</span> <span class="fn">sort</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqc">getEqc</a></span> <span class="fn">e</span> <span class="fn">sort</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getEqc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getEqcs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1581-L1591">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getEqcs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">sort</span> : <a href="../../../.././Init/Prelude.html#Bool">Bool</a> := <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span></div></div><p>Returns all equivalence classes in the current goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getEqcs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getEqcs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1593-L1595">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqcs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getEqcs</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span>)</span></span></div></div><p>Returns all equivalence classes in the current goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getEqcs">Lean.Meta.Grind.getEqcs</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getEqcs">getEqcs</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getEqcs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isKnownCaseSplit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1597-L1603">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isKnownCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isKnownCaseSplit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code>s</code> has been already added to the case-split list at one point.
Remark: this function returns <code>true</code> even if the split has already been resolved
and is not in the list anymore.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isKnownCaseSplit">Lean.Meta.Grind.isKnownCaseSplit</a> <span class="fn">s</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.split">split</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.added">added</a></span>.<a href="../../../.././Std/Data/HashSet/Basic.html#Std.HashSet.contains">contains</a></span> <span class="fn">s</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isKnownCaseSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isResolvedCaseSplit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1605-L1607">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isResolvedCaseSplit"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isResolvedCaseSplit</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> is a case-split that does not need to be performed anymore.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isResolvedCaseSplit">Lean.Meta.Grind.isResolvedCaseSplit</a> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Data/PersistentHashSet.html#Lean.PersistentHashSet.contains">Lean.PersistentHashSet.contains</a> <span class="fn"><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.split">split</a></span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Split.State.resolved">resolved</a></span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">{</a> <span class="fn">expr</span> := <span class="fn">e</span> <a href="../../../.././Lean/Meta/Tactic/Grind/ExprPtr.html#Lean.Meta.Grind.ExprPtr.mk">}</a>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isResolvedCaseSplit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.markCaseSplitAsResolved"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1609-L1617">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.markCaseSplitAsResolved"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">markCaseSplitAsResolved</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Marks <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> as a case-split that does not need to be performed anymore.
Remark: we currently use this feature to disable <code>match</code>-case-splits.
Remark: we also use this feature to record the case-splits that have already been performed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.markCaseSplitAsResolved" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addSplitCandidate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1627-L1635">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addSplitCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addSplitCandidate</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">sinfo</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Inserts <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code> into the list of case-split candidates if it was not inserted before.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addSplitCandidate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ActivateNextGuardResult"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1637-L1639">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActivateNextGuardResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ActivateNextGuardResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.ActivateNextGuardResult.ready">ready : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActivateNextGuardResult">ActivateNextGuardResult</a></li><li class="constructor" id="Lean.Meta.Grind.ActivateNextGuardResult.next">next<span class="decl_args">
<span class="fn">(<span class="fn">guard</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">pending</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard">TheoremGuard</a></span>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActivateNextGuardResult">ActivateNextGuardResult</a></li></ul><details id="instances-for-list-Lean.Meta.Grind.ActivateNextGuardResult" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.activateNextGuard"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1641-L1654">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.activateNextGuard"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">activateNextGuard</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">thm</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">guards</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard">TheoremGuard</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActivateNextGuardResult">ActivateNextGuardResult</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.activateNextGuard">Lean.Meta.Grind.activateNextGuard</a> <span class="fn">thm</span> <span class="fn">guards</span> <span class="fn">generation</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.activateNextGuard.go">Lean.Meta.Grind.activateNextGuard.go✝</a> <span class="fn">thm</span> <span class="fn">generation</span> <span class="fn">guards</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.activateNextGuard" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addTheoremInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1656-L1671">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addTheoremInstance"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addTheoremInstance</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">thm</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">proof </span><span class="fn">prop</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">generation</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">guards</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TheoremGuard">TheoremGuard</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Adds a new theorem instance produced using E-matching.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addTheoremInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.DelayedTheoremInstance.check"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1673-L1674">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">DelayedTheoremInstance</span>.<span class="name">check</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">delayed</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance">DelayedTheoremInstance</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">delayed</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance.check">check</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addTheoremInstance">Lean.Meta.Grind.addTheoremInstance</a> <span class="fn"><span class="fn">delayed</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance.thm">thm</a></span> <span class="fn"><span class="fn">delayed</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance.proof">proof</a></span> <span class="fn"><span class="fn">delayed</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance.prop">prop</a></span> <span class="fn"><span class="fn">delayed</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance.generation">generation</a></span> <span class="fn"><span class="fn">delayed</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.DelayedTheoremInstance.guards">guards</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.DelayedTheoremInstance.check" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.getExtTheorems"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1676-L1691">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getExtTheorems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">getExtTheorems</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">type</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Ext.html#Lean.Meta.Ext.ExtTheorem">Ext.ExtTheorem</a>)</span></span></div></div><p>Returns extensionality theorems for the given type if available.
If <code>Config.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ext">ext</a></code> is <code>false</code>, the result is <code>#[]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.getExtTheorems" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.addLookaheadCandidate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1693-L1697">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.addLookaheadCandidate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">addLookaheadCandidate</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">sinfo</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitInfo">SplitInfo</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Add a new lookahead candidate.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.addLookaheadCandidate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.withoutModifyingState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1699-L1709">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.withoutModifyingState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">withoutModifyingState</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">α</span></span></div></div><p>Helper function for executing <code>x</code> with a fresh <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.newFacts">newFacts</a></code> and without modifying
the goal state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.withoutModifyingState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.canon"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1711-L1713">source</a></div><div class="attributes">@[extern lean_grind_canon]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.canon"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">canon</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Canonicalizes nested types, type formers, and instances in <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p></div></div><div class="mod_doc"><p><code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action">Action</a></code> is the <em>control interface</em> for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code>’s search steps. It is defined in
Continuation-Passing Style (CPS).
See <code><a href="../../../.././Grind/Action.html">Grind/Action.lean</a></code> for additional details.</p></div><div class="decl" id="Lean.Meta.Grind.TGrind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1721-L1721">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TGrind"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">TGrind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TGrind">Lean.Meta.Grind.TGrind</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`grind</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.TGrind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ActionResult"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1723-L1733">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActionResult"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ActionResult</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Result type for a <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code> Action</p><ul class="constructors"><li class="constructor" id="Lean.Meta.Grind.ActionResult.closed">closed<span class="decl_args">
<span class="fn">(<span class="fn">seq</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.TGrind">TGrind</a></span>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActionResult">ActionResult</a><div class="inductive_ctor_doc"><p>The goal has been closed, and you can use <code>seq</code> to close the goal efficiently.</p></div></li><li class="constructor" id="Lean.Meta.Grind.ActionResult.stuck">stuck<span class="decl_args">
<span class="fn">(<span class="fn">gs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a></span>)</span></span>
 : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActionResult">ActionResult</a><div class="inductive_ctor_doc"><p>The action could not make further progress.
<code>gs</code> are subgoals that could not be closed. They are used for producing error messages.</p></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.ActionResult" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.ActionCont"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1735-L1736">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActionCont"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">ActionCont</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActionCont">Lean.Meta.Grind.ActionCont</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Lean.Meta.Grind.Goal</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActionResult">Lean.Meta.Grind.ActionResult</a></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.ActionCont" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Action"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1738-L1739">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Action</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action">Lean.Meta.Grind.Action</a> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Lean.Meta.Grind.Goal</a> →
    <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActionCont">Lean.Meta.Grind.ActionCont</a> → <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActionCont">Lean.Meta.Grind.ActionCont</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GrindM">Lean.Meta.Grind.GrindM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ActionResult">Lean.Meta.Grind.ActionResult</a></span></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Action" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Action.notApplicable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1741-L1742">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action.notApplicable"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Action</span>.<span class="name">notApplicable</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action">Action</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action.notApplicable">Lean.Meta.Grind.Action.notApplicable</a> <span class="fn">goal</span> <span class="fn">kna</span> <span class="fn">x✝</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">kna</span> <span class="fn">goal</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Action.notApplicable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedAction"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1744-L1745">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedAction"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedAction</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action">Action</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedAction">Lean.Meta.Grind.instInhabitedAction</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action.notApplicable">Lean.Meta.Grind.Action.notApplicable</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="mod_doc"><p>Solver Extensions</p></div><div class="decl" id="Lean.Meta.Grind.SolverExtension"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1751-L1765">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><p>Solver extension, can only be generated by <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.registerSolverExtension">registerSolverExtension</a></code> that allocates a unique index
for this extension into each goal's extension state's array.</p><ul class="structure_fields" id="_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.mk"><li id="Lean.Meta.Grind.SolverExtension.id" class="structure_field"><div class="structure_field_info">id : <a href="../../../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Meta.Grind.SolverExtension.mkInitial" class="structure_field"><div class="structure_field_info">mkInitial : <span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">σ</span></span></div></li><li id="Lean.Meta.Grind.SolverExtension.internalize" class="structure_field"><div class="structure_field_info">internalize : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn">(<span class="fn">parent?</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>) → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span></span></div></li><li id="Lean.Meta.Grind.SolverExtension.newEq" class="structure_field"><div class="structure_field_info">newEq : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></li><li id="Lean.Meta.Grind.SolverExtension.newDiseq" class="structure_field"><div class="structure_field_info">newDiseq : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span></div></li><li id="Lean.Meta.Grind.SolverExtension.mbtc" class="structure_field"><div class="structure_field_info">mbtc : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></li><li id="Lean.Meta.Grind.SolverExtension.action" class="structure_field"><div class="structure_field_info">action : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action">Action</a></div></li><li id="Lean.Meta.Grind.SolverExtension.check" class="structure_field"><div class="structure_field_info">check : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></li><li id="Lean.Meta.Grind.SolverExtension.checkInv" class="structure_field"><div class="structure_field_info">checkInv : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.SolverExtension" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverExtension.default"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1765-L1765">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtension.default"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtension</span>.<span class="name">default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a✝</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">a✝</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.instInhabitedSolverExtension.default" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedSolverExtension"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1765-L1765">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedSolverExtension</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a✝</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">a✝</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtension">Lean.Meta.Grind.instInhabitedSolverExtension</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedSolverExtension.default">Lean.Meta.Grind.instInhabitedSolverExtension.default</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.registerSolverExtension"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1769-L1790">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.registerSolverExtension"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">registerSolverExtension</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">mkInitial</span> : <span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span>)</span></span></div></div><p>Registers a new solver extension for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SavedState.grind">grind</a></code>.
Solver extensions can only be registered during initialization.
Reason: We do not use any synchronization primitive to access <code>solverExtensionsRef</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.registerSolverExtension" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.setMethods"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1792-L1812">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.setMethods"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">setMethods</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">internalize</span> : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span></span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>) (<span class="fn">x_1</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">newEq </span><span class="fn">newDiseq</span> : <span class="fn"><a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a> → <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></span> := <span class="fn">fun (<span class="fn">x</span> <span class="fn">x_1</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mbtc</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span> := <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">action</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action">Action</a> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action.notApplicable">Action.notApplicable</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">check</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span> := <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">checkInv</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span> := <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Sets methods/handlers for solver extension <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ext">ext</a></code>.
Solver extension methods can only be registered during initialization.
Reason: We do not use any synchronization primitive to access <code>solverExtensionsRef</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.setMethods" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.mkInitialStates"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1814-L1817">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.mkInitialStates"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mkInitialStates</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtensionState">SolverExtensionState</a>)</span></span></div></div><p>Returns initial state for registered solvers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.mkInitialStates" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instInhabitedGoalM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1819-L1820">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoalM"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instInhabitedGoalM</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">σ</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instInhabitedGoalM">Lean.Meta.Grind.instInhabitedGoalM</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href="../../../.././Lean/Exception.html#Lean.throwError">Lean.throwError</a> <span class="fn">(<a href="../../../.././Lean/Message.html#Lean.ToMessageData.toMessageData">Lean.toMessageData</a> <span class="fn">&quot;&lt;GoalM action default value&gt;&quot;</span>)</span></span> <a href="../../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.modifyState"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1827-L1828">source</a></div><div class="attributes">@[implemented_by _private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.modifyStateImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.modifyState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">modifyState</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">σ</span> → <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.getStateCore"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1833-L1834">source</a></div><div class="attributes">@[implemented_by _private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.getStateCoreImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getStateCore"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getStateCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <span class="fn">σ</span></span></div></div></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.getState"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1836-L1837">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getState"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getState</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">σ</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getState">getState</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Init/Prelude.html#MonadState.get">get</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getStateCore">getStateCore</a></span> <span class="fn">__do_lift</span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.getState" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.internalize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1839-L1841">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.internalize"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">internalize</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">parent?</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Internalizes given expression in all registered solvers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.internalize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.checkInvariants"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1843-L1845">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.checkInvariants"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">checkInvariants</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Checks invariants of all registered solvers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.checkInvariants" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.check?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1847-L1862">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.check?"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">check?</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span>)</span></span></div></div><p>Performs (expensive) satisfiability checks in all registered solvers,
and returns the solver ids that made progress.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.check?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.check"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1864-L1865">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.check"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">check</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.check">Lean.Meta.Grind.Solvers.check</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.check?">Lean.Meta.Grind.Solvers.check?</a>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.check" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.mbtc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1867-L1873">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.mbtc"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mbtc</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Invokes model-based theory combination extensions in all registered solvers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.mbtc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Action.andAlso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1875-L1882">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action.andAlso"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Action</span>.<span class="name">andAlso</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action">Action</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action">Action</a></div></div><p>Sequential conjunction: executes both <code>x</code> and <code>y</code>.</p><ul>
<li>Runs <code>x</code> and always runs <code>y</code> afterward, regardless of whether <code>x</code> made progress.</li>
<li>It is not applicable only if both <code>x</code> and <code>y</code> are not applicable.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">x</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action.andAlso">andAlso</a></span> <span class="fn">y</span> <span class="fn">goal</span> <span class="fn">kna</span> <span class="fn">kp</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">x</span> <span class="fn">goal</span> <span class="fn">(fun (<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Lean.Meta.Grind.Goal</a>) =&gt; <span class="fn"><span class="fn">y</span> <span class="fn">goal</span> <span class="fn">kna</span> <span class="fn">kp</span></span>)</span> <span class="fn">fun (<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Lean.Meta.Grind.Goal</a>) =&gt; <span class="fn"><span class="fn">y</span> <span class="fn">goal</span> <span class="fn">kp</span> <span class="fn">kp</span></span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Action.andAlso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.mkAction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1888-L1898">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.mkAction"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mkAction</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/System/IO.html#IO">IO</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Action">Action</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.mkAction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.propagateDiseqs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1900-L1917">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.propagateDiseqs"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">propagateDiseqs</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">lhs </span><span class="fn">rhs</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Given a new disequality <code>lhs ≠ rhs</code>, propagates it to relevant theories.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.propagateDiseqs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.isSameSolverTerms"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1945-L1946">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isSameSolverTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">isSameSolverTerms</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverTerms">SolverTerms</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Bool">Bool</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.isSameSolverTerms">Lean.Meta.Grind.isSameSolverTerms</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.isSameSolverTerms.unsafe_impl_3">Lean.Meta.Grind.isSameSolverTerms.unsafe_impl_3✝</a> <span class="fn">a</span> <span class="fn">b</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.isSameSolverTerms" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.markTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1948-L1969">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.markTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">markTerm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.markTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.getTerm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1971-L1979">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getTerm"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">getTerm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a></span></div></div><p>Returns <code>some t</code> if <code>t</code> is the solver term for <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SplitSource.ext">ext</a></code> associated with <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.getTerm">getTerm</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.getTerm.go">Lean.Meta.Grind.SolverExtension.getTerm.go✝</a> <span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.id">id</a></span> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.sTerms">sTerms</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.getTerm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.SolverExtension.hasTermAtRoot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1981-L1990">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.hasTermAtRoot"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">SolverExtension</span>.<span class="name">hasTermAtRoot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">σ</span> : <a href="../../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ext</span> : <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension">SolverExtension</a> <span class="fn">σ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../../.././Lean/Expr.html#Lean.Expr">Expr</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the root of <code><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.CongrKey.e">e</a></code>s equivalence class is already attached to a term
of the given solver.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.hasTermAtRoot">hasTermAtRoot</a></span> <span class="fn">e</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let <span class="fn">__do_lift</span> ← <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.getRootENode">Lean.Meta.Grind.getRootENode</a> <span class="fn">e</span></span>
  <span class="fn"><a href="../../../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.SolverExtension.hasTermAtRoot.go">Lean.Meta.Grind.SolverExtension.hasTermAtRoot.go✝</a> <span class="fn"><span class="fn">ext</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.SolverExtension.id">id</a></span> <span class="fn"><span class="fn">__do_lift</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode.sTerms">sTerms</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.SolverExtension.hasTermAtRoot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PendingSolverPropagations"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L1997-L1998">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PendingSolverPropagations</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a></div></div><ul class="structure_fields" id="_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagations.mk"><li id="_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagations.data" class="structure_field"><div class="structure_field_info">data : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagationsData">Lean.Meta.Grind.PendingSolverPropagationsData✝</a></div></li></ul><details id="instances-for-list-Lean.Meta.Grind.PendingSolverPropagations" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Solvers.mergeTerms"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L2000-L2027">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Solvers.mergeTerms"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Solvers</span>.<span class="name">mergeTerms</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">rhsRoot </span><span class="fn">lhsRoot</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.ENode">ENode</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations">PendingSolverPropagations</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Solvers.mergeTerms" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.PendingSolverPropagations.propagate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L2029-L2040">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations.propagate"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">PendingSolverPropagations</span>.<span class="name">propagate</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations">PendingSolverPropagations</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.GoalM">GoalM</a> <a href="../../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">p</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.PendingSolverPropagations.propagate">propagate</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagations.propagate.go">Lean.Meta.Grind.PendingSolverPropagations.propagate.go✝</a> <span class="fn">(<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#_private.Lean.Meta.Tactic.Grind.Types.0.Lean.Meta.Grind.PendingSolverPropagations.data">Lean.Meta.Grind.PendingSolverPropagations.data✝</a> <span class="fn">p</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.PendingSolverPropagations.propagate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.anchorPrefixToString"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L2042-L2047">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.anchorPrefixToString"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">anchorPrefixToString</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">numDigits</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">anchorPrefix</span> : <a href="../../../.././Init/Prelude.html#UInt64">UInt64</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#String">String</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.anchorPrefixToString">Lean.Meta.Grind.anchorPrefixToString</a> <span class="fn">numDigits</span> <span class="fn">anchorPrefix</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/String/Bootstrap.html#String.ofList">String.ofList</a>
    (<span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.replicate">List.replicate</a> (<span class="fn">numDigits</span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Repr.html#Nat.toDigits">Nat.toDigits</a> <span class="fn">16</span> <span class="fn"><span class="fn">anchorPrefix</span>.<a href="../../../.././Init/Data/UInt/BasicAux.html#UInt64.toNat">toNat</a></span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span>) <span class="fn">'0'</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Init/Data/Repr.html#Nat.toDigits">Nat.toDigits</a> <span class="fn">16</span> <span class="fn"><span class="fn">anchorPrefix</span>.<a href="../../../.././Init/Data/UInt/BasicAux.html#UInt64.toNat">toNat</a></span></span>)</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.anchorPrefixToString" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.anchorToString"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L2049-L2050">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.anchorToString"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">anchorToString</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">numDigits</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">anchor</span> : <a href="../../../.././Init/Prelude.html#UInt64">UInt64</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#String">String</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.anchorToString">Lean.Meta.Grind.anchorToString</a> <span class="fn">numDigits</span> <span class="fn">anchor</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.anchorPrefixToString">Lean.Meta.Grind.anchorPrefixToString</a> <span class="fn">numDigits</span> (<span class="fn">anchor</span> <a href="../../../.././Init/Prelude.html#HShiftRight.hShiftRight">&gt;&gt;&gt;</a> (<span class="fn">64</span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">4</span> <a href="../../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><span class="fn">numDigits</span>.<a href="../../../.././Init/Data/UInt/BasicAux.html#Nat.toUInt64">toUInt64</a></span>))</span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.anchorToString" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.AnchorRef.toString"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L2052-L2053">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef.toString"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">AnchorRef</span>.<span class="name">toString</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">anchorRef</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef">AnchorRef</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#String">String</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">anchorRef</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef.toString">toString</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.anchorPrefixToString">Lean.Meta.Grind.anchorPrefixToString</a> <span class="fn"><span class="fn">anchorRef</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef.numDigits">numDigits</a></span> <span class="fn"><span class="fn">anchorRef</span>.<a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef.anchorPrefix">anchorPrefix</a></span></span></li></ul></details><details id="instances-for-list-Lean.Meta.Grind.AnchorRef.toString" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.instToStringAnchorRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L2055-L2056">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instToStringAnchorRef"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">instToStringAnchorRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/ToString/Basic.html#ToString">ToString</a> <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef">AnchorRef</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.instToStringAnchorRef">Lean.Meta.Grind.instToStringAnchorRef</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/ToString/Basic.html#ToString.mk">{</a> <span class="fn">toString</span> := <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.AnchorRef.toString">Lean.Meta.Grind.AnchorRef.toString</a> <a href="../../../.././Init/Data/ToString/Basic.html#ToString.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Meta.Grind.Goal.getActiveMatchEqTheorems"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Meta/Tactic/Grind/Types.lean#L2058-L2069">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal.getActiveMatchEqTheorems"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">Grind</span>.<span class="name">Goal</span>.<span class="name">getActiveMatchEqTheorems</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">goal</span> : <a href="../../../.././Lean/Meta/Tactic/Grind/Types.html#Lean.Meta.Grind.Goal">Goal</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#Array">Array</a> <a href="../../../.././Lean/Meta/Tactic/Grind/EMatchTheorem.html#Lean.Meta.Grind.EMatchTheorem">EMatchTheorem</a>)</span></span></div></div><p>Returns activated <code>match</code>-declaration equations.
Recall that in tactics such as <code>instantiate only [...]</code>, <code>match</code>-declarations are always instantiated.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.Grind.Goal.getActiveMatchEqTheorems" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>