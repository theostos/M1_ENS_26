<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Lean.Elab.Parallel</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Lean.Elab.Parallel";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Parallel</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init/System/IO.html">Init.System.IO</a></li><li><a href="../.././Lean/Elab/Task.html">Lean.Elab.Task</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Lean.Elab.Parallel" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Std.Iterators.TaskIterator"><span class="name">Std</span>.<span class="name">Iterators</span>.<span class="name">TaskIterator</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Core.CoreM.parIterWithCancel"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parIterWithCancel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Core.CoreM.parIter"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parIter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Core.CoreM.parIterGreedyWithCancel"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parIterGreedyWithCancel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Core.CoreM.parIterGreedy"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parIterGreedy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Core.CoreM.par"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">par</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Core.CoreM.par'"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">par'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Core.CoreM.parFirst"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parFirst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.MetaM.par"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">par</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.MetaM.par'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">par'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.MetaM.parIterWithCancel"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parIterWithCancel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.MetaM.parIter"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parIter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.MetaM.parIterGreedyWithCancel"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parIterGreedyWithCancel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.MetaM.parIterGreedy"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parIterGreedy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Meta.MetaM.parFirst"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parFirst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.TermElabM.parIterWithCancel"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parIterWithCancel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.TermElabM.parIter"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parIter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.TermElabM.parIterGreedyWithCancel"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parIterGreedyWithCancel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.TermElabM.parIterGreedy"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parIterGreedy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.TermElabM.par"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">par</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.TermElabM.par'"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">par'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Term.TermElabM.parFirst"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parFirst</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Tactic.TacticM.parIterWithCancel"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parIterWithCancel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Tactic.TacticM.parIter"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parIter</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Tactic.TacticM.parIterGreedyWithCancel"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parIterGreedyWithCancel</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Tactic.TacticM.parIterGreedy"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parIterGreedy</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Tactic.TacticM.par"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">par</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Tactic.TacticM.par'"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">par'</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Elab.Tactic.TacticM.parFirst"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parFirst</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Iterator-based-parallelization-for-Lean-s-tactic-monads">Iterator-based parallelization for Lean's tactic monads. <a class="hover-link" href="#Iterator-based-parallelization-for-Lean-s-tactic-monads">#</a></h1><p>This file provides utilities for running computations in parallel using Lean's task system,
with support for collecting results in different ways.</p><h2 class="markdown-heading" id="Main-functions">Main functions <a class="hover-link" href="#Main-functions">#</a></h2><p>For each monad (<code><a href="../.././Init/System/IO.html#IO">IO</a></code>, <code>CoreM</code>, <code>MetaM</code>, <code>TermElabM</code>, <code>TacticM</code>), the following functions are provided:</p><ul>
<li><p><code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par">par</a></code> / <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par'">par'</a></code></p>
<ul>
<li>Run jobs in parallel, collect results in original order</li>
<li>Takes <code><a href="../.././Init/Prelude.html#List">List</a> (MonadM α)</code>, returns <code>MonadM (List (Except Error (α × State)))</code> / <code>MonadM (List (Except Error α))</code></li>
<li>All tasks run in parallel, results returned in input order</li>
<li><code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par">par</a></code> returns state information, <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par'">par'</a></code> discards state</li>
<li>Final state is restored to initial state (before tasks ran)</li>
<li>Errors wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a></code> so all results are collected</li>
</ul>
</li>
<li><p><code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter">parIter</a></code> / <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterWithCancel">parIterWithCancel</a></code></p>
<ul>
<li>Run jobs in parallel, iterate over results in original order</li>
<li>Takes <code><a href="../.././Init/Prelude.html#List">List</a> (MonadM α)</code>, returns iterator</li>
<li><code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterWithCancel">parIterWithCancel</a></code> also returns cancellation hook</li>
</ul>
</li>
<li><p><code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedy">parIterGreedy</a></code> / <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedyWithCancel">parIterGreedyWithCancel</a></code></p>
<ul>
<li>Run jobs in parallel, iterate over results in completion order (greedily)</li>
<li>Takes <code><a href="../.././Init/Prelude.html#List">List</a> (MonadM α)</code>, returns iterator</li>
<li><code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedyWithCancel">parIterGreedyWithCancel</a></code> also returns cancellation hook</li>
</ul>
</li>
<li><p><code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parFirst">parFirst</a></code></p>
<ul>
<li>Run jobs in parallel, return first successful result (by completion order)</li>
<li>Cancels remaining tasks after first success (by default)</li>
<li>Throws error if all tasks fail</li>
</ul>
</li>
</ul><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>The greedy iterator-based functions use <code><a href="../.././Init/System/IO.html#IO.waitAny'">IO.waitAny'</a></code> internally to wait for task completion in any order.
The ordered iterator-based functions process tasks sequentially in the original order.</p><p><strong>State threading in iterators:</strong>
The iterators (<code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter">parIter</a></code>, <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedy">parIterGreedy</a></code>, and their <code>WithCancel</code> variants) preserve state from each
completed task. When you map over an iterator with a monadic function, the monad state will be that at
the conclusion of the monadic action that produced each value. This means:</p><ul>
<li>For <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter">parIter</a></code>: State is threaded sequentially in the original task order</li>
<li>For <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedy">parIterGreedy</a></code>: State is threaded in task completion order</li>
</ul><p>This allows you to observe state changes (like logged messages, modified metavariable contexts, etc.)
as tasks complete, unlike <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par">par</a></code>/<code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par'">par'</a></code> which restore the initial state after collecting all results.</p><p>Iterators do not have <code>Finite</code> instances, as we cannot prove termination from the available
information. For consumers that require <code>Finite</code> (like <code>.toList</code>), use <code>.allowNontermination.toList</code>.</p></div><div class="decl" id="Std.Iterators.TaskIterator"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L68-L73">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Std.Iterators.TaskIterator"><span class="name">Std</span>.<span class="name">Iterators</span>.<span class="name">TaskIterator</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> w)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> w</div></div><p>Internal state for an iterator over tasks.
Maintains the list of tasks that haven't completed yet.</p><ul class="structure_fields" id="_private.Lean.Elab.Parallel.0.Std.Iterators.TaskIterator.mk"><li id="_private.Lean.Elab.Parallel.0.Std.Iterators.TaskIterator.tasks" class="structure_field"><div class="structure_field_info">tasks : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Core.html#Task">Task</a> <span class="fn">α</span>)</span></span></div></li></ul><details id="instances-for-list-Std.Iterators.TaskIterator" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Core.CoreM.parIterWithCancel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L128-L151">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterWithCancel"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parIterWithCancel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> (<span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span></span>)</span></div></div><p>Runs a list of CoreM computations in parallel and returns:</p><ul>
<li>a combined cancellation hook for all tasks, and</li>
<li>an iterator that yields results in original order.</li>
</ul><p>The iterator runs in CoreM, and as it yields each result, it updates the CoreM state
to reflect the state when that particular task completed. This means the state is
threaded through the iteration in the order of the original list.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code> so that errors in individual tasks don't stop
the iteration - you can observe all results including which tasks failed.</p><p>The iterator will terminate after all jobs complete (assuming they all do complete).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Core.CoreM.parIterWithCancel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Core.CoreM.parIter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L153-L159">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parIter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">(<a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of CoreM computations in parallel (without cancellation hook).</p><p>Returns an iterator that yields results in original order, wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter">Lean.Core.CoreM.parIter</a> <span class="fn">jobs</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Lean.Exception</a> <span class="fn">α</span>)</span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../.././Init/Prelude.html#Prod.snd">snd</a></span>)</span> <a href="../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a>     <span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterWithCancel">Lean.Core.CoreM.parIterWithCancel</a> <span class="fn">jobs</span></span></li></ul></details><details id="instances-for-list-Lean.Core.CoreM.parIter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Core.CoreM.parIterGreedyWithCancel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L161-L185">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedyWithCancel"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parIterGreedyWithCancel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> (<span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span></span>)</span></div></div><p>Runs a list of CoreM computations in parallel and returns:</p><ul>
<li>a combined cancellation hook for all tasks, and</li>
<li>an iterator that yields results in completion order (greedily).</li>
</ul><p>The iterator runs in CoreM, and as it yields each result, it updates the CoreM state
to reflect the state when that particular task completed. This means the state is
threaded through the iteration in task completion order.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code> so that errors in individual tasks don't stop
the iteration - you can observe all results including which tasks failed.</p><p>The iterator will terminate after all jobs complete (assuming they all do complete).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Core.CoreM.parIterGreedyWithCancel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Core.CoreM.parIterGreedy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L187-L193">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedy"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parIterGreedy</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">(<a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of CoreM computations in parallel (without cancellation hook).</p><p>Returns an iterator that yields results in completion order, wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedy">Lean.Core.CoreM.parIterGreedy</a> <span class="fn">jobs</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/CoreM.html#Lean.Core.CoreM">Lean.CoreM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Lean.Exception</a> <span class="fn">α</span>)</span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../.././Init/Prelude.html#Prod.snd">snd</a></span>)</span> <a href="../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a>     <span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIterGreedyWithCancel">Lean.Core.CoreM.parIterGreedyWithCancel</a> <span class="fn">jobs</span></span></li></ul></details><details id="instances-for-list-Lean.Core.CoreM.parIterGreedy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Core.CoreM.par"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L195-L217">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">par</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> (<span class="fn">α</span> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/CoreM.html#Lean.Core.SavedState">SavedState</a>))</span>)</span></span></div></div><p>Runs a list of CoreM computations in parallel and collects results in the original order,
including the saved state after each task completes.</p><p>Unlike <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter">parIter</a></code>, this waits for all tasks to complete and returns results
in the same order as the input list, not in completion order.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception (α × Core.SavedState)</code> so that errors in individual
tasks don't stop the collection - you can observe all results including which tasks failed.</p><p>The final CoreM state is restored to the initial state (before tasks ran).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Core.CoreM.par" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Core.CoreM.par'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L219-L238">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par'"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">par'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of CoreM computations in parallel and collects results in the original order,
discarding state information.</p><p>Unlike <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par">par</a></code>, this doesn't return state information from tasks.</p><p>The final CoreM state is restored to the initial state (before tasks ran).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Core.CoreM.par'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Core.CoreM.parFirst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L240-L254">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parFirst"><span class="name">Lean</span>.<span class="name">Core</span>.<span class="name">CoreM</span>.<span class="name">parFirst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cancel</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/CoreM.html#Lean.Core.CoreM">CoreM</a> <span class="fn">α</span></span></div></div><p>Runs a list of CoreM computations in parallel and returns the first successful result
(by completion order, not list order).</p><p>If <code>cancel := true</code> (the default), cancels all remaining tasks after the first success.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Core.CoreM.parFirst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.MetaM.par"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L262-L284">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.par"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">par</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> (<span class="fn">α</span> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.SavedState">SavedState</a>))</span>)</span></span></div></div><p>Runs a list of MetaM computations in parallel and collects results in the original order,
including the saved state after each task completes.</p><p>Unlike <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter">parIter</a></code>, this waits for all tasks to complete and returns results
in the same order as the input list, not in completion order.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception (α × Meta.SavedState)</code> so that errors in individual
tasks don't stop the collection - you can observe all results including which tasks failed.</p><p>The final MetaM state is restored to the initial state (before tasks ran).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.MetaM.par" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.MetaM.par'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L286-L305">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.par'"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">par'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of MetaM computations in parallel and collects results in the original order,
discarding state information.</p><p>Unlike <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par">par</a></code>, this doesn't return state information from tasks.</p><p>The final MetaM state is restored to the initial state (before tasks ran).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.MetaM.par'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.MetaM.parIterWithCancel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L307-L331">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterWithCancel"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parIterWithCancel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span></span>)</span></div></div><p>Runs a list of MetaM computations in parallel and returns:</p><ul>
<li>a combined cancellation hook for all tasks, and</li>
<li>an iterator that yields results in original order.</li>
</ul><p>The iterator runs in MetaM, and as it yields each result, it updates the MetaM state
to reflect the state when that particular task completed. This means the state is
threaded through the iteration in the order of the original list.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code> so that errors in individual tasks don't stop
the iteration - you can observe all results including which tasks failed.</p><p>The iterator will terminate after all jobs complete (assuming they all do complete).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.MetaM.parIterWithCancel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.MetaM.parIter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L333-L339">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIter"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parIter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of MetaM computations in parallel (without cancellation hook).</p><p>Returns an iterator that yields results in original order, wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIter">Lean.Meta.MetaM.parIter</a> <span class="fn">jobs</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Lean.Exception</a> <span class="fn">α</span>)</span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../.././Init/Prelude.html#Prod.snd">snd</a></span>)</span> <a href="../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a>     <span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterWithCancel">Lean.Meta.MetaM.parIterWithCancel</a> <span class="fn">jobs</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.MetaM.parIter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.MetaM.parIterGreedyWithCancel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L341-L365">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterGreedyWithCancel"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parIterGreedyWithCancel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> (<span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span></span>)</span></div></div><p>Runs a list of MetaM computations in parallel and returns:</p><ul>
<li>a combined cancellation hook for all tasks, and</li>
<li>an iterator that yields results in completion order (greedily).</li>
</ul><p>The iterator runs in MetaM, and as it yields each result, it updates the MetaM state
to reflect the state when that particular task completed. This means the state is
threaded through the iteration in task completion order.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code> so that errors in individual tasks don't stop
the iteration - you can observe all results including which tasks failed.</p><p>The iterator will terminate after all jobs complete (assuming they all do complete).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.MetaM.parIterGreedyWithCancel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.MetaM.parIterGreedy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L367-L373">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterGreedy"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parIterGreedy</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of MetaM computations in parallel (without cancellation hook).</p><p>Returns an iterator that yields results in completion order, wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterGreedy">Lean.Meta.MetaM.parIterGreedy</a> <span class="fn">jobs</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Lean.Exception</a> <span class="fn">α</span>)</span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../.././Init/Prelude.html#Prod.snd">snd</a></span>)</span> <a href="../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a>     <span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.parIterGreedyWithCancel">Lean.Meta.MetaM.parIterGreedyWithCancel</a> <span class="fn">jobs</span></span></li></ul></details><details id="instances-for-list-Lean.Meta.MetaM.parIterGreedy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Meta.MetaM.parFirst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L375-L389">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Meta.MetaM.parFirst"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">MetaM</span>.<span class="name">parFirst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cancel</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">MetaM</a> <span class="fn">α</span></span></div></div><p>Runs a list of MetaM computations in parallel and returns the first successful result
(by completion order, not list order).</p><p>If <code>cancel := true</code> (the default), cancels all remaining tasks after the first success.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Meta.MetaM.parFirst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.TermElabM.parIterWithCancel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L397-L421">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterWithCancel"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parIterWithCancel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> (<span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span></span>)</span></div></div><p>Runs a list of TermElabM computations in parallel and returns:</p><ul>
<li>a combined cancellation hook for all tasks, and</li>
<li>an iterator that yields results in original order.</li>
</ul><p>The iterator runs in TermElabM, and as it yields each result, it updates the TermElabM state
to reflect the state when that particular task completed. This means the state is
threaded through the iteration in the order of the original list.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code> so that errors in individual tasks don't stop
the iteration - you can observe all results including which tasks failed.</p><p>The iterator will terminate after all jobs complete (assuming they all do complete).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Term.TermElabM.parIterWithCancel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.TermElabM.parIter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L423-L429">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIter"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parIter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">(<a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of TermElabM computations in parallel (without cancellation hook).</p><p>Returns an iterator that yields results in original order, wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIter">Lean.Elab.Term.TermElabM.parIter</a> <span class="fn">jobs</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Lean.Exception</a> <span class="fn">α</span>)</span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../.././Init/Prelude.html#Prod.snd">snd</a></span>)</span> <a href="../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a>     <span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterWithCancel">Lean.Elab.Term.TermElabM.parIterWithCancel</a> <span class="fn">jobs</span></span></li></ul></details><details id="instances-for-list-Lean.Elab.Term.TermElabM.parIter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.TermElabM.parIterGreedyWithCancel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L431-L455">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterGreedyWithCancel"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parIterGreedyWithCancel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> (<span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span></span>)</span></div></div><p>Runs a list of TermElabM computations in parallel and returns:</p><ul>
<li>a combined cancellation hook for all tasks, and</li>
<li>an iterator that yields results in completion order (greedily).</li>
</ul><p>The iterator runs in TermElabM, and as it yields each result, it updates the TermElabM state
to reflect the state when that particular task completed. This means the state is
threaded through the iteration in task completion order.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code> so that errors in individual tasks don't stop
the iteration - you can observe all results including which tasks failed.</p><p>The iterator will terminate after all jobs complete (assuming they all do complete).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Term.TermElabM.parIterGreedyWithCancel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.TermElabM.parIterGreedy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L457-L463">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parIterGreedy"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parIterGreedy</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">(<a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of TermElabM computations in parallel (without cancellation hook).</p><p>Returns an iterator that yields results in completion order, wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Term.TermElabM.parIterGreedy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.TermElabM.par"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L465-L489">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.par"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">par</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> (<span class="fn">α</span> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.SavedState">SavedState</a>))</span>)</span></span></div></div><p>Runs a list of TermElabM computations in parallel and collects results in the original order,
including the saved state after each task completes.</p><p>Unlike <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter">parIter</a></code>, this waits for all tasks to complete and returns results
in the same order as the input list, not in completion order.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception (α × Term.SavedState)</code> so that errors in individual
tasks don't stop the collection - you can observe all results including which tasks failed.</p><p>The final TermElabM state is restored to the initial state (before tasks ran).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Term.TermElabM.par" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.TermElabM.par'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L491-L510">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.par'"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">par'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of TermElabM computations in parallel and collects results in the original order,
discarding state information.</p><p>Unlike <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par">par</a></code>, this doesn't return state information from tasks.</p><p>The final TermElabM state is restored to the initial state (before tasks ran).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Term.TermElabM.par'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Term.TermElabM.parFirst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L512-L526">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Term.TermElabM.parFirst"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Term</span>.<span class="name">TermElabM</span>.<span class="name">parFirst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cancel</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM">TermElabM</a> <span class="fn">α</span></span></div></div><p>Runs a list of TermElabM computations in parallel and returns the first successful result
(by completion order, not list order).</p><p>If <code>cancel := true</code> (the default), cancels all remaining tasks after the first success.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Term.TermElabM.parFirst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Tactic.TacticM.parIterWithCancel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L534-L558">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterWithCancel"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parIterWithCancel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> (<span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span></span>)</span></div></div><p>Runs a list of TacticM computations in parallel and returns:</p><ul>
<li>a combined cancellation hook for all tasks, and</li>
<li>an iterator that yields results in original order.</li>
</ul><p>The iterator runs in TacticM, and as it yields each result, it updates the TacticM state
to reflect the state when that particular task completed. This means the state is
threaded through the iteration in the order of the original list.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code> so that errors in individual tasks don't stop
the iteration - you can observe all results including which tasks failed.</p><p>The iterator will terminate after all jobs complete (assuming they all do complete).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Tactic.TacticM.parIterWithCancel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Tactic.TacticM.parIter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L560-L566">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIter"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parIter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">(<a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of TacticM computations in parallel (without cancellation hook).</p><p>Returns an iterator that yields results in original order, wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIter">Lean.Elab.Tactic.TacticM.parIter</a> <span class="fn">jobs</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">Lean.Elab.Tactic.TacticM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Lean.Exception</a> <span class="fn">α</span>)</span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../.././Init/Prelude.html#Prod.snd">snd</a></span>)</span> <a href="../.././Init/Prelude.html#Functor.map">&lt;$&gt;</a>     <span class="fn"><a href="../.././Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterWithCancel">Lean.Elab.Tactic.TacticM.parIterWithCancel</a> <span class="fn">jobs</span></span></li></ul></details><details id="instances-for-list-Lean.Elab.Tactic.TacticM.parIter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Tactic.TacticM.parIterGreedyWithCancel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L568-L592">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterGreedyWithCancel"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parIterGreedyWithCancel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> (<span class="fn"><a href="../.././Init/System/IO.html#BaseIO">BaseIO</a> <a href="../.././Init/Prelude.html#PUnit">PUnit</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span></span>)</span></div></div><p>Runs a list of TacticM computations in parallel and returns:</p><ul>
<li>a combined cancellation hook for all tasks, and</li>
<li>an iterator that yields results in completion order (greedily).</li>
</ul><p>The iterator runs in TacticM, and as it yields each result, it updates the TacticM state
to reflect the state when that particular task completed. This means the state is
threaded through the iteration in task completion order.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code> so that errors in individual tasks don't stop
the iteration - you can observe all results including which tasks failed.</p><p>The iterator will terminate after all jobs complete (assuming they all do complete).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Tactic.TacticM.parIterGreedyWithCancel" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Tactic.TacticM.parIterGreedy"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L594-L600">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parIterGreedy"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parIterGreedy</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">(<a href="../.././Init/Data/Iterators/Basic.html#Std.Iterators.IterM">Std.IterM</a> <a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of TacticM computations in parallel (without cancellation hook).</p><p>Returns an iterator that yields results in completion order, wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Tactic.TacticM.parIterGreedy" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Tactic.TacticM.par"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L602-L626">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.par"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">par</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> (<span class="fn">α</span> <a href="../.././Init/Prelude.html#Prod">×</a> <a href="../.././Lean/Elab/Term/TermElabM.html#Lean.Elab.Tactic.SavedState">SavedState</a>))</span>)</span></span></div></div><p>Runs a list of TacticM computations in parallel and collects results in the original order,
including the saved state after each task completes.</p><p>Unlike <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.parIter">parIter</a></code>, this waits for all tasks to complete and returns results
in the same order as the input list, not in completion order.</p><p>Results are wrapped in <code><a href="../.././Init/Prelude.html#Except">Except</a> Exception (α × Tactic.SavedState)</code> so that errors in individual
tasks don't stop the collection - you can observe all results including which tasks failed.</p><p>The final TacticM state is restored to the initial state (before tasks ran).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Tactic.TacticM.par" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Tactic.TacticM.par'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L628-L647">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.par'"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">par'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">(<a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Init/Prelude.html#Except">Except</a> <a href="../.././Lean/Exception.html#Lean.Exception">Exception</a> <span class="fn">α</span>)</span>)</span></span></div></div><p>Runs a list of TacticM computations in parallel and collects results in the original order,
discarding state information.</p><p>Unlike <code><a href="../.././Lean/Elab/Parallel.html#Lean.Core.CoreM.par">par</a></code>, this doesn't return state information from tasks.</p><p>The final TacticM state is restored to the initial state (before tasks ran).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Tactic.TacticM.par'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Elab.Tactic.TacticM.parFirst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Lean/Elab/Parallel.lean#L649-L663">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Lean/Elab/Parallel.html#Lean.Elab.Tactic.TacticM.parFirst"><span class="name">Lean</span>.<span class="name">Elab</span>.<span class="name">Tactic</span>.<span class="name">TacticM</span>.<span class="name">parFirst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">jobs</span> : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">α</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cancel</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a> := <a href="../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM">TacticM</a> <span class="fn">α</span></span></div></div><p>Runs a list of TacticM computations in parallel and returns the first successful result
(by completion order, not list order).</p><p>If <code>cancel := true</code> (the default), cancels all remaining tasks after the first success.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Elab.Tactic.TacticM.parFirst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>